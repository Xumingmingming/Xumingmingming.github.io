<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>外网SSH连接内网Windows上linux虚拟机</title>
      <link href="/2019/06/28/wai-wang-ssh-lian-jie-nei-wang-windows-shang-linux-xu-ni-ji/"/>
      <url>/2019/06/28/wai-wang-ssh-lian-jie-nei-wang-windows-shang-linux-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>外网SSH连接学校内网的Windows科研电脑上的linux虚拟机</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>学校网络之外的外网机器 SSH远程连接 内网电脑对应的外网IP，内网电脑接受到外网SSH连接请求，再通过虚拟机的NAT模式（端口转发模式），即宿主PC机转发外网SSH请求到虚拟机对应的端口号，间接的访问虚拟机的Linux。</p><a id="more"></a><h1 id="prerequisite"><a href="#prerequisite" class="headerlink" title="prerequisite"></a>prerequisite</h1><p>有了思路，我们需要做的准备</p><ol><li>VMware的网络连接选择NAT模式—&gt;达到转发SSH请求到虚拟机的效果</li><li>虚拟机要有对应的SSH服务—&gt;<code>sudo apt-get install openssh-server</code></li><li>使用<strong>nat123</strong>达到内网穿透</li></ol><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><p>学校内网的ip实际上网络经过了很多中间层的映射，而这个映射很复杂的，学校也不可能告诉我们，所以不可以或者很难直接用内网IP映射成外网IP，进而提供SSH服务。</p><p>但是我们可以使用工具，如nat123、神卓互联、花生壳等，将学校内网IP直接映射成外网IP</p><h1 id="let’s-start"><a href="#let’s-start" class="headerlink" title="let’s start"></a>let’s start</h1><h2 id="1-设置VMware"><a href="#1-设置VMware" class="headerlink" title="1 设置VMware"></a>1 设置VMware</h2><ol><li>虚拟网络编辑器</li></ol><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151944.png" alt="虚拟网络编辑器"></p><p>在VMnet8类型换成NAT模式</p><p>在进行NAT设置之前，需要查看虚拟机的IP，使用<code>ifconfig</code></p><pre><code class="bash">aliceyu@aliceyu-virtual-machine:~$ ifconfig ens33     Link encap:Ethernet  HWaddr 00:0c:29:14:cd:ad            inet addr:192.168.11.128  Bcast:192.168.11.255  Mask:255.255.255.0          inet6 addr: fe80::f557:95a2:e8bf:5b89/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:9979 errors:0 dropped:0 overruns:0 frame:0          TX packets:2844 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:8368432 (8.3 MB)  TX bytes:201165 (201.1 KB)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:789 errors:0 dropped:0 overruns:0 frame:0          TX packets:789 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:63342 (63.3 KB)  TX bytes:63342 (63.3 KB)</code></pre><p>可以看到<code>inet addr:192.168.11.128</code>，这个IP其实是<strong>内网IP</strong></p><ol start="2"><li><p>设置NAT</p><ul><li>添加端口转发：</li></ul><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151945.png" alt="屏幕快照 2019-06-26 下午8.35.22"></p><ul><li>设置端口转发</li></ul><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151946.png" alt="屏幕快照 2019-06-26 下午9.06.55"></p></li></ol><p>到现在为止，Windows宿主机已经可以将请求通过虚拟机的NAT模式转发到虚拟机了。</p><p>但是前提是虚拟机要支持openssh-server。默认linux系统里是没有的。</p><h2 id="2-在虚拟机中下载SSH服务"><a href="#2-在虚拟机中下载SSH服务" class="headerlink" title="2 在虚拟机中下载SSH服务"></a>2 在虚拟机中下载SSH服务</h2><h3 id="1-下载-openssh-server"><a href="#1-下载-openssh-server" class="headerlink" title="1. 下载 openssh-server"></a>1. 下载 openssh-server</h3><p>打开Ubuntu的终端，输入：</p><pre><code class="bash">sudo apt-get install openssh-server</code></pre><p>安装完毕后ssh默认已启动。可以使用下述命令查看是否有进程在22端口上监听，即是否已启动：</p><pre><code class="bash">netstat -nat | grep 22</code></pre><h3 id="2-允许root用户远程登录"><a href="#2-允许root用户远程登录" class="headerlink" title="2. 允许root用户远程登录"></a>2. <strong>允许root用户远程登录</strong></h3><ul><li><p>终端输入命令 <strong>sudo vim /etc/ssh/sshd_config</strong> ，修改ssh服务配置文件</p><pre><code class="bash">sudo vim /etc/ssh/sshd_config</code></pre></li><li><p>找到PermitRootLogin，将参数<strong>prohibit-password</strong>改为<strong>yes</strong>，原来是<strong>prohibit-password</strong>，如图所示：</p></li></ul><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151947.png" alt="屏幕快照 2019-06-26 下午8.47.47"></p><ul><li>设置完需ssh配置文件，我们需要要重启ssh服务，命令 <strong>service sshd restart</strong>  或者  <strong>/etc/initd.d/sshd restart</strong></li></ul><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>在Windows宿主机上下载SecureCRT软件。</p><p>打开SecureCRT软件，进行配置：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151948.png" alt="屏幕快照 2019-06-26 下午9.12.05"></p><p>ProtoCol模式选为 <code>SSH2</code>，Port为 <code>22</code>（前面NAT设置等虚拟机端口号），HostName为<code>192.168.124.23</code>（那就是我们宿主PC机的IP地址），UserName为我们Ubuntu的登录账户。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151949.png" alt="屏幕快照 2019-06-26 下午9.13.51"></p><p>PassWord为我们Ubuntu的登录密码</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151950.png" alt="屏幕快照 2019-06-26 下午9.14.29"></p><p>配置完成后，如果成功，会进入虚拟机的界面</p><p>到现在为止，我们已经完成了Windows宿主机通过虚拟机NAT模式转发SSH请求到虚拟机，并且虚拟机支持openssh-server操作。接下来就剩下最后一步：<strong>将windows宿主机的内网IP（就是例子中的192.168.124.23）映射到外网。</strong></p><h2 id="3-使用nat123达到内网穿透"><a href="#3-使用nat123达到内网穿透" class="headerlink" title="3 使用nat123达到内网穿透"></a>3 使用<strong>nat123</strong>达到内网穿透</h2><h3 id="nat相关操作"><a href="#nat相关操作" class="headerlink" title="nat相关操作"></a>nat相关操作</h3><p>在宿主机上下载<a href="http://www.nat123.com/Pages_2_32.jsp" target="_blank" rel="noopener">nat123程序</a> ，使用自己的帐号登录。如没有帐号，可以“注册帐号”进入网站进行注册。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151952.png" alt="屏幕快照 2019-06-26 下午9.21.33"></p><p>主面板/端口映射列表/添加映射</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151953.png" alt="屏幕快照 2019-06-26 下午9.24.47"></p><p>设置映射信息。选择<strong>非网站应用映射类型</strong>。填写内网LINUX地址端口，和外网访问的域名。可以使用自己的域名，也可以使用免费二级域名。外网端口在添加映射时，会自动分配一个可用端口，不用更改。将鼠标放在输入框有向导提示。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151954.png" alt="屏幕快照 2019-06-26 下午9.37.17"></p><p>这是官网的教程：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151956.png" alt="屏幕快照 2019-06-26 下午9.27.54"></p><p>添加映射后，可查看映射状态。将鼠标放在映射图标上有提示当着状态信息。新添加映射一般几分钟内生效。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151957.png" alt="屏幕快照 2019-06-26 下午9.40.31"></p><h2 id="4-进行SSH连接"><a href="#4-进行SSH连接" class="headerlink" title="4 进行SSH连接"></a>4 进行SSH连接</h2><p>用处在外网的电脑连接</p><p>命令行输入：</p><pre><code class="bash">ssh aliceyu@160b2b1e.nat123.cc -p 13604</code></pre><p>解释：</p><pre><code class="properties">aliceyu:虚拟机用户名160b2b1e.nat123.cc:nat123随机分配的域名-p 13604:指定的服务端口号，也是nat123分配的</code></pre><p>其实还有一种连接方式：</p><ol><li><code>ping</code>域名得到外网IP</li></ol><pre><code class="bash">AliceYudeMacBook-Pro:~ alice$ ping 160b2b1e.nat123.ccPING 160b2b1e.nat123.cc (139.199.62.115): 56 data bytes64 bytes from 139.199.62.115: icmp_seq=0 ttl=229 time=42.318 ms64 bytes from 139.199.62.115: icmp_seq=1 ttl=229 time=40.618 ms64 bytes from 139.199.62.115: icmp_seq=2 ttl=229 time=39.732 ms64 bytes from 139.199.62.115: icmp_seq=3 ttl=229 time=46.012 ms64 bytes from 139.199.62.115: icmp_seq=4 ttl=229 time=56.567 ms64 bytes from 139.199.62.115: icmp_seq=5 ttl=229 time=43.138 ms64 bytes from 139.199.62.115: icmp_seq=6 ttl=229 time=56.581 ms64 bytes from 139.199.62.115: icmp_seq=7 ttl=229 time=39.161 ms64 bytes from 139.199.62.115: icmp_seq=8 ttl=229 time=50.325 ms64 bytes from 139.199.62.115: icmp_seq=9 ttl=229 time=37.974 ms64 bytes from 139.199.62.115: icmp_seq=10 ttl=229 time=38.712 ms64 bytes from 139.199.62.115: icmp_seq=11 ttl=229 time=50.818 ms64 bytes from 139.199.62.115: icmp_seq=12 ttl=229 time=39.310 ms</code></pre><p>上述：<code>PING 160b2b1e.nat123.cc (139.199.62.115): 56 data bytes</code>，139.199.62.115就是域名对应的外网IP。</p><ol start="2"><li>ssh连接<code>ssh aliceyu@139.199.62.115 -p 13604</code></li></ol><pre><code class="bash">AliceYudeMacBook-Pro:~ alice$ ssh aliceyu@139.199.62.115 -p 13604aliceyu@139.199.62.115&#39;s password: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.15.0-51-generic x86_64) * Documentation:  https://help.ubuntu.com * Management:     https://landscape.canonical.com * Support:        https://ubuntu.com/advantage148 个可升级软件包。0 个安全更新。New release &#39;18.04.2 LTS&#39; available.Run &#39;do-release-upgrade&#39; to upgrade to it.*** 需要重启系统 ***Last login: Wed Jun 26 21:35:04 2019 from 192.168.124.23aliceyu@aliceyu-virtual-machine:~$ lscore     Downloads         Files  ncbi    TemplatesDesktop  examples.desktop  igv    Public  vmware-rootaliceyu@aliceyu-virtual-machine:~$ </code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/xuliangxing/p/4462929.html" target="_blank" rel="noopener">SSH安装篇之——SecureCRT连接(内网和外网)虚拟机中的Linux系统(Ubuntu)</a></p><p><a href="http://www.nat123.com/Pages_23_539.jsp" target="_blank" rel="noopener">外网SSH访问内网LINUX-非网站应用映射方法</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 奇淫异术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给老婆的故事</title>
      <link href="/2019/06/28/gei-lao-po-de-gu-shi/"/>
      <url>/2019/06/28/gei-lao-po-de-gu-shi/</url>
      
        <content type="html"><![CDATA[<p>有一天，他又去森林里看太阳。他发现在草丛里有一个小女孩，小女孩长得漂亮极了，长长的睫毛看起来好像从童话里走出来的小公主，但是她不知道怎么了，他叫了她几次都没反应，小男孩很担心。于是他那天没有等到太阳落下就背着小女孩回家了。</p><a id="more"></a><p>小女孩在他家里昏睡了三天，小男孩一直尽心的照顾她。三天后，小女孩终于醒了，她看着小男孩就笑了。她告诉小男孩，她是从另外一个世界来的，她看见小男孩每天傻傻的看着太阳，觉得小男孩很可爱，于是就想和小男孩做朋友。小男孩听了后觉得很开心，就留小女孩住下来了。两个人每天一起玩，一起去森林里看太阳。<br>其实，小女孩还有一些事情没有告诉小男孩，她在另一个星球也很孤单，那个星球一个人也没有，她不知道自己为什么在哪里，她也每天看着太阳。她想着，真好，这个世界上还有另外一个人也喜欢看太阳，我以后再也不用一个人了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 给老婆讲故事 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2019/06/28/da-jian-ge-ren-bo-ke/"/>
      <url>/2019/06/28/da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><a id="more"></a><p>在root下安装</p><pre><code class="bash">sudo su</code></pre><ol><li>安装nodejs</li></ol><pre><code class="bash">brew install nodejs</code></pre><ol start="2"><li>更改镜像元</li></ol><pre><code class="bash">npm install -g cnpm --registery=https://registry.npm.taobao.org</code></pre><ol start="3"><li>安装haxo博客</li></ol><pre><code class="bash">cnpm install -g hexo-cli</code></pre><ol start="4"><li>初始化博客</li></ol><p>在根目录创建文件夹</p><pre><code class="bash">sh-3.2# pwd/Users/xuxinghuash-3.2# mkdir blogsh-3.2# cd blog/sh-3.2# lssh-3.2# pwd/Users/xuxinghua/blog</code></pre><p>用管理员的命令来执行</p><pre><code class="bash">sh-3.2# sudo hexo initINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitCloning into &#39;/Users/xuxinghua/blog&#39;...remote: Enumerating objects: 9, done.remote: Counting objects: 100% (9/9), done.remote: Compressing objects: 100% (7/7), done.remote: Total 77 (delta 4), reused 5 (delta 2), pack-reused 68Unpacking objects: 100% (77/77), done.Submodule &#39;themes/landscape&#39; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#39;themes/landscape&#39;Cloning into &#39;/Users/xuxinghua/blog/themes/landscape&#39;...remote: Enumerating objects: 33, done.remote: Counting objects: 100% (33/33), done.remote: Compressing objects: 100% (29/29), done.remote: Total 929 (delta 12), reused 12 (delta 3), pack-reused 896Receiving objects: 100% (929/929), 2.56 MiB | 181.00 KiB/s, done.Resolving deltas: 100% (492/492), done.Submodule path &#39;themes/landscape&#39;: checked out &#39;73a23c51f8487cfcd7c6deec96ccc7543960d350&#39;INFO  Install dependenciesnpm WARN deprecated core-js@1.2.7: core-js@&lt;2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.&gt; fsevents@1.2.9 install /Users/xuxinghua/blog/node_modules/fsevents&gt; node installnode-pre-gyp WARN Using needle for node-pre-gyp https download[fsevents] Success: &quot;/Users/xuxinghua/blog/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node&quot; is installed via remotenpm notice created a lockfile as package-lock.json. You should commit this file.added 408 packages from 520 contributors and audited 6879 packages in 22.577sfound 0 vulnerabilitiesINFO  Start blogging with Hexo!</code></pre><p>可以看下在blog文件夹下生成了哪些文件</p><pre><code class="bash">sh-3.2# ls -ltotal 120-rw-r--r--   1 root staff   1765 Jun 28 19:14 _config.ymldrwxr-xr-x 274 root staff   8768 Jun 28 19:14 node_modules-rw-r--r--   1 root staff 110677 Jun 28 19:14 package-lock.json-rw-r--r--   1 root staff    443 Jun 28 19:14 package.jsondrwxr-xr-x   5 root staff    160 Jun 28 19:14 scaffoldsdrwxr-xr-x   3 root staff     96 Jun 28 19:14 sourcedrwxr-xr-x   3 root staff     96 Jun 28 19:14 themes</code></pre><ol start="5"><li>启动博客</li></ol><pre><code class="bash">sh-3.2# hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><ol start="6"><li>写博客</li></ol><p>比如博客名叫做：我的第一篇博客文章</p><pre><code class="bash">sh-3.2# hexo n &quot;我的第一篇博客文章&quot;</code></pre><h1 id="博客部署到github上公开使用"><a href="#博客部署到github上公开使用" class="headerlink" title="博客部署到github上公开使用"></a>博客部署到github上公开使用</h1><ol><li>新建仓库</li></ol><p>Reposity name：<code>Xumingmingming.github.io</code></p><p>必须是你的github的昵称</p><p>![屏幕快照 2019-06-28 下午10.29.43](assets/屏幕快照 2019-06-28 下午10.29.43.png)</p><ol start="2"><li><p>安装git的部署插件</p><pre><code class="bash">sh-3.2# cnpm install --save hexo-deployer-git</code></pre><p>peerDependencies WARNING 不用管</p></li><li><p>修改_config.yml</p><p>在最后：</p><pre><code class="yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/Xumingmingming/xuxinghua.github.io.git  branch: master</code></pre></li><li><p>部署到远端</p><pre><code class="bash">sh-3.2# hexo d</code></pre></li></ol><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>换的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">这个主题</a></p><ul><li><p>下载主题：</p><p>当前目录在blog目录，clone到<code>blog/themes</code>下的<code>yilia</code>文件夹下</p><pre><code class="bash">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></pre></li><li><p>配置主题</p><p>修改_config.yml</p><pre><code class="yml"># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape</code></pre><p>改成：</p><pre><code class="yml"># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia</code></pre></li><li><p>重启</p><p>Clean—&gt;g(重新生成)—&gt;s(start)</p><pre><code class="bash">sh-3.2# hexo cleanINFO  Deleted database.INFO  Deleted public folder.sh-3.2# hexo gINFO  Start processingINFO  Files loaded in 403 msINFO  Generated: index.htmlINFO  Generated: archives/index.htmlINFO  Generated: fonts/default-skin.b257fa.svgINFO  Generated: img/preloader.gifINFO  Generated: fonts/iconfont.16acc2.ttfINFO  Generated: fonts/iconfont.45d7ee.svgINFO  Generated: img/scrollbar_arrow.pngINFO  Generated: fonts/iconfont.b322fa.eotINFO  Generated: fonts/iconfont.8c627f.woffINFO  Generated: fonts/tooltip.4004ff.svgINFO  Generated: archives/2019/06/index.htmlINFO  Generated: img/default-skin.pngINFO  Generated: archives/2019/index.htmlINFO  Generated: 2019/06/28/我的第一篇博客文章/index.htmlINFO  Generated: 2019/06/28/hello-world/index.htmlINFO  Generated: slider.e37972.jsINFO  Generated: main.0cf68a.cssINFO  Generated: main.0cf68a.jsINFO  Generated: mobile.992cbe.jsINFO  19 files generated in 241 mssh-3.2# hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre></li><li><p>重新部署到远端</p><p>注意修改完后，需要重新在git上部署</p><pre><code class="bash">sh-3.2# hexo d</code></pre></li></ul><h1 id="走过的坑"><a href="#走过的坑" class="headerlink" title="走过的坑"></a>走过的坑</h1><h2 id="访问网站时，网站加载速度慢"><a href="#访问网站时，网站加载速度慢" class="headerlink" title="访问网站时，网站加载速度慢"></a>访问网站时，网站加载速度慢</h2><p>打开Chrome的开发者工具，有2个URL超时，大概1.2min，拖慢速度的就是这两条！！</p><ol><li><p>Request URL: <a href="https://fonts.googleapis.com/css?family=Source+Code+Pro" target="_blank" rel="noopener">https://fonts.googleapis.com/css?family=Source+Code+Pro</a></p></li><li><p>Request URL: <a href="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js</a></p></li></ol><p>措施：</p><ul><li>定位<code>fonts.googleapis.com/css?family=Source+Code+Pro</code>到<code>blog/themes/landscape/layout/_partial/head.ejs</code></li></ul><pre><code class="bash">sudo vi /Users/xuxinghua/blog/themes/landscape/layout/_partial/head.ejs</code></pre><p>将下面注释掉：</p><pre><code class="html">&lt;link href=&quot;//fonts.googleapis.com/css?family=Source+Code+Pro&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code></pre><ul><li><p>定位<code>ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js</code>到<code>blog/themes/landscape/layout/_partial/after-footer.ejs</code></p><pre><code class="bash">sudo vi /Users/xuxinghua/blog/themes/landscape/layout/_partial/after-footer.ejs</code></pre><p>将</p><pre><code class="html">&lt;script src=&quot;//lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js&quot;&gt;&lt;/script&gt;</code></pre></li></ul><p>​       改为</p><pre><code>   ~~~HTMl</code></pre><script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script><pre><code>   ~~~</code></pre><p>成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2019/06/28/wo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2019/06/28/wo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="老婆老婆"><a href="#老婆老婆" class="headerlink" title="老婆老婆~~"></a>老婆老婆~~</h2><p>  老婆老婆我爱你!</p><a id="more"></a><p>  嗷嗷嗷~</p><p>这是一个很古老的传说………… 很久很久以前，在老虎王国有一对兄妹，他们各自身怀特殊的能力。 哥哥有着一对千里眼，能够看到极远方的微小事物 妹妹有着一 对顺风耳，能够听到极其细小的声音 他们从小一起长大 ……………..一起快乐一起悲伤…………… 闲暇时候，他们总会跑到后山的山丘上， 哥哥眺望千里外的遥远国 度，对着妹妹述说着那里各种千奇百怪的事物。 妹妹聆听微风传来的讯息，对着哥哥吟唱着远方教堂传来的天使般的歌声。 或许是长时间在一起的缘故，他们爱上了彼此。 虽然他们知道这段爱情是不被允许的，但他们就是无法控制自己。 他们抛开了一切束缚，开始不顾一切地享受着爱情。 然而， 纸终究是包不住火的，两人的关系被发现了。 父亲大发雷霆，母亲以泪洗面， 街坊邻居对两人指指点点不为什么，只因为他们认为，既然得不到， 两人拼命证明对彼此纯真的感情。 但是，由于道德观念的枷锁，两人终究不被允许，已经无路可走了 ……….. 为了证明对彼此至死不渝的爱， 哥哥弄瞎了自己的眼睛， 妹妹弄聋了自己的耳朵， 众人的祝福，那有这能力又有何用？ 反正他们两人是得不到幸福的一对。 很久很久以后，有个音乐家听到了这个凄美动人的爱情故事，大受感动。 百感交集下，他谱出了一曲感人肺腑的曲子。 &gt; &gt; &gt; 那歌词是这样唱的 ……….. &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 两只老虎 两只老虎 跑得快 跑得快 一只没有眼睛 一只没有耳朵 真奇怪 真奇怪</p>]]></content>
      
      
      
        <tags>
            
            <tag> 我们永远在一起 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 交易优化技术之缓存库存</title>
      <link href="/2019/06/19/di-7-zhang-jiao-yi-you-hua-ji-zhu-zhi-huan-cun-ku-cun/"/>
      <url>/2019/06/19/di-7-zhang-jiao-yi-you-hua-ji-zhu-zhi-huan-cun-ku-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ul><li>掌握高效交易验证方式</li><li>掌握缓存库存模型(解决库存行锁的性能问题)</li></ul><a id="more"></a><h1 id="交易性能瓶颈"><a href="#交易性能瓶颈" class="headerlink" title="交易性能瓶颈"></a>交易性能瓶颈</h1><h2 id="JMeter压测"><a href="#JMeter压测" class="headerlink" title="JMeter压测"></a>JMeter压测</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150922.png" alt="屏幕快照 2019-07-02 下午7.05.46"></p><h2 id="交易验证完全依赖数据库"><a href="#交易验证完全依赖数据库" class="headerlink" title="交易验证完全依赖数据库"></a>交易验证完全依赖数据库</h2><p>OrderServiceImpl.class:</p><pre><code class="java">    @Override    @Transactional    public OrderModel createOrder(Integer userId, Integer itemId, Integer promoId, Integer amount) throws BusinessException {        //1.校验下单状态,下单的商品是否存在，用户是否合法，购买数量是否正确        ItemModel itemModel = itemService.getItemById(itemId);        if(itemModel == null){            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;商品信息不存在&quot;);        }        //校验用户        UserModel userModel = userService.getUserById(userId);        if(userModel == null){            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;用户信息不存在&quot;);        }        if(amount &lt;= 0 || amount &gt; 99){//不能不买，也不能一次买多个            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;数量信息不正确&quot;);        }        //校验活动信息--&gt;是内存操作        if(promoId != null){            //（1）校验对应活动是否存在这个适用商品            if(promoId.intValue() != itemModel.getPromoModel().getId()){                throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;活动信息不正确&quot;);                //（2）校验活动是否正在进行中            }else if(itemModel.getPromoModel().getStatus().intValue() != 2) {                throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;活动信息还未开始&quot;);            }        }        //2.落单减库存        boolean result = itemService.decreaseStock(itemId,amount);        if(!result){            throw new BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);        }        //3.订单入库        OrderModel orderModel = new OrderModel();        orderModel.setUserId(userId);        orderModel.setItemId(itemId);        orderModel.setAmount(amount);        if(promoId != null){            orderModel.setItemPrice(itemModel.getPromoModel().getPromoItemPrice());        }else{            orderModel.setItemPrice(itemModel.getPrice());        }        orderModel.setPromoId(promoId);        orderModel.setOrderPrice(orderModel.getItemPrice().multiply(new BigDecimal(amount)));        //3.1生成交易流水号,订单号        orderModel.setId(generateOrderNo());        OrderDO orderDO = convertFromOrderModel(orderModel);        orderDOMapper.insertSelective(orderDO);        //加上商品的销量        itemService.increaseSales(itemId,amount);        //4.返回前端        return orderModel;    }</code></pre><p>分析：</p><ul><li><p>1.校验下单状态 中的<code>itemService.getItemById(itemId);</code>中，其实操作了3次数据库：</p><ul><li>根据商品id查询<code>item</code>表：<code>itemDOMapper.selectByPrimaryKey(id);</code></li><li>根据商品信息查询库存<code>item_stock</code>表：<code>itemStockDOMapper.selectByItemId(itemDO.getId());</code></li><li>根据商品id查询活动商品信息<code>promo</code>表：<code>promoService.getPromoByItemId(itemModel.getId());</code></li></ul></li><li><p>校验用户</p><ul><li>查询user表：<code>userDOMapper.selectByPrimaryKey(id);</code></li><li>查询use_password表：<code>userPasswordDOMapper.selectByUserId(userDO.getId());</code></li></ul></li><li><p>2.落单减库存 这将会是个热点操作</p><p>最终在<code>item_stock</code>表中完成减库存操作<code>itemStockDOMapper.decreaseStock(itemId,amount);</code></p><p>对应sql语句：有一个<code>item_id = #{itemId}</code>，比如说传入的itemId=6，就会在6这一行加入行锁</p><pre><code class="html">&lt;update id=&quot;decreaseStock&quot;&gt;    update item_stock    set stock = stock - #{amount}    where item_id = #{itemId} and stock &gt;= #{amount}  &lt;/update&gt;</code></pre></li><li><p>3.订单入库</p><ul><li>3.1生成交易流水号 对<code>order_info</code>表：<code>orderDOMapper.insertSelective(orderDO);</code></li><li>加销量，对<code>item</code>表：<code>itemService.increaseSales(itemId,amount);</code></li></ul></li></ul><p>可以看出这里有8次查询数据库的IO操作，而且减库存的操作有一个行锁等待。</p><h2 id="库存行锁"><a href="#库存行锁" class="headerlink" title="库存行锁"></a>库存行锁</h2><p>落单减库存：</p><pre><code class="java">boolean result = itemService.decreaseStock(itemId,amount);</code></pre><p>最终在<code>item_stock</code>表中完成减库存操作<code>itemStockDOMapper.decreaseStock(itemId,amount);</code></p><p>对应sql语句：有一个<code>item_id = #{itemId}</code>，比如说传入的itemId=6，就会在6这一行加入行锁</p><p>ItemStockDOMapper.xml：</p><pre><code class="html">&lt;update id=&quot;decreaseStock&quot;&gt;    update item_stock    set stock = stock - #{amount}    where item_id = #{itemId} and stock &gt;= #{amount}  &lt;/update&gt;</code></pre><p>补充：</p><pre><code class="mysql">update from table set xx=&#39;aa&#39; where yy=&#39;bb&#39;</code></pre><p>这里的yy字段不是主键，但值都是唯一的，这样的话，不加 rowlock时update是锁行还是锁表？</p><blockquote><p>锁表。</p><p>若指定的yy为索引（主键是特殊的索引），只有一条记录，则锁行。<br>若不指定yy为索引，则锁表。</p></blockquote><h2 id="后置处理逻辑"><a href="#后置处理逻辑" class="headerlink" title="后置处理逻辑"></a>后置处理逻辑</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150924.png" alt="未命名文件"></p><h1 id="交易链路优化"><a href="#交易链路优化" class="headerlink" title="交易链路优化"></a>交易链路优化</h1><h2 id="交易验证优化"><a href="#交易验证优化" class="headerlink" title="交易验证优化"></a>交易验证优化</h2><ul><li>用户风控策略优化：策略缓存模型优化</li><li>活动校验策略优化：引入活动发布流程，模型缓存化，紧急下限能力</li></ul><h3 id="UserModel和ItemModel缓存模型"><a href="#UserModel和ItemModel缓存模型" class="headerlink" title="UserModel和ItemModel缓存模型"></a>UserModel和ItemModel缓存模型</h3><ul><li><p>增加<code>UserService.getUserByIdInCache(Integer id);</code>方法</p><p>UserServiceImpl.class：</p><pre><code class="java">@Override    public UserModel getUserByIdInCache(Integer id) {        UserModel userModel= (UserModel) redisTemplate.opsForValue().get(&quot;user_validate_&quot;+id);        if (userModel==null){            userModel=this.getUserById(id);            redisTemplate.opsForValue().set(&quot;user_validate_&quot;+id,userModel);            redisTemplate.expire(&quot;user_validate_&quot;+id,10, TimeUnit.MINUTES);        }        return userModel;    }</code></pre></li></ul><ul><li><p>增加<code>ItemService.getItemByIdInCache(Integer id);</code>方法</p><p>ItemServiceImpl.class:</p><pre><code class="java">@Override    public ItemModel getItemByIdInCache(Integer id) {        ItemModel itemModel= (ItemModel) redisTemplate.opsForValue().get(&quot;item_validate_&quot;+id);        if (itemModel==null){            itemModel=this.getItemById(id);            redisTemplate.opsForValue().set(&quot;item_validate_&quot;+id,itemModel);            redisTemplate.expire(&quot;item_validate_&quot;+id,10, TimeUnit.MINUTES);        }        return itemModel;    }</code></pre></li></ul><h2 id="库存行锁优化"><a href="#库存行锁优化" class="headerlink" title="库存行锁优化"></a>库存行锁优化</h2><p>再回顾下我们的减库存操作：</p><p>ItemStockDOMapper.xml：</p><pre><code class="html">&lt;update id=&quot;decreaseStock&quot;&gt;    update item_stock    set stock = stock - #{amount}    where item_id = #{itemId} and stock &gt;= #{amount}  &lt;/update&gt;</code></pre><p>mysql将会在<code>item_id = #{itemId}</code>的地方加上一个行锁，前提是<code>item_id</code>在数据库里是必须是有索引的。如果没有索引是会锁表的。</p><p>默认<code>item_stock</code>表中的item_id字段是没有索引的，设置索引：</p><pre><code class="mysql">ALTER table item_stock add UNIQUE INDEXitem_id_index(item_id)</code></pre><h3 id="扣减库存缓存化"><a href="#扣减库存缓存化" class="headerlink" title="扣减库存缓存化"></a>扣减库存缓存化</h3><p>在内存中肯定比在磁盘中扣减库存快。</p><p>方案：</p><ul><li>活动发布同步库存进缓存</li><li>下单交易减缓存中库存</li></ul><h4 id="动发布同步库存进缓存"><a href="#动发布同步库存进缓存" class="headerlink" title="动发布同步库存进缓存"></a>动发布同步库存进缓存</h4><p>PromoServiceImpl.class</p><pre><code class="java">@Override    public void publishPromo(Integer promoId) {        //通过活动id获取活动        PromoDO promoDO=promoDOMapper.selectByItemId(promoId);        if (promoDO.getItemId()==null||promoDO.getItemId().intValue()==0){//说明对应的操作不存在，这个活动没有适应的商品            return;        }        ItemModel itemModel=itemService.getItemById(promoDO.getItemId());        //将库存同步到redis内        redisTemplate.opsForValue().set(&quot;promo_item_stock_&quot;+itemModel.getId(),itemModel.getStock());    }</code></pre><p>在ItemController.class中完成发布promo的操作</p><pre><code class="java">@RequestMapping(value = &quot;/publicpromo&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType publicpromo(@RequestParam(name = &quot;id&quot;)Integer id){        promoService.publishPromo(id);        return CommonReturnType.create(null);    }</code></pre><h4 id="下单交易减缓存中库存"><a href="#下单交易减缓存中库存" class="headerlink" title="下单交易减缓存中库存"></a>下单交易减缓存中库存</h4><p>ItemServiceImpl.class中</p><pre><code class="java">    @Override    @Transactional    public boolean decreaseStock(Integer itemId, Integer amount) throws BusinessException {       // int affectedRow =  itemStockDOMapper.decreaseStock(itemId,amount);        Long result=redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue()*-1);        if(result &gt;= 0){            //更新库存成功            return true;        }else{            //更新库存失败            return false;        }    }</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li><p>数据库记录不一致</p><p>内存毕竟是不可靠的，如果宕机，库存信息就会全部消失</p></li></ul><h3 id="异步同步数据库"><a href="#异步同步数据库" class="headerlink" title="异步同步数据库"></a>异步同步数据库</h3><p>采用异步消息队列的方式，将对应的异步扣减的消息同步给消息的<code>consumer</code>端，由这个<code>consumer</code>端完成数据库的扣减操作。</p><h4 id="方案-前两种步骤不变"><a href="#方案-前两种步骤不变" class="headerlink" title="方案(前两种步骤不变)"></a>方案(前两种步骤不变)</h4><ul><li>活动发布同步库存进缓存</li><li>下单交易减缓存中库存</li><li>异步消息扣减数据库内库存</li></ul><p>异步扣减数据库：既能保证用户的一个高效的购买体验，又可以保证数据库最终一致性。</p><h4 id="异步消息队列中间件rocketmq"><a href="#异步消息队列中间件rocketmq" class="headerlink" title="异步消息队列中间件rocketmq"></a>异步消息队列中间件rocketmq</h4><ul><li>高性能，高并发，分布式消息中间件</li><li>典型应用场景：分布式事物，异步解耦</li></ul><h5 id="rocketmq概念模型"><a href="#rocketmq概念模型" class="headerlink" title="rocketmq概念模型"></a>rocketmq概念模型</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150930.png" alt="屏幕快照 2019-07-02 下午10.04.57"></p><h5 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150936.png" alt="屏幕快照 2019-07-02 下午10.07.58"></p><h3 id="分布式事物"><a href="#分布式事物" class="headerlink" title="分布式事物"></a>分布式事物</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150939.png" alt="屏幕快照 2019-07-02 下午10.26.37"></p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>C：一致性</p><p>A：可用性</p><p>P：分区容忍性</p><p>分布式事物中，p分区容忍性是必须的，所以必须在<code>C一致性</code>和<code>A可用性</code>之间做一个选择</p><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p>不追求瞬时状态的强一致，追求的是最终的一致性，也就是我的数据最终会达到一致。</p><p>B：基础可用</p><p>S：软状态</p><p>E：最终一致性</p><p>软状态：在我们的应用当中，会瞬时的存在有数据不一致的情况，比如说一部分数据成功，另外一部分数据还在处理中，那我们的业务认为这些数据是可以容忍的。</p><h4 id="结合到我们缓存库存的模型当中，我们怎么解决这些问题？"><a href="#结合到我们缓存库存的模型当中，我们怎么解决这些问题？" class="headerlink" title="结合到我们缓存库存的模型当中，我们怎么解决这些问题？"></a>结合到我们缓存库存的模型当中，我们怎么解决这些问题？</h4><p>在我们缓存库存当中，我们的redis的状态是正确的状态，比如redis中的库存从87减到86，redis中的86是正确的，但是我们数据库中库存状态由于异步消息队列的consumer端还没有被触发，因此在consumer没有消费完消息之前，数据库里的库存数错的，比如还是87。但是只要这个分布式的消息投递成功了，consumer端消费了这个消息，最终我们数据库中的状态会从87减到86，达到最终一致性。</p><p>这样的话，只要我们使用的消息中间件的高可用性达到99.99%，那至少有99.99%以上的概率，我们数据库里的状态可以和redis中的数据保持一致的。</p><h3 id="数据库中库存数据和缓存中保持最终一致性"><a href="#数据库中库存数据和缓存中保持最终一致性" class="headerlink" title="数据库中库存数据和缓存中保持最终一致性"></a>数据库中库存数据和缓存中保持最终一致性</h3><h4 id="缓存库存接入异步化"><a href="#缓存库存接入异步化" class="headerlink" title="缓存库存接入异步化"></a>缓存库存接入异步化</h4><h5 id="ItemServiceImpl-java"><a href="#ItemServiceImpl-java" class="headerlink" title="ItemServiceImpl.java"></a>ItemServiceImpl.java</h5><pre><code class="java">@Override    @Transactional    public boolean decreaseStock(Integer itemId, Integer amount) throws BusinessException {       // int affectedRow =  itemStockDOMapper.decreaseStock(itemId,amount);        Long result=redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue()*-1);        if(result &gt;= 0){            //更新库存成功            boolean mqResult= mQproducer.ausncReduceStock(itemId,amount);            if (!mqResult){                redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue());                return false;            }            return true;        }else{            redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue());            //更新库存失败            return false;        }    }</code></pre><p>在redis中扣减完库存后，将扣减库存的消息发送给MQ。使用的是<code>mQproducer.ausncReduceStock(itemId,amount)</code>方法：</p><h5 id="引入消息生产者MQproducer-java"><a href="#引入消息生产者MQproducer-java" class="headerlink" title="引入消息生产者MQproducer.java"></a>引入消息生产者MQproducer.java</h5><pre><code class="java">//同步库存扣减消息    public boolean ausncReduceStock(Integer itemId,Integer amount)  {        Map&lt;String,Object&gt; bodyMap=new HashMap&lt;&gt;();        bodyMap.put(&quot;itemId&quot;,itemId);        bodyMap.put(&quot;amount&quot;,amount);        Message message=new Message(topicName,&quot;increase&quot;, JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(&quot;UTF-8&quot;)));        try {            producer.send(message);        } catch (MQClientException e) {            return false;        } catch (RemotingException e) {            return false;        } catch (MQBrokerException e) {            return false;        } catch (InterruptedException e) {            return false;        }        return true;    }</code></pre><h5 id="引入MQconsumer-java"><a href="#引入MQconsumer-java" class="headerlink" title="引入MQconsumer.java"></a>引入MQconsumer.java</h5><pre><code class="java">@Componentpublic class MQconsumer {    private DefaultMQPushConsumer consumer;    @Value(&quot;${mq.nameserver.addr}&quot;)    private String nameAddr;    @Value(&quot;${mq.topicname}&quot;)    private String topicName;    @Autowired    private ItemStockDOMapper itemStockDOMapper;    @PostConstruct    public void init() throws MQClientException {        consumer=new DefaultMQPushConsumer(&quot;stock_consumer_group&quot;);        consumer.setNamesrvAddr(nameAddr);        consumer.subscribe(topicName,&quot;*&quot;);        consumer.registerMessageListener(new MessageListenerConcurrently() {            @Override            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext consumeConcurrentlyContext) {               //实现库存真正到数据库内扣减的逻辑                Message message=msgs.get(0);                String jsonstring=new String(message.getBody());                Map&lt;String,Object&gt; map= JSON.parseObject(jsonstring, Map.class);                Integer itemId= (Integer) map.get(&quot;itemId&quot;);                Integer amount= (Integer) map.get(&quot;amount&quot;);                itemStockDOMapper.decreaseStock(itemId,amount);                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;            }        });        consumer.start();    }}</code></pre><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li><p>异步消息发送失败</p><p><code>MQproducer.java</code>中的<code>producer.send(message)</code>消息发送失败了，我们现在没有解决。</p></li><li><p>扣减操作失败</p><p>若库存扣减这个操作执行失败了，这条扣减消息应该怎么处理</p></li><li><p>下单失败无法正确回补库存</p><p>若用户取消订单了，我们怎么回滚库存呢</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 查询优化技术之页面静态化</title>
      <link href="/2019/06/18/di-6-zhang-cha-xun-you-hua-ji-zhu-zhi-ye-mian-jing-tai-hua-dong-tai-qing-qiu-jia-jing-tai-ye-mian-yi-tong-jing-tai-hua/"/>
      <url>/2019/06/18/di-6-zhang-cha-xun-you-hua-ji-zhu-zhi-ye-mian-jing-tai-hua-dong-tai-qing-qiu-jia-jing-tai-ye-mian-yi-tong-jing-tai-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li><p>优化的是H5(static)，请求走静态资源文件。</p></li><li><p>将静态资源的请求路由到CDN</p></li></ul><a id="more"></a><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150911.png" alt="秒杀结构图"></p><h1 id="静态请求CDN"><a href="#静态请求CDN" class="headerlink" title="静态请求CDN"></a>静态请求CDN</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150911.jpg" alt="v2-2080dfe83dd76bd079dbf3e7348ca795_hd"></p><p>结构图</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150912.png" alt="秒杀结构图"></p><h2 id="DNS用CNAME解析源站"><a href="#DNS用CNAME解析源站" class="headerlink" title="DNS用CNAME解析源站"></a>DNS用CNAME解析源站</h2><h2 id="回源缓存设置"><a href="#回源缓存设置" class="headerlink" title="回源缓存设置"></a>回源缓存设置</h2><h3 id="cache-control响应头"><a href="#cache-control响应头" class="headerlink" title="cache control响应头"></a>cache control响应头</h3><p>Request Headers：</p><p>例：</p><pre><code class="properties">GET / HTTP/1.1Host: localhost:4000Connection: keep-alivePragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: Hm_lvt_512065947708a980c982b4401d14c2f5=1551084094; SESSION=OGQzOGIzMGEtZGYyNy00MjQ4LWI1ZGYtMjc2OTAxYjJmNjEz</code></pre><p>###cache control有几种取值：</p><ul><li><p>private：客户端可以缓存(请求发起的浏览器才可以缓存)</p></li><li><p>public：客户端和代理服务器（反向或正向代理）都可以缓存</p></li><li><p>max-age=xxx：缓存的内容将在xxx秒之后失效</p><p>也就是说我们对应缓存的内容，从收到服务端的这个max-age返回数据开始，存储xxx秒后这个请求就失效，客户端必须往对应的服务端上面再次发起请求，用来验证和结束对应的请求体</p></li><li><p>no-cache：强制向服务端再验证一次(<strong>会将对应的缓存存储在客户端，但是在下次用的时候要向服务端验证一次这个缓存到底是能用还是不能用，no-store是压根不存</strong>)</p></li><li><p>no-store：不缓存请求的任何返回内容</p></li></ul><h4 id="怎么选择HTTP-cache-control头？"><a href="#怎么选择HTTP-cache-control头？" class="headerlink" title="怎么选择HTTP cache control头？"></a>怎么选择HTTP cache control头？</h4><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150913.png" alt="未命名文件-2"></p><h3 id="有效性判断"><a href="#有效性判断" class="headerlink" title="有效性判断"></a>有效性判断</h3><ul><li>ETag：资源唯一标识</li><li>If-None-Match：客户端发送的匹配ETag标识符</li><li>Last-modified：资源最后被修改时间</li><li>If-Modified-Since：客户端发送的匹配资源最后修改时间的标识符</li></ul><p>补充：</p><p>ETag：</p><p>一般是将请求的资源做一个MD5或者类似hash操作，生成一个ETag的唯一标识，服务端在第一次返回内容中加上这个ETag的唯一标识，一起返回给浏览器，浏览器会存储下来这个ETag；下一次请求的时候，所谓的有效性判断，是浏览器将之前缓存下来内容的ETag的值一起带到服务器上，用来验证说它不发送具体的响应，而是发送一个对应的HTTP请求并且带上这个ETag的值，服务端会将这个ETag的值和我本地的文件ETag内容做比较，若比较是一致的，就返回304 not-modified，告诉客户端说服务端这个内容是有效的，直接使用浏览器里的缓存即可</p><p>若If-Modified-Since的值早于Last-modified的值，证明是无效的；若晚于Last-modified的值，则是有效的，说明这段时间资源没有被修改过。</p><h3 id="用户请求浏览器资源的网站路径"><a href="#用户请求浏览器资源的网站路径" class="headerlink" title="用户请求浏览器资源的网站路径"></a>用户请求浏览器资源的网站路径</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150914.png" alt="未命名文件"></p><h3 id="浏览器三种刷新方式"><a href="#浏览器三种刷新方式" class="headerlink" title="浏览器三种刷新方式"></a>浏览器三种刷新方式</h3><ul><li>回车刷新或者a链接(get请求跳转)：看cache-control对应的max-age是否仍然有效，有效则直接从cache取对应的数据，若cache-control中为no-cache，则进入缓存协商逻辑</li><li>F5刷新(Windows)或者command+R(macOS)刷新：去掉cache-control中的max-age或者直接设置max-age为0，然后进入缓存协商逻辑</li><li>ctrl+F5或commond+shift+R刷新：去掉cache-control和协商头，强制刷新 (强制从服务端拿内容)</li></ul><p>对应的协商机制：</p><p>比较Last-modified和ETag到服务端，若服务端判断没变化则304不返回数据，否则200返回数据</p><h3 id="CDN自定义缓存策略"><a href="#CDN自定义缓存策略" class="headerlink" title="CDN自定义缓存策略"></a>CDN自定义缓存策略</h3><ul><li>可自定义目录过期时间</li><li>可自定义后缀名过期时间</li><li>可自定义对应权重</li><li>可通过界面或api强制cdn对应目录刷新(不一定保证成功)</li></ul><h4 id="阿里云CDN配置"><a href="#阿里云CDN配置" class="headerlink" title="阿里云CDN配置"></a>阿里云CDN配置</h4><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150915.png" alt="屏幕快照 2019-07-01 下午9.20.29"></p><h3 id="静态资源部署策略-1"><a href="#静态资源部署策略-1" class="headerlink" title="静态资源部署策略(1)"></a>静态资源部署策略(1)</h3><ol><li>css,js,img等元素使用带版本号部署，例如<code>a.js？=v1.0</code>不便利，且维护困难</li><li>css,js,img等元素使用带摘要（hash获得）部署，例如a<code>.js？=45edw</code>，存在先部署html还是先部署资源的覆盖问题</li><li>css,js,img等元素使用带摘要做文件名部署，例如<code>45edw.js</code>，新老版本并存且可回滚，资源部署完后再部署HTML</li></ol><p>采用第三种</p><h3 id="静态资源部署策略-2"><a href="#静态资源部署策略-2" class="headerlink" title="静态资源部署策略(2)"></a>静态资源部署策略(2)</h3><ol><li><p>对静态资源保持生命周期内不会变，max-age可设置很长，无视失效更新周期</p></li><li><p>html文件设置no-cache或较短max-age，以便更新</p></li><li><p>html文件仍然设置较长的max-age，依靠动态的获取版本号请求发送到后端，异步下载最新的版本号的html展示渲染在前端</p><p>将html文件缓存。html每次都能展示缓存离的内容，没有问题，但是html文件里面每次在启动的时候有一个很小很小的<code>ajax</code>请求头，ajax请求做的事情就是带着本地的html版本号去我的服务端调用一个动态的接口，这个动态的接口比较ajax中html版本号和后端的版本号是否是最新的；如果是的话，对应的html渲染到前端即可；如果不是，就需要在后端从新下载最新版本号的html(<strong>异步更新策略</strong>)</p></li></ol><p>第三种方式是最好的，但是一般第二种也足够使用</p><h3 id="静态资源部署策略-3"><a href="#静态资源部署策略-3" class="headerlink" title="静态资源部署策略(3)"></a>静态资源部署策略(3)</h3><p>上面讨论的都是静态资源文件</p><ol><li>动态请求可以静态化成json资源推送到cdn上</li><li>依靠异步请求获取后端节点对应资源状态做紧急下架处理</li><li>可通过跑批紧急推送cdn内容以使其下架等操作</li></ol><h2 id="强推失效"><a href="#强推失效" class="headerlink" title="强推失效"></a>强推失效</h2><h1 id="全页面静态化"><a href="#全页面静态化" class="headerlink" title="全页面静态化"></a>全页面静态化</h1><ul><li>html，css，js静态资源cdn化</li><li>js，ajax动态请求cdn化</li><li>全页面静态化</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在服务端完成html，css，甚至js的load；并且渲染成纯html文件后直接以静态资源的方式部署到cdn上</p><h2 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h2><p>可以理解为无头浏览器，可以借助其模拟webkit js的执行</p><ul><li>演示样例</li></ul><p>js:</p><pre><code class="js">var page = require(&#39;webpage&#39;).create();page.open(&#39;http://www.baidu.com&#39;, function() {    setTimeout(function() {        page.render(&#39;baidu.png&#39;);        phantom.exit();    }, 200);});</code></pre><ul><li>运行：</li></ul><pre><code class="bash">phantomjs spiderbaidu.js</code></pre><ul><li>结果：</li></ul><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150916.png" alt="baidu"></p><h2 id="phantomjs应用"><a href="#phantomjs应用" class="headerlink" title="phantomjs应用"></a>phantomjs应用</h2><ul><li>修改需要全页面静态化的实现，采用<code>initView</code>和<code>hasInit</code>方式防止多次初始化</li><li>编写对应轮询生成内容方式</li><li>将全静态化页面生成后推送到CDN</li></ul><p>1.在<code>/usr/local/Caskroom/phantomjs/2.1.1/phantomjs-2.1.1-macosx/js/</code>下创建<code>getitem.js</code></p><pre><code class="js">var page = require(&quot;webpage&quot;).create();var fs = require(&quot;fs&quot;);page.open(&quot;http://localhost/resources/getitem.html?id=6&quot;,function(status){    console.log(&quot;status= &quot;+status);   fs.write(&quot;getitem.html&quot;,page.content,&quot;w&quot;);   phantom.exit();});</code></pre><p>2.执行</p><pre><code class="bash">xuxinghua@xxhdemac:/usr/local/Caskroom/phantomjs/2.1.1/phantomjs-2.1.1-macosx/js$ phantomjs getitem.jsstatus= success</code></pre><p>成功后会在当前目录生成<code>getitem.html</code></p><pre><code class="bash">xuxinghua@xxhdemac:/usr/local/Caskroom/phantomjs/2.1.1/phantomjs-2.1.1-macosx/js$ lsgetitem.html  getitem.js</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 查询优化技术之多级缓存</title>
      <link href="/2019/06/17/di-5-zhang-cha-xun-you-hua-ji-zhu-zhi-duo-ji-huan-cun/"/>
      <url>/2019/06/17/di-5-zhang-cha-xun-you-hua-ji-zhu-zhi-duo-ji-huan-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ul><li>掌握多级缓存的定义</li><li>掌握redis缓存，本地缓存：不同应用场景的使用，以及他们的优劣</li><li>掌握热点nginx lua缓存</li></ul><a id="more"></a><h1 id="缓存设计原则"><a href="#缓存设计原则" class="headerlink" title="缓存设计原则"></a>缓存设计原则</h1><ul><li>用快速存取设备，用内存</li><li>将缓存推到离用户最近的地方</li><li>脏缓存清理</li></ul><p><strong>补：</strong></p><p>1.为什么将缓存推到离用户最近的地方？</p><p>现在有：前端的H5，nginx的反向代理，有miaoshaserver的Tomcat应用服务器，以及对应的数据库的mysql。缓存应该建在哪些地方呢？原则就是将缓存推到离用户最近的地方。<strong>==缓存离用户越近，用户对应访问的数据走的链路也就越少，对应的查询效率也就越高。==</strong></p><p>2.一旦数据库里面的数据发送变化，那么该数据在缓存中就成了脏数据</p><h1 id="多机缓存"><a href="#多机缓存" class="headerlink" title="多机缓存"></a>多机缓存</h1><ul><li>redis缓存</li><li>热点内存本地缓存</li><li>nginx proxy cache缓存</li><li>nginx lua 缓存</li></ul><p>补：</p><p><strong>==热点内存本地缓存：redis毕竟是有网络对应的开销，可以将热点数据做到jvm内存的本地缓存中==</strong></p><h1 id="redis缓存"><a href="#redis缓存" class="headerlink" title="redis缓存"></a>redis缓存</h1><p>redis具有存储数据库的能力，但是需要允许一定数量数据丢失的。在我们做redis使用的时候，我们其实很少特别关心数据的完整性问题，经常还会把它当做一个易失性的<strong>集中式缓存中间件</strong>并且<strong>基于KV内存级别的存储</strong>。</p><h3 id="redis定位"><a href="#redis定位" class="headerlink" title="redis定位"></a>redis定位</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150861.png" alt="未命名文件"></p><h2 id="redis使用"><a href="#redis使用" class="headerlink" title="redis使用"></a>redis使用</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><p>1.单个机子有内存上限</p><p>2.单点故障问题。单机redis服务器出现故障，整个应用程序就不能用了。比如将token存储在redis中的用户登录操作</p><h3 id="sentinal哨兵模式"><a href="#sentinal哨兵模式" class="headerlink" title="sentinal哨兵模式"></a>sentinal哨兵模式</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150900.png" alt="未命名文件-2"></p><h3 id="集群cluster模式"><a href="#集群cluster模式" class="headerlink" title="集群cluster模式"></a>集群cluster模式</h3><p>redis cluster数据同步+paxos竞争算法</p><h3 id="商品详情动态内容实现"><a href="#商品详情动态内容实现" class="headerlink" title="商品详情动态内容实现"></a>商品详情动态内容实现</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在redis中存储对应商品ID的<code>ItemModel</code>对象(JSON序列化后的)</p><p>之后的请求可以根据URL上传来的商品ID在redis中查找对应的<code>ItemModel</code>对象，减少了3次mysql查询操作，加快查询效率</p><h4 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h4><p>ItemController.class</p><pre><code class="java">    //商品详情页浏览    @RequestMapping(value = &quot;/get&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType getItem(@RequestParam(name = &quot;id&quot;)Integer id){        ItemModel itemModel = itemService.getItemById(id);        ItemVO itemVO = convertVOFromModel(itemModel);        return CommonReturnType.create(itemVO);    }</code></pre><p>ItemServiceImpl.class</p><pre><code class="java">    @Override    public ItemModel getItemById(Integer id) {        ItemDO itemDO = itemDOMapper.selectByPrimaryKey(id);        if(itemDO == null){            return null;        }        //操作获得库存数量        ItemStockDO itemStockDO = itemStockDOMapper.selectByItemId(itemDO.getId());        //将dataobject-&gt;model        ItemModel itemModel = convertModelFromDataObject(itemDO,itemStockDO);        //获取活动商品信息        PromoModel promoModel = promoService.getPromoByItemId(itemModel.getId());        if(promoModel != null &amp;&amp; promoModel.getStatus().intValue() != 3){            itemModel.setPromoModel(promoModel);        }        return itemModel;    }</code></pre><p>有三次数据库操作：1.获得商品基本信息 2.获得商品库存信息 3.获得商品活动信息</p><h4 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h4><p>优化点：直接在Controller层缓存商品信息，不走<code>itemService.getItemById(id);</code>操作去查询数据库</p><pre><code class="java">    //商品详情页浏览    @RequestMapping(value = &quot;/get&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType getItem(@RequestParam(name = &quot;id&quot;)Integer id){        //根据商品的id到redis内获取        ItemModel itemModel= (ItemModel) redisTemplate.opsForValue().get(&quot;item_&quot;+id);        //若redis内存不存在对应的itemModel，则访问下游service        if (itemModel==null){            itemModel = itemService.getItemById(id);            //设置itemModel到redis内            redisTemplate.opsForValue().set(&quot;item_&quot;+id,itemModel);            //设置键值对的失效时间,10分钟            redisTemplate.expire(&quot;item_&quot;+id,10, TimeUnit.MINUTES);        }        ItemVO itemVO = convertVOFromModel(itemModel);        return CommonReturnType.create(itemVO);    }</code></pre><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>1.输入<code>http://localhost:8090/item/get?id=6</code></p><p>2.返回</p><pre><code class="json">status    &quot;success&quot;data    id    6title    &quot;iphone99&quot;price    800stock    60description    &quot;最好用的苹果手机&quot;sales    152imgUrl    &quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg&quot;promoStatus    2promoPrice    100promoId    1startDate    &quot;2018-01-19 00:04:30&quot;</code></pre><p>3.redis-server</p><pre><code class="bash">202.117.35.220:6379&gt; SELECT 10OK202.117.35.220:6379[10]&gt; KEYS *1) &quot;\xac\xed\x00\x05t\x00\x06item_6&quot;202.117.35.220:6379[10]&gt; get &quot;\xac\xed\x00\x05t\x00\x06item_6&quot;&quot;\xac\xed\x00\x05sr\x000com.imooc.miaoshaproject.service.model.ItemModeln\x88\x87\xf0:\xa5i\xdd\x02\x00\bL\x00\x0bdescriptiont\x00\x12Ljava/lang/String;L\x00\x02idt\x00\x13Ljava/lang/Integer;L\x00\x06imgUrlq\x00~\x00\x01L\x00\x05pricet\x00\x16Ljava/math/BigDecimal;L\x00\npromoModelt\x003Lcom/imooc/miaoshaproject/service/model/PromoModel;L\x00\x05salesq\x00~\x00\x02L\x00\x05stockq\x00~\x00\x02L\x00\x05titleq\x00~\x00\x01xpt\x00\x18\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xbasr\x00\x11java.lang.Integer\x12\xe2\xa0\xa4\xf7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x00\x06t\x00^https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpgsr\x00\x14java.math.BigDecimalT\xc7\x15W\xf9\x81(O\x03\x00\x02I\x00\x05scaleL\x00\x06intValt\x00\x16Ljava/math/BigInteger;xq\x00~\x00\b\x00\x00\x00\x00sr\x00\x14java.math.BigInteger\x8c\xfc\x9f\x1f\xa9;\xfb\x1d\x03\x00\x06I\x00\bbitCountI\x00\tbitLengthI\x00\x13firstNonzeroByteNumI\x00\x0clowestSetBitI\x00\x06signum[\x00\tmagnitudet\x00\x02[Bxq\x00~\x00\b\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff\xfe\x00\x00\x00\x01ur\x00\x02[B\xac\xf3\x17\xf8\x06\bT\xe0\x02\x00\x00xp\x00\x00\x00\x02\x03 xxsr\x001com.imooc.miaoshaproject.service.model.PromoModelC$\x13\x1f\x19\xa6\xe2\xa0\x02\x00\aL\x00\aendDatet\x00\x18Lorg/joda/time/DateTime;L\x00\x02idq\x00~\x00\x02L\x00\x06itemIdq\x00~\x00\x02L\x00\x0epromoItemPriceq\x00~\x00\x03L\x00\tpromoNameq\x00~\x00\x01L\x00\tstartDateq\x00~\x00\x14L\x00\x06statusq\x00~\x00\x02xpsr\x00\x16org.joda.time.DateTime\xb8&lt;xdj[\xdd\xf9\x02\x00\x00xr\x00\x1forg.joda.time.base.BaseDateTime\xff\xff\xf9\xe1O].\xa3\x02\x00\x02J\x00\aiMillisL\x00\x0biChronologyt\x00\x1aLorg/joda/time/Chronology;xp\x00\x00\x01oW\x89\x18\x00sr\x00&#39;org.joda.time.chrono.ISOChronology$Stub\xa9\xc8\x11fq7P&#39;\x03\x00\x00xpsr\x00\x1forg.joda.time.DateTimeZone$Stub\xa6/\x01\x9a|2\x1a\xe3\x03\x00\x00xpw\x0f\x00\rAsia/Shanghaixxsq\x00~\x00\a\x00\x00\x00\x01q\x00~\x00\tsq\x00~\x00\x0b\x00\x00\x00\x00sq\x00~\x00\x0e\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff\xfe\x00\x00\x00\x01uq\x00~\x00\x11\x00\x00\x00\x01dxxt\x00\x13iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8sq\x00~\x00\x16\x00\x00\x01a\n\x03\xb2\xb0q\x00~\x00\x1bsq\x00~\x00\a\x00\x00\x00\x02sq\x00~\x00\a\x00\x00\x00\x98sq\x00~\x00\a\x00\x00\x00&lt;t\x00\biphone99&quot;</code></pre><p>采用的是java序列化方式</p><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><p>对应的<code>ItemModel</code>需要<code>implements Serializable</code></p><p>对应的<code>PromoModel</code>需要 <code>implements Serializable</code>  </p><h4 id="序列化优化"><a href="#序列化优化" class="headerlink" title="序列化优化"></a>序列化优化</h4><h5 id="1-将redis中的KV做指定序列化处理"><a href="#1-将redis中的KV做指定序列化处理" class="headerlink" title="1.将redis中的KV做指定序列化处理"></a>1.将redis中的KV做指定序列化处理</h5><p>key做String序列化，value做json序列化处理</p><p>RedisConfig.class</p><pre><code class="java">@Component@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)//默认是1800public class RedisConfig {    @Bean    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){        RedisTemplate redisTemplate=new RedisTemplate();        redisTemplate.setConnectionFactory(redisConnectionFactory);        //首先解决key的序列化方式,，序列化String        StringRedisSerializer stringRedisSerializer=new StringRedisSerializer();        redisTemplate.setKeySerializer(stringRedisSerializer);        //解决value的序列化方式        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=new Jackson2JsonRedisSerializer(Object.class);        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);        return redisTemplate;    }}</code></pre><p><strong>实验</strong></p><pre><code class="bash">202.117.35.220:6379[10]&gt; KEYS *1) &quot;item_6&quot;202.117.35.220:6379[10]&gt; get item_6&quot;{\&quot;id\&quot;:6,\&quot;title\&quot;:\&quot;iphone99\&quot;,\&quot;price\&quot;:800,\&quot;stock\&quot;:60,\&quot;description\&quot;:\&quot;\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xba\&quot;,\&quot;sales\&quot;:152,\&quot;imgUrl\&quot;:\&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg\&quot;,\&quot;promoModel\&quot;:{\&quot;id\&quot;:1,\&quot;status\&quot;:2,\&quot;promoName\&quot;:\&quot;iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8\&quot;,\&quot;startDate\&quot;:{\&quot;secondOfDay\&quot;:270,\&quot;minuteOfDay\&quot;:4,\&quot;centuryOfEra\&quot;:20,\&quot;yearOfEra\&quot;:2018,\&quot;yearOfCentury\&quot;:18,\&quot;weekyear\&quot;:2018,\&quot;monthOfYear\&quot;:1,\&quot;weekOfWeekyear\&quot;:3,\&quot;hourOfDay\&quot;:0,\&quot;minuteOfHour\&quot;:4,\&quot;secondOfMinute\&quot;:30,\&quot;millisOfSecond\&quot;:0,\&quot;millisOfDay\&quot;:270000,\&quot;dayOfMonth\&quot;:19,\&quot;dayOfWeek\&quot;:5,\&quot;era\&quot;:1,\&quot;dayOfYear\&quot;:19,\&quot;year\&quot;:2018,\&quot;chronology\&quot;:{\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;}},\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;millis\&quot;:1516291470000,\&quot;afterNow\&quot;:false,\&quot;beforeNow\&quot;:true,\&quot;equalNow\&quot;:false},\&quot;endDate\&quot;:{\&quot;secondOfDay\&quot;:0,\&quot;minuteOfDay\&quot;:0,\&quot;centuryOfEra\&quot;:20,\&quot;yearOfEra\&quot;:2019,\&quot;yearOfCentury\&quot;:19,\&quot;weekyear\&quot;:2020,\&quot;monthOfYear\&quot;:12,\&quot;weekOfWeekyear\&quot;:1,\&quot;hourOfDay\&quot;:0,\&quot;minuteOfHour\&quot;:0,\&quot;secondOfMinute\&quot;:0,\&quot;millisOfSecond\&quot;:0,\&quot;millisOfDay\&quot;:0,\&quot;dayOfMonth\&quot;:31,\&quot;dayOfWeek\&quot;:2,\&quot;era\&quot;:1,\&quot;dayOfYear\&quot;:365,\&quot;year\&quot;:2019,\&quot;chronology\&quot;:{\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;}},\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;millis\&quot;:1577721600000,\&quot;afterNow\&quot;:true,\&quot;beforeNow\&quot;:false,\&quot;equalNow\&quot;:false},\&quot;itemId\&quot;:6,\&quot;promoItemPrice\&quot;:100}}&quot;</code></pre><p>结果还是不好，进一步需要对<code>PromoModel</code>中的<code>Datetime</code>进行序列化</p><h5 id="2-对Datetime进行json序列化"><a href="#2-对Datetime进行json序列化" class="headerlink" title="2.对Datetime进行json序列化"></a>2.对Datetime进行json序列化</h5><p>RedisConfig.class</p><pre><code class="java">@Component@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)//默认是1800public class RedisConfig {    @Bean    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){        RedisTemplate redisTemplate=new RedisTemplate();        redisTemplate.setConnectionFactory(redisConnectionFactory);        //首先解决key的序列化方式,，序列化String        StringRedisSerializer stringRedisSerializer=new StringRedisSerializer();        redisTemplate.setKeySerializer(stringRedisSerializer);        //解决value的序列化方式        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=new Jackson2JsonRedisSerializer(Object.class);        //序列化Datetime        ObjectMapper objectMapper=new ObjectMapper();        SimpleModule simpleModule=new SimpleModule();        simpleModule.addSerializer(DateTime.class,new JodaDatimeJsonSerializer());        simpleModule.addDeserializer(DateTime.class,new JodaDateTimeJsonDeserializer());        objectMapper.registerModule(simpleModule);        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);        return redisTemplate;    }}</code></pre><p>结果：</p><pre><code class="bash">202.117.35.220:6379[10]&gt; GEt item_6&quot;{\&quot;id\&quot;:6,\&quot;title\&quot;:\&quot;iphone99\&quot;,\&quot;price\&quot;:800,\&quot;stock\&quot;:60,\&quot;description\&quot;:\&quot;\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xba\&quot;,\&quot;sales\&quot;:152,\&quot;imgUrl\&quot;:\&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg\&quot;,\&quot;promoModel\&quot;:{\&quot;id\&quot;:1,\&quot;status\&quot;:2,\&quot;promoName\&quot;:\&quot;iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8\&quot;,\&quot;startDate\&quot;:\&quot;2018-01-19 00:04:30\&quot;,\&quot;endDate\&quot;:\&quot;2019-12-31 00:00:00\&quot;,\&quot;itemId\&quot;:6,\&quot;promoItemPrice\&quot;:100}}&quot;</code></pre><h5 id="3-在redis中value值里如类信息"><a href="#3-在redis中value值里如类信息" class="headerlink" title="3.在redis中value值里如类信息"></a>3.在redis中value值里如类信息</h5><p>RedisConfig.class</p><pre><code class="java">//在value中加入对应类的信息        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</code></pre><p>最终结果：</p><pre><code class="bash">202.117.35.220:6379[10]&gt; GEt item_6&quot;[\&quot;com.imooc.miaoshaproject.service.model.ItemModel\&quot;,{\&quot;id\&quot;:6,\&quot;title\&quot;:\&quot;iphone99\&quot;,\&quot;price\&quot;:[\&quot;java.math.BigDecimal\&quot;,800],\&quot;stock\&quot;:60,\&quot;description\&quot;:\&quot;\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xba\&quot;,\&quot;sales\&quot;:152,\&quot;imgUrl\&quot;:\&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg\&quot;,\&quot;promoModel\&quot;:[\&quot;com.imooc.miaoshaproject.service.model.PromoModel\&quot;,{\&quot;id\&quot;:1,\&quot;status\&quot;:2,\&quot;promoName\&quot;:\&quot;iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8\&quot;,\&quot;startDate\&quot;:\&quot;2018-01-19 00:04:30\&quot;,\&quot;endDate\&quot;:\&quot;2019-12-31 00:00:00\&quot;,\&quot;itemId\&quot;:6,\&quot;promoItemPrice\&quot;:[\&quot;java.math.BigDecimal\&quot;,100]}]}]&quot;</code></pre><h2 id="redis集中式缓存压测效果验证"><a href="#redis集中式缓存压测效果验证" class="headerlink" title="redis集中式缓存压测效果验证"></a>redis集中式缓存压测效果验证</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150901.png" alt="屏幕快照 2019-06-23 下午2.03.04"></p><h1 id="本地热点缓存"><a href="#本地热点缓存" class="headerlink" title="本地热点缓存"></a>本地热点缓存</h1><ul><li>存放热点数据</li><li>脏读非常不敏感</li><li>内存可控</li></ul><p>注：</p><p><strong>本地缓存其实就是==java虚拟机JVM的缓存==</strong></p><h2 id="Guava-cache"><a href="#Guava-cache" class="headerlink" title="Guava cache"></a>Guava cache</h2><p>单纯的hashmap是无法满足的</p><p>1.并发读写</p><p>2.内存淘汰机制</p><h3 id="介绍-Guava"><a href="#介绍-Guava" class="headerlink" title="介绍 Guava"></a>介绍 Guava</h3><ul><li>可控制的大小和超时时间</li><li>可配置的lru策略</li><li>线程安全</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为我们是多机缓存，先找<code>1.本地缓存</code>，不存在<code>2.找redis</code>，还不存在<code>3.找mysql数据库</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a>引入jar包</h4><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;com.google.guava&lt;/groupId&gt;      &lt;artifactId&gt;guava&lt;/artifactId&gt;      &lt;version&gt;18.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h4 id="ItemController-class"><a href="#ItemController-class" class="headerlink" title="ItemController.class"></a>ItemController.class</h4><pre><code class="java">//商品详情页浏览    @RequestMapping(value = &quot;/get&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType getItem(@RequestParam(name = &quot;id&quot;)Integer id){        ItemModel itemModel=null;        //先取本地缓存        itemModel=(ItemModel)cacheService.getFromCommonCache(&quot;item_&quot;+id);        //本地缓存没有，找redis        if (itemModel==null){            //根据商品的id到redis内获取            itemModel= (ItemModel) redisTemplate.opsForValue().get(&quot;item_&quot;+id);            //若redis内存不存在对应的itemModel，则访问下游itemService查询数据库            if (itemModel==null){                itemModel = itemService.getItemById(id);                //设置itemModel到redis内                redisTemplate.opsForValue().set(&quot;item_&quot;+id,itemModel);                //设置键值对的失效时间,10分钟                redisTemplate.expire(&quot;item_&quot;+id,10, TimeUnit.MINUTES);            }            //填充本地缓存            cacheService.setCommonCache(&quot;item_&quot;+id,itemModel);        }        ItemVO itemVO = convertVOFromModel(itemModel);        return CommonReturnType.create(itemVO);    }</code></pre><h2 id="本地缓存缺点"><a href="#本地缓存缺点" class="headerlink" title="本地缓存缺点"></a>本地缓存缺点</h2><p>1.当本地热点缓存中数据发生更新时，本地热点缓存没有好的机制去更新</p><p>2.本地热点缓存还有一个JVM容量大小的限制</p><h1 id="nginx缓存"><a href="#nginx缓存" class="headerlink" title="nginx缓存"></a>nginx缓存</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150902.png" alt="秒杀结构图"></p><p>本地缓存：</p><p>1.nginx将用户请求分发到<code>miaosha.jar</code>中，并经过<code>org.springframework.web.servlet. DispatcherServlet</code>中转发，需要启动java代码完成对应的操作，总规是有消耗 </p><p>2.nginx和miaosha.jar直接的局域网连接</p><p>试想一下，我们是不是可以把缓存在nginx上做？</p><p>因为nginx是里用户H5最近的一个节点，若我们把对应的热点数据做到nginx上的话，优化的策略会更好。</p><h2 id="1-nginx-proxy-cache缓存"><a href="#1-nginx-proxy-cache缓存" class="headerlink" title="1.nginx proxy cache缓存"></a>1.nginx proxy cache缓存</h2><ul><li>nginx反向代理前置</li><li>依靠文件系统存对应索引的文件</li><li>依靠内存缓存文件地址</li></ul><h3 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h3><pre><code>#申明一个cache缓存节点的内容proxy_cache_path /usr/local/Cellar/openresty/1.15.8.1/nginx/tmp_cache levels=1:2 keys_zone=tmp_cache:100m inactive=7d max_size=10g;location / {proxy_pass http://backend_server;#nginx proxy cacheproxy_cache tmp_cache;proxy_cache_key $uri;proxy_cache_valid 200 206 304 302 7d;proxy_set_header Host $http_host:$proxy_port;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_http_version 1.1;proxy_set_header Connection &quot;&quot;;}</code></pre><h3 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h3><p>在浏览器输入<code>http://localhost/item/get?id=6</code></p><p>如果配置成功，linux服务器的<code>/xxh009/miaosha/tomcat/access_log.2019-06-23.log</code>里，多次刷新页面，也只有一行记录</p><pre><code class="bash">115.154.255.245 - - [23/Jun/2019:19:22:02 +0800] &quot;GET /item/get?id=6 HTTP/1.1&quot; 200 328 37</code></pre><p>并且在<code>/usr/local/Cellar/openresty/1.15.8.1/nginx/tmp_cache/中有对应的缓存文件</code></p><p>比如</p><pre><code class="bash"> xuxinghua@xxhdemac /usr/local/Cellar/openresty/1.15.8.1/nginx/tmp_cache/8/f6 cat 86e4d1b3ba4f1464e409c74be4ef6f68�]��������c`]ksr�`�KEY: /item/getHTTP/1.1 200Content-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Sun, 23 Jun 2019 11:22:02 GMT{&quot;status&quot;:&quot;success&quot;,&quot;data&quot;:{&quot;id&quot;:6,&quot;title&quot;:&quot;iphone99&quot;,&quot;price&quot;:800,&quot;stock&quot;:60,&quot;description&quot;:&quot;最好用的苹果手机&quot;,&quot;sales&quot;:152,&quot;imgUrl&quot;:&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg&quot;,&quot;promoStatus&quot;:2,&quot;promoPrice&quot;:100,&quot;promoId&quot;:1,&quot;startDate&quot;:&quot;2018-01-19 00:04:30&quot;}}%</code></pre><h3 id="压测及结果分析"><a href="#压测及结果分析" class="headerlink" title="压测及结果分析"></a>压测及结果分析</h3><p>压测完后，其实还没有之前的速度快，为什么呢？</p><p>因为我们做的这个nginx proxy cache的数据是存放在本地磁盘的，读写磁盘效率很低，还不如nginx与miaosha.jar直接的网络传输效率高。</p><p>所以不用nginx proxy cache。</p><h2 id="2-nginx-lua"><a href="#2-nginx-lua" class="headerlink" title="2.nginx lua"></a>2.nginx lua</h2><ul><li>lua协程机制</li><li>nginx协程机制</li><li>nginx lua插载点</li><li>OpenResty</li></ul><h3 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h3><ul><li>依附于线程的内存模型，切换开销小</li><li>遇阻塞及归还执行权，代码同步</li><li>无需加锁</li></ul><h3 id="nginx协程"><a href="#nginx协程" class="headerlink" title="nginx协程"></a>nginx协程</h3><ul><li>nginx的每一个Worker进程都是在epoll或kqueue这种事件模型之上，封装成协程</li><li>每一个请求都有一个协程进行处理</li><li>即使ngx_lua需要运行lua，相对C有一定的开销，但依旧能保证高并发能力</li></ul><h4 id="nginx协程机制"><a href="#nginx协程机制" class="headerlink" title="nginx协程机制"></a>nginx协程机制</h4><ul><li>nginx每个工作进程创建一个lua虚拟机</li><li>工作进程内的所有协程共享同一个vm</li><li>每一个外部请求由一个lua协程处理，之间数据隔离</li><li>lua代码调用io等异步接口时，协程被挂起，保存上下文数据保持不变</li><li>自动保持，不阻塞工作进程</li><li>io异步操作完成后还有协程上下文，代码继续执行</li></ul><h3 id="nginx处理阶段"><a href="#nginx处理阶段" class="headerlink" title="nginx处理阶段"></a>nginx处理阶段</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150903.png" alt="屏幕快照 2019-06-23 下午8.04.21"></p><p>*_handler 用户可以定制</p><h3 id="nginx-lua插载点"><a href="#nginx-lua插载点" class="headerlink" title="nginx lua插载点"></a>nginx lua插载点</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150904.png" alt="屏幕快照 2019-06-23 下午8.07.26"></p><ol><li>Init_by_lua:系统启动时调用</li><li>init_worker_by_lua:worker进程启动时调用</li><li>set_by_lua:nginx变量使用复杂lua return</li><li>rewrite_by_lua:重写url规则</li><li>access_by_lua:权限验证阶段</li><li>content_by_lua:内容输出节点</li></ol><h4 id="content-by-lua-内容输出节点"><a href="#content-by-lua-内容输出节点" class="headerlink" title="content_by_lua:内容输出节点"></a>content_by_lua:内容输出节点</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p>拦截url为<code>/staticitem/get</code>的请求</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>1.在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下新建staticitem.lua脚本</p><p>staticitem.lua</p><pre><code class="lua">ngx.say(&quot;hello static item lua&quot;);</code></pre><p>意思就是：</p><p>以HTTP response的形式返回字符串<code>&quot;hello static item lua&quot;</code></p><p>2.修改nginx.conf</p><pre><code>location /staticitem/get {content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/staticitem.lua;}</code></pre><h5 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150905.png" alt="屏幕快照 2019-06-23 下午8.35.18"></p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>nginx可以拦截nginx.conf中的location请求，将url路由到我们配置lua脚本做相应的处理。比如上面的例子中nginx就可以将<code>/staticitem/get</code>请求对应到我们编写的taticitem.lua，最终向浏览器返回<code>hello static item lua</code></p><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><ul><li>OpenResty由Nginx核心+很多第三方模块组成，默认集成Lua开发环境，使得Nginx可以作为一个Web Server使用。</li><li>借助于Nginx的事件驱动模型和非阻塞IO，可以实现高性能的Web应用程序</li><li>OpenResty提供了大量组件如mysql、redis、memcached等等，使在nginx上开发Web应用程序更方便更简单</li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ul><li>OpenResty hello world</li><li>shared dic:共享内存字典，所有进程可见，lru淘汰(替换到nginx自己的基于文件系统的proxy cache)</li><li>OpenResty对redis的支持</li></ul><h5 id="OpenResty-hello-world"><a href="#OpenResty-hello-world" class="headerlink" title="OpenResty hello world"></a>OpenResty hello world</h5><ol><li>在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下创建helloworld.lua脚本</li></ol><pre><code class="lua">ngx.exec(&quot;/item/get?id=6&quot;);</code></pre><ol start="2"><li><p>修改nginx.conf配置</p><pre><code>#openresty helloworldlocation /helloworld{content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/helloworld.lua;}</code></pre></li><li><p>实验</p></li></ol><p>输入<a href="http://localhost/helloworld" target="_blank" rel="noopener"><code>http://localhost/helloworld</code></a></p><p>显示：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150905.jpg" alt="11"></p><h5 id="shared-dic"><a href="#shared-dic" class="headerlink" title="shared dic"></a>shared dic</h5><ol><li><p>在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下创建itemshareddic.lua脚本</p><pre><code class="lua">function get_from_cache(key)        local cache_ngx=ngx.shared.my_cache        local value=cache_ngx:get(key)        return valueendfunction set_to_cache(key,value,exptime)        if not exptime then              exptime =0        end        local cache_ngx=ngx.shared.my_cache        local succ,err,forcible=cache_ngx:set(key,value,exptime)        return succendlocal args=ngx.req.get_uri_args();local id=args[&quot;id&quot;]local item_model=get_from_cache(&quot;item_&quot;..id);if item_model == nil then      local resp=ngx.location.capture(&quot;/item/get?id=&quot;..id)      item_model = resp.body      set_to_cache(&quot;item_&quot;..id,item_model,1*60)endngx.say(item_model)</code></pre></li><li><p>修改nginx.conf</p><pre><code>location /luaitem/get {default_type &quot;application/json&quot;;content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/itemshareddic.lua;}</code></pre></li><li><p>实验</p><p>输入<a href="http://localhost/luaitem/get?id=6" target="_blank" rel="noopener">http://localhost/luaitem/get?id=6</a></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150906.jpg" alt="实验图"></p></li></ol><h5 id="OpenResty对redis的支持"><a href="#OpenResty对redis的支持" class="headerlink" title="OpenResty对redis的支持"></a>OpenResty对redis的支持</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150907.jpg" alt="openresty对redis支持"></p><ol><li><p>在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下创建itemredi.lua脚本</p><pre><code class="lua">local args=ngx.req.get_uri_args()local id=args[&quot;id&quot;]local redis= require &quot;resty.redis&quot;local cache=redis:new()local ok,err= cache:connect(&quot;localhost&quot;,6379)local item_model=cache:get(&quot;item_&quot;..id)if item_model==ngx.null or item_model==nil then    local resp=ngx.location.capture(&quot;/item/get?id=&quot;..id)    item_model=resp.bodyendngx.say(item_model)</code></pre></li><li><p>修改nginx.conf</p><pre><code>location /luaitem/get {default_type &quot;application/json&quot;;content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/itemredis.lua;}</code></pre></li><li><p>实验</p><p>输入<a href="http://localhost/luaitem/get?id=6" target="_blank" rel="noopener">http://localhost/luaitem/get?id=6</a></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150906.jpg" alt="实验图"></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 分布式扩展</title>
      <link href="/2019/06/16/di-4-zhang-fen-bu-shi-kuo-zhan/"/>
      <url>/2019/06/16/di-4-zhang-fen-bu-shi-kuo-zhan/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ul><li>nginx反向代理负载均衡</li><li>分布式会话管理</li><li>使用redis实现分布式会话存储</li></ul><a id="more"></a><p>单机部署结构：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150840.png" alt="未命名文件"></p><p>#nginx反向代理负载均衡</p><h2 id="单机容量问题，水平扩展"><a href="#单机容量问题，水平扩展" class="headerlink" title="单机容量问题，水平扩展"></a>单机容量问题，水平扩展</h2><p>表象：单机cpu使用率增高，memory占用增加，网络带宽使用增加</p><p>cpu us：用户空间的cpu使用情况(用户层代码)</p><p>cpu sy：内核空间的cpu使用情况(系统调用)</p><p>load average：1,5,15分钟load平均值，跟着核数系数（比如2核cpu，这个数字在2以下就是正常的），0代表通常，1代表打满，1+代表等待阻塞</p><p>memory：free空闲内存，used使用内存</p><h3 id="水平扩展方案"><a href="#水平扩展方案" class="headerlink" title="水平扩展方案"></a>水平扩展方案</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150853.png" alt="未命名文件-2"></p><p>我们需要4台服务器来完成上述的水平扩展，1台用于nginx，1台用户mysql，2台用于部署miaosha.jar(java Application)</p><h3 id="mysql数据库开放远端连接"><a href="#mysql数据库开放远端连接" class="headerlink" title="mysql数据库开放远端连接"></a>mysql数据库开放远端连接</h3><p>默认情况下，mysql帐号不允许从远程登陆，只能在localhost登录。</p><h4 id="添加用户权限"><a href="#添加用户权限" class="headerlink" title="添加用户权限"></a>添加用户权限</h4><ol><li>如果你想root使用123456（密码）从任何主机连接到mysql服务器的话。</li></ol><pre><code class="mysql">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;</code></pre><p>*.*：所有的databases和所有的表</p><p><strong>‘root’@’%’</strong>：用户名为root的用户，%：所有的host</p><p><strong>IDENTIFIED BY ‘123456’</strong>：但是必须知道密码：123456</p><ol start="2"><li>使修改生效，就可以了</li></ol><pre><code class="mysql">mysql&gt;FLUSH PRIVILEGES;</code></pre><h3 id="服务端水平对称部署"><a href="#服务端水平对称部署" class="headerlink" title="服务端水平对称部署"></a>服务端水平对称部署</h3><p>在2台服务器上分别部署miaosha.jar</p><h3 id="验证访问"><a href="#验证访问" class="headerlink" title="验证访问"></a>验证访问</h3><p><a href="http://202.117.35.220:8080/item/get?id=6" target="_blank" rel="noopener">http://202.117.35.220:8080/item/get?id=6</a></p><p>和</p><p><a href="http://202.117.35.221:8080/item/get?id=6" target="_blank" rel="noopener">http://202.117.35.221:8080/item/get?id=6</a></p><p>是否访问正常</p><h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>部署图：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><p>nginx主要有3种功能：</p><p>使用nginx做为web服务器</p><p>使用nginx作为动静分离服务器</p><p>使用nginx作为反向代理服务器</p><h3 id="修改前端资源"><a href="#修改前端资源" class="headerlink" title="修改前端资源"></a>修改前端资源</h3><p>在<code>htmlStable</code>目录下添加<code>gethost.js</code></p><pre><code class="js">var g_host = &quot;localhost:8090&quot;;</code></pre><p>在对应的前端代码也改了</p><p>如<code>getotp.html</code>中的</p><p>head标签中添加<code>gethost.js</code></p><pre><code class="html">&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;link href=&quot;static/assets/global/plugins/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;link href=&quot;static/assets/global/css/components.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;link href=&quot;static/assets/admin/pages/css/login.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;script src=&quot;static/assets/global/plugins/jquery-1.11.0.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./gethost.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><p>ajax请求：</p><pre><code class="js">$.ajax({                type:&quot;POST&quot;,                contentType:&quot;application/x-www-form-urlencoded&quot;,                url:&quot;http://&quot;+g_host+&quot;/user/getotp&quot;,                data:{                    &quot;telphone&quot;:$(&quot;#telphone&quot;).val(),                },</code></pre><h3 id="安装openResty"><a href="#安装openResty" class="headerlink" title="安装openResty"></a>安装openResty</h3><ol><li>解压：</li></ol><pre><code class="bash">tar -xvzf openresty-1.13.6.2.tar.gz</code></pre><ol start="2"><li>由于是源码下载的方式，进行配置编译</li></ol><pre><code class="bash">#编译bash脚本./configure</code></pre><p>直接进行步骤2，会直接报错</p><pre><code class="bash">ERROR: failed to run command: make install TARGET_STRIP=@: CCDEBUG=-g XCFLAGS=&#39;-DLUAJIT_ENABLE_LUA52COMPAT -msse4.2&#39; CC=cc PREFIX=/usr/local/openresty/luajit DESTDIR=/Users/xuxinghua/java/项目/秒杀/Java电商秒杀系统深度优化 从容应对亿级流量挑战/工具包/openresty-1.13.6.2/build/luajit-root/</code></pre><p>在第二步前，安装前准备</p><pre><code class="bash">apt-get install libpcre3-dev \    libssl-dev perl make build-essential curl</code></pre><p>然后</p><pre><code class="bash">cd openresty-1.13.6.2/./configure</code></pre><ol start="3"><li>安装openResty</li></ol><p><strong>使用下面的命令来编译</strong></p><pre><code class="bash">make</code></pre><p>如果您的电脑支持多核 <code>make</code> 工作的特性, 您可以这样编译:</p><pre><code class="bash">make -j2</code></pre><p>假设您是的机器是双核。</p><p><strong>make install</strong></p><p>如果前面的步骤都没有问题的话,您可以使用下面的命令安装 <a href="http://openresty.org/cn/openresty.html" target="_blank" rel="noopener">OpenResty</a> 到您的系统中：</p><pre><code class="bash">make install</code></pre><h2 id="使用nginx做为web服务器"><a href="#使用nginx做为web服务器" class="headerlink" title="使用nginx做为web服务器"></a>使用nginx做为web服务器</h2><ul><li>location节点path：指定url映射key</li><li>location节点内容：root指定location path后对应的根路径，index指定默认的访问页</li><li>==sbin/nginx -c conf/nginx.conf启动==</li><li>==修改配置后直接sbin/nginx -s reload无缝重启==</li></ul><h4 id="linux启动nginx"><a href="#linux启动nginx" class="headerlink" title="linux启动nginx"></a>linux启动nginx</h4><pre><code class="bash">sbin/nginx -c conf/nginx.conf</code></pre><p>查看nignx进程</p><pre><code class="bash">ps -ef|grep nginx</code></pre><p>查看80端口是否被占用</p><pre><code class="bash">netstat -an |grep 80</code></pre><h4 id="mac上启动nginx"><a href="#mac上启动nginx" class="headerlink" title="mac上启动nginx"></a>mac上启动nginx</h4><p>由于使用homebrew安装openResty</p><pre><code class="bash">xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin sudo ./nginx</code></pre><h3 id="前端资源的部署"><a href="#前端资源的部署" class="headerlink" title="前端资源的部署"></a>前端资源的部署</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><h4 id="更改文件读写权限"><a href="#更改文件读写权限" class="headerlink" title="更改文件读写权限"></a>更改文件读写权限</h4><pre><code class="bash">sudo chmod 777 需要写入的文件名</code></pre><p>例子：</p><p>需要将 <code>~/java/项目/秒杀/Java电商秒杀系统深度优化 从容应对亿级流量挑战/源码/第四章.分布式扩展/htmlStable</code>目录下的前端资源传输到<code>202.117.35.221</code>服务器上</p><pre><code class="bash">scp -r * hpms@202.117.35.221:/usr/local/openresty/nginx/html</code></pre><p>出现错误：</p><pre><code class="bash">scp 文件 : /目录: Permission denied </code></pre><p>解决方法：</p><p>进入<code>/usr/local/openresty/nginx</code>赋予<code>html</code>文件夹权限</p><pre><code class="bash">sudo chmod 777 html</code></pre><p><strong>将当前目录下的所有文件及子目录的文件拥有者权限设置为读、写、可执行，文件拥有者所在的用户组成员具备读、写、可执行权限，其它用户也具备读、写、可执行权限</strong></p><h4 id="nginx-config文件"><a href="#nginx-config文件" class="headerlink" title="nginx.config文件"></a>nginx.config文件</h4><pre><code class="bash">#user  nobody;worker_processes  1;#1个工作进程#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;#可以接受工作连接1024个}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;#http请求的客户端和nginx服务端连接timeout    #gzip  on;    server {        listen       80;#服务端口        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /         # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ {        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #}        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ /\.ht {        #    deny  all;        #}    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}</code></pre><h4 id="使用openresty登录前端"><a href="#使用openresty登录前端" class="headerlink" title="使用openresty登录前端"></a>使用openresty登录前端</h4><p>比如访问login.html页面</p><p>在浏览器上输入：</p><p><a href="http://202.117.35.221:80/login.html" target="_blank" rel="noopener">http://202.117.35.221:80/login.html</a></p><p><code>nginx.config</code>中设置的<code>root</code>是<code>html</code></p><p>所以在地址后面加上html目录下的html文件名，openresty会直接映射到服务端/usr/local/openresty/nginx/html目录下，找相应的html文件</p><h3 id="前端资源路由"><a href="#前端资源路由" class="headerlink" title="前端资源路由"></a>前端资源路由</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><h4 id="1-修改nginx-config"><a href="#1-修改nginx-config" class="headerlink" title="1 修改nginx.config"></a>1 修改nginx.config</h4><pre><code>location /resources/ {            alias /usr/local/openresty/nginx/html/resources/;            index  index.html index.htm;        }</code></pre><h4 id="2-转移前端资源到resources目录下"><a href="#2-转移前端资源到resources目录下" class="headerlink" title="2 转移前端资源到resources目录下"></a>2 转移前端资源到resources目录下</h4><p>将<code>/usr/local/openresty/nginx/html/</code>目录下的文件转移到<code>/usr/local/openresty/nginx/html/resources/</code>目录下:</p><p>转移前<code>html</code>目录下：</p><pre><code class="bash">-rw-r--r-- 1 root root  541  6月 17 10:13 50x.html-rwxr-xr-x 1 hpms hpms 3093  6月 18 11:17 createitem.html*-rwxr-xr-x 1 hpms hpms   36  6月 18 11:22 gethost.js*-rwxr-xr-x 1 hpms hpms 5185  6月 18 11:17 getitem.html*-rwxr-xr-x 1 hpms hpms 1880  6月 18 11:17 getotp.html*-rw-r--r-- 1 root root  649  6月 17 10:13 index.html-rwxr-xr-x 1 hpms hpms 1976  6月 18 11:17 listitem.html*-rwxr-xr-x 1 hpms hpms 2354  6月 18 11:17 login.html*-rwxr-xr-x 1 hpms hpms 3496  6月 18 11:17 register.html*drwxr-xr-x 8 hpms hpms 4096  6月 18 11:18 static/</code></pre><p>使用mv命令</p><pre><code class="bash">hpms@hpms-1:/usr/local/openresty/nginx$ mkdir resourceshpms@hpms-1:/usr/local/openresty/nginx$ mv *.html resources/hpms@hpms-1:/usr/local/openresty/nginx$ mv gethost.js resources/#转移static/目录hpms@hpms-1:/usr/local/openresty/nginx$ mv static resources/</code></pre><h4 id="3-无缝重启nginx"><a href="#3-无缝重启nginx" class="headerlink" title="3 无缝重启nginx"></a>3 无缝重启nginx</h4><pre><code class="bash">hpms@hpms-1:/usr/local/openresty/nginx$ sbin/nginx -s reload</code></pre><h2 id="使用nginx作为动静分离服务器"><a href="#使用nginx作为动静分离服务器" class="headerlink" title="使用nginx作为动静分离服务器"></a>使用nginx作为动静分离服务器</h2><p>location节点path热定resources：静态资源路径</p><p>location节点其他路径：动态资源用</p><p>修改<code>nginx.config</code>中</p><h3 id="静态请求"><a href="#静态请求" class="headerlink" title="静态请求"></a>静态请求</h3><p>设置了静态资源访问路径：</p><p>即当服务器发来的url:<code>nginx服务器的IP地址/resources/</code>，比如<code>115.154.255.245/resources/</code> ，nginx会访问.<code>/nginx/html/resources/</code>下的静态页面</p><pre><code class="bash">location /resources/ {            alias /usr/local/openresty/nginx/html/resources/;            index  index.html index.htm;        }</code></pre><h3 id="动态请求"><a href="#动态请求" class="headerlink" title="动态请求"></a>动态请求</h3><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host &amp;http_host:8090;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}</code></pre><p>当从用户浏览器传来的URL:<code>nginx服务器的IP地址/</code>，如<code>115.154.255.245/user/get?id=6</code>,会把请求分发到后端部署了<code>miaosha.jar</code>的服务器上处理</p><h2 id="使用nginx作为反向代理服务器"><a href="#使用nginx作为反向代理服务器" class="headerlink" title="使用nginx作为反向代理服务器"></a>使用nginx作为反向代理服务器</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><h3 id="设置upstream-server"><a href="#设置upstream-server" class="headerlink" title="设置upstream server"></a>设置upstream server</h3><p>视频上：</p><pre><code class="bash">upstream backend_server{server 202.117.35.220 weight=1;server 202.117.35.221 weight=1;}</code></pre><p>跟着视频上的步骤行不通，于是上网查了资料，很纳闷，逻辑都正确，弄了一下午的时间</p><p>最后终于正确了。</p><p>正确的：</p><pre><code class="bash">upstream backend_server{     server 202.117.35.220:8090 weight=1;     server 202.117.35.221:8090 weight=1;}</code></pre><h3 id="设置动态请求location为proxy-pass路径"><a href="#设置动态请求location为proxy-pass路径" class="headerlink" title="设置动态请求location为proxy pass路径"></a>设置动态请求location为proxy pass路径</h3><p>视频上：</p><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host $http_host:$proxy_port;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}</code></pre><p>正确的</p><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}</code></pre><h3 id="血的教训"><a href="#血的教训" class="headerlink" title="血的教训"></a>血的教训</h3><p>以后配环境一定要看清楚符号</p><p>比如正确的应该是<code>$host</code>是<code>$</code>，而我打成了<code>&amp;host</code>，郁闷了，整了一个下午。</p><p>error.log里面显示的端口一直是默认的：80</p><h3 id="开启Tomcat-access-log-验证"><a href="#开启Tomcat-access-log-验证" class="headerlink" title="开启Tomcat access log 验证"></a>开启Tomcat access log 验证</h3><p><code>application.properties</code>中修改</p><pre><code class="bash">server.tomcat.accesslog.enabled=trueserver.tomcat.accesslog.directory=/home/hpms/xxh009/miaosha/tomcatserver.tomcat.accesslog.pattern=%h %l %u %t &quot;%r&quot; %s %b %D</code></pre><pre><code class="properties">%h:远端host，ip地址%l:--%u:remote user%t:处理时长&quot;%r&quot;:对应http请求的第一行%s:http返回状态码%b:请求response的大小%D:处理请求的时长</code></pre><p>创建好后，<code>/home/hpms/xxh009/miaosha/tomcat</code>目录下会产生log文件，比如<code>access_log.2019-06-18.log</code></p><p>当有请求来时，<code>/home/hpms/xxh009/miaosha/tomcat/access_log.2019-06-18.log</code>文件内会出现：</p><pre><code class="bash">115.154.255.245 - - [18/Jun/2019:21:35:22 +0800] &quot;GET /item/get?id=6 HTTP/1.0&quot; 200 316 732</code></pre><pre><code class="properties">115.154.255.245:host 其实就是反向代理发过来的%l:--&quot;%r&quot;:&quot;GET /item/get?id=6 HTTP/1.0&quot;状态码:200发送了316个字节使用了732ms</code></pre><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><p>设置weight=1，nginx会轮询2个ip地址上的<code>miaosha.jar</code>服务</p><pre><code class="bash">upstream backend_server{     server 202.117.35.220:8090 weight=1;     server 202.117.35.221:8090 weight=1;}</code></pre><h2 id="分布式扩展后性能压测"><a href="#分布式扩展后性能压测" class="headerlink" title="分布式扩展后性能压测"></a>分布式扩展后性能压测</h2><p><code>nginx</code>和<code>miaosha.jar</code>服务器之间默认的是短连接，可以开启nginx的keepalive模式，进一步提升性能</p><h3 id="nginx和upstream后端服务器建立keep-alive长连接"><a href="#nginx和upstream后端服务器建立keep-alive长连接" class="headerlink" title="nginx和upstream后端服务器建立keep-alive长连接"></a>nginx和upstream后端服务器建立keep-alive长连接</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>使用长连接解决分布式扩展后nginx服务器和upstream后端服务器网络建联的消耗</p><h4 id="为什么nginx和后端服务器upstream默认是短连接呢？"><a href="#为什么nginx和后端服务器upstream默认是短连接呢？" class="headerlink" title="为什么nginx和后端服务器upstream默认是短连接呢？"></a>为什么nginx和后端服务器upstream默认是短连接呢？</h4><p>那是因为nginx和后端服务器默认使用的是<code>HTTP1.0</code>的协议，默认的<code>HTTP1.0</code>协议默认是不支持keepalive的，需要默认设置<code>connection:keep-alive</code>.</p><p>我们设置反向代理层往后端服务器发送使用<code>HTTP1.1</code>的协议</p><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_http_version 1.1;proxy_set_header Connection &quot;&quot;;}</code></pre><h3 id="后端服务器和数据库"><a href="#后端服务器和数据库" class="headerlink" title="后端服务器和数据库"></a>后端服务器和数据库</h3><p>使用miaoshaserver自带的Druid数据库的连接池解决了跟数据源之间的建联消耗</p><h1 id="nginx高性能原因"><a href="#nginx高性能原因" class="headerlink" title="nginx高性能原因"></a>nginx高性能原因</h1><h2 id="epoll多路复用"><a href="#epoll多路复用" class="headerlink" title="epoll多路复用"></a>epoll多路复用</h2><p>java BIO模型：阻塞进程式</p><p>linux select模型，变更触发轮询查找，有1024数量上限</p><p>epoll模型，变更触发回调直接读取，理论上没有上限</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150858.png" alt="未命名文件-4"></p><h2 id="master-worker进程模型"><a href="#master-worker进程模型" class="headerlink" title="master-worker进程模型"></a>master-worker进程模型</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150859.png" alt="屏幕快照 2019-06-19 下午3.16.29"></p><h3 id="图形介绍"><a href="#图形介绍" class="headerlink" title="图形介绍"></a>图形介绍</h3><p>管理员：可以理解为root操作用户，用于启动和管理nginx进程</p><p>信号：启动nginx，<code>sbin/nginx -c conf/nginx.conf</code></p><p>master根据nignx.congif中的<code>worker_processes  1;</code>fork出worker进程，它们主子进程的关系</p><p>work进程才是真正处理和客户端连接的</p><h3 id="平滑重启"><a href="#平滑重启" class="headerlink" title="平滑重启"></a>平滑重启</h3><pre><code class="bash">sbin/nginx -s reload</code></pre><p>一般修改完配置文件，重启服务都会断开原本和socket的连接，也就是断开服务</p><h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><pre><code class="bash"> xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin ps -ef|grep nginx    0 22467     1   0  8:58PM ??         0:00.05 nginx: master process ./nginx   -2 23614 22467   0 12:48PM ??         0:21.92 nginx: worker process  501 24958 23250   0  4:08PM ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn nginx xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin sudo ./nginx -s reloadPassword: xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin ps -ef|grep nginx    0 22467     1   0  8:58PM ??         0:00.06 nginx: master process ./nginx   -2 24971 22467   0  4:08PM ??         0:00.00 nginx: worker process  501 24981 23250   0  4:08PM ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn nginx</code></pre><p>可以看到，<code>master process</code>进程号2次都没变，都是<code>22467</code>，而<code>worker process</code>一次是<code>23614</code>，一次是<code>24971</code></p><p>补充：</p><p>每个<code>worker process</code>中都是单线程，执行没有阻塞的任务</p><h2 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h2><p>比线程更小的内存模型，一个线程可以有多个协程；没有线程CPU的切换开销，只有内存的切换开销</p><ul><li>依附于线程的内存模型，切换开销小</li><li>遇阻塞及归还执行权，代码同步</li><li>无需加锁</li></ul><h1 id="分布式会话管理"><a href="#分布式会话管理" class="headerlink" title="分布式会话管理"></a>分布式会话管理</h1><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>基于cookie传输sessionid：java tomcat容器session实现</p><p>基于token传输类似sessionid：java代码session实现</p><h3 id="基于cookie传输sessionid"><a href="#基于cookie传输sessionid" class="headerlink" title="基于cookie传输sessionid"></a>基于cookie传输sessionid</h3><p>目前实现的秒杀是通过cookie传输sessionid的，springboot中的Tomcat帮我师兄了session</p><p>比如：在浏览器上输入 <a href="http://localhost/user/get?id=23" target="_blank" rel="noopener">http://localhost/user/get?id=23</a> 对应的请求头 <code>Request Header</code>中会有cookie</p><pre><code class="properties">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Connection: keep-aliveCookie: Hm_lvt_512065947708a980c982b4401d14c2f5=1551084094; JSESSIONID=3C16C7B4DB293A1F56D3EB3C8A3FFACDHost: localhostUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36</code></pre><p>JSESSIONID其实就是Tomcat返回的内置cookie的标识，JSESSIONID对应到Tomcat内就是来获取对应用户的session的</p><h3 id="基于token传输类似sessionid"><a href="#基于token传输类似sessionid" class="headerlink" title="基于token传输类似sessionid"></a>基于token传输类似sessionid</h3><p>移动手机端常用</p><h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><h3 id="会话管理出现的问题分析"><a href="#会话管理出现的问题分析" class="headerlink" title="会话管理出现的问题分析"></a>会话管理出现的问题分析</h3><p>基于分布式会话，上面<code>基于cookie传输sessionid</code>和<code>基于token传输类似sessionid</code>都是不能生效的。</p><p>来看看部署结构图：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><p>因为上述两种策略都是在；单机的内存当中，</p><p>基于cookie传输sessionid：基于的是Springboot内嵌的Tomcat容器实现的，是居于内存，只在单机上起作用</p><p>基于token传输类似sessionid：基于java代码的，也是在内存里，只在单机上起作用</p><p>那么问题来了，如果一个用户登录请求通过<code>nginx</code>转发到了第一个<code>miaosha.jar</code>的服务器上，该服务器的sessionid存于内存中，当用户再发送一个其他请求，nginx把请求路由到第二个<code>miaosha.jar</code>的服务器上，由于2个服务器sessionid都在内存中，不能共享，所以会出现问题。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1.用户登录</p><pre><code>http://localhost/resources/login.html</code></pre><p>2.到商品详情页下单</p><pre><code>http://localhost/resources/listitem.html</code></pre><p>3.下单</p><pre><code>提示:下单失败，原因为用户还未登陆，不能下单</code></pre><h1 id="使用redis解决分布式session管理"><a href="#使用redis解决分布式session管理" class="headerlink" title="使用redis解决分布式session管理"></a>使用redis解决分布式session管理</h1><ul><li>基于cookie传输sessionid：java Tomcat容器session实现迁移到redis</li><li>基于token传输类似sessionid：java代码session实现迁移到redis</li></ul><h2 id="1-基于cookie传输sessionid"><a href="#1-基于cookie传输sessionid" class="headerlink" title="1 基于cookie传输sessionid"></a>1 基于cookie传输sessionid</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;      &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;      &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>修改application.properties</p><pre><code class="properties">#配置Springboot对redis的依赖spring.redis.host=202.117.35.220spring.redis.port=6379#默认有16个database，可以用 select 10 来切换databasesspring.redis.database=10#设置jedis连接池spring.redis.jedis.pool.max-active=50spring.redis.jedis.pool.min-idle=20</code></pre><h3 id="序列化错误"><a href="#序列化错误" class="headerlink" title="序列化错误"></a>序列化错误</h3><pre><code>org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.imooc.miaoshaproject.service.model.UserModel]</code></pre><p>原因：UserModel类没有序列化</p><p>解决方法1：</p><pre><code class="java">public class UserModel implements Serializable</code></pre><p>解决方法2：更好的方案</p><p>修改redis默认的序列化方式，改成使用JSON的序列化方式，这是跨系统当中最最好的。</p><h3 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h3><p>登录成功后，<code>spring.redis.host=202.117.35.220</code>上的redis-server会存有session信息</p><pre><code class="bash">202.117.35.220:6379&gt; SELECT 10202.117.35.220:6379[10]&gt; KEYS *1) &quot;spring:session:sessions:expires:2b321bc8-141a-402b-8545-d6d034b58cca&quot;2) &quot;spring:session:sessions:2b321bc8-141a-402b-8545-d6d034b58cca&quot;3) &quot;spring:session:expirations:1560949920000&quot;</code></pre><p><strong>注意：</strong></p><p>这里有个小插曲，因为<code>application.properties</code>中<code>spring.redis.database=10</code></p><p>因为默认的<code>database=0</code>，所以要先select下</p><h2 id="2-基于token传输类似sessionid"><a href="#2-基于token传输类似sessionid" class="headerlink" title="2 基于token传输类似sessionid"></a>2 基于token传输类似sessionid</h2><p>更符合现代互联网，不光支持电脑，还支持手机等各种移动端。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>UserController：</p><pre><code class="java">//用户登陆接口    @RequestMapping(value = &quot;/login&quot;,method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})    @ResponseBody    public CommonReturnType login(@RequestParam(name=&quot;telphone&quot;)String telphone,                                  @RequestParam(name=&quot;password&quot;)String password) throws BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException {        //入参校验        if(org.apache.commons.lang3.StringUtils.isEmpty(telphone)||                StringUtils.isEmpty(password)){            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);        }        //用户登陆服务,用来校验用户登陆是否合法        UserModel userModel = userService.validateLogin(telphone,this.EncodeByMd5(password));//传入的encrptPassword是MD5加密后的        //方法2：基于token传输类似sessionid        //修改成若用户登录验证成功，将对应的登录信息和登录凭证一起存入redis中        //生成登录凭证token，采用UUID，保证唯一性        String uuidToken=UUID.randomUUID().toString();        uuidToken=uuidToken.replace(&quot;-&quot;,&quot;&quot;);        //建立token和用户登录状态之间的联系        redisTemplate.opsForValue().set(uuidToken,userModel);        //设置超时时间,一小时        redisTemplate.expire(uuidToken,1, TimeUnit.HOURS);        //下发token        return CommonReturnType.create(uuidToken);    }</code></pre><p>OrderController：</p><pre><code class="java">//封装下单请求    @RequestMapping(value = &quot;/createorder&quot;,method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})    @ResponseBody    public CommonReturnType createOrder(@RequestParam(name=&quot;itemId&quot;)Integer itemId,                                        @RequestParam(name=&quot;amount&quot;)Integer amount,                                        @RequestParam(name=&quot;promoId&quot;,required = false)Integer promoId) throws BusinessException {        //Boolean isLogin = (Boolean) httpServletRequest.getSession().getAttribute(&quot;IS_LOGIN&quot;);        //为什么要getParameterMap()，因为前端getitem.html中传来的url:&quot;http://&quot;+g_host+&quot;/order/createorder?token=&quot;+token,        String token =httpServletRequest.getParameterMap().get(&quot;token&quot;)[0];        if (StringUtils.isEmpty(token)){            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,&quot;用户还未登陆，不能下单&quot;);        }        //获取用户的登陆信息        UserModel userModel= (UserModel) redisTemplate.opsForValue().get(token);        if (userModel==null){            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,&quot;token不存在&quot;);        }        OrderModel orderModel = orderService.createOrder(userModel.getId(),itemId,promoId,amount);        return CommonReturnType.create(null);    }</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 云端部署 性能压测</title>
      <link href="/2019/06/14/di-3-zhang-yun-duan-bu-shu-xing-neng-ya-ce/"/>
      <url>/2019/06/14/di-3-zhang-yun-duan-bu-shu-xing-neng-ya-ce/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h1 id="私有部署"><a href="#私有部署" class="headerlink" title="私有部署"></a>私有部署</h1><p>就是本地的私有化部署，在本机上调试程序，运行成功在本地打包部署云端。</p><h2 id="操作系统及运行环境"><a href="#操作系统及运行环境" class="headerlink" title="操作系统及运行环境"></a>操作系统及运行环境</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><h1 id="项目云端部署"><a href="#项目云端部署" class="headerlink" title="项目云端部署"></a>项目云端部署</h1><h2 id="操作系统及运行环境-1"><a href="#操作系统及运行环境-1" class="headerlink" title="操作系统及运行环境"></a>操作系统及运行环境</h2><p>阿里云centos虚拟机(ECS服务器)</p><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><h3 id="本地备份"><a href="#本地备份" class="headerlink" title="本地备份"></a>本地备份</h3><pre><code class="bash">mysqldump -uroot -pxxh171015 --databases miaoshaproject &gt;~/Downloads/miaosha.sql</code></pre><p>会在 /Downloads 目录下生成 miaosha.sql </p><h3 id="上传到服务器上"><a href="#上传到服务器上" class="headerlink" title="上传到服务器上"></a>上传到服务器上</h3><pre><code class="bash">scp ~/Downloads/miaosha.sql hpms@202.117.35.221:/home/hpms/xxh009</code></pre><h3 id="在服务器端恢复"><a href="#在服务器端恢复" class="headerlink" title="在服务器端恢复"></a>在服务器端恢复</h3><pre><code class="bash">cd ~mysql -uroot -p123456 &lt;xxh009/miaosha.sql</code></pre><h2 id="应用程序-1"><a href="#应用程序-1" class="headerlink" title="应用程序"></a>应用程序</h2><h3 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h3><pre><code class="xml">&lt;plugin&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;</code></pre><pre><code class="bash">mvn clean package</code></pre><h3 id="应用程序的jar上传到服务器"><a href="#应用程序的jar上传到服务器" class="headerlink" title="应用程序的jar上传到服务器"></a>应用程序的jar上传到服务器</h3><pre><code class="bash">scp miaosha-1.0-SNAPSHOT.jar  hpms@202.117.35.221:/home/hpms/xxh009</code></pre><h2 id="外挂配置文件"><a href="#外挂配置文件" class="headerlink" title="外挂配置文件"></a>外挂配置文件</h2><p>加载项目外的application.properties</p><p>在项目目录下，新建application.properties文件</p><pre><code class="bash">vi application.properties</code></pre><p>项目目录下运行：</p><pre><code class="bash">java -jar miaosha-1.0-SNAPSHOT.jar --spring.config.addition-location=application.properties</code></pre><h2 id="编写deploy脚本启动"><a href="#编写deploy脚本启动" class="headerlink" title="编写deploy脚本启动"></a>编写deploy脚本启动</h2><pre><code class="bash">##编写脚本vi deploy.sh##运行脚本前赋权限chmod -R 777 *##运行脚本./deploy.sh &amp;</code></pre><h3 id="如何关闭"><a href="#如何关闭" class="headerlink" title="如何关闭"></a>如何关闭</h3><pre><code class="bash">##查看应用该端口的程序，显示的是这个端口号那个进程在使用lsof -i:$PORT##关掉对应的应用程序sudo kill -9 PID</code></pre><h1 id="jmeter性能压测"><a href="#jmeter性能压测" class="headerlink" title="jmeter性能压测"></a>jmeter性能压测</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><h2 id="查看结果树"><a href="#查看结果树" class="headerlink" title="查看结果树"></a>查看结果树</h2><h2 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h2><h1 id="如何发现系统瓶颈问题"><a href="#如何发现系统瓶颈问题" class="headerlink" title="如何发现系统瓶颈问题"></a>如何发现系统瓶颈问题</h1><h2 id="发现容量问题"><a href="#发现容量问题" class="headerlink" title="发现容量问题"></a>发现容量问题</h2><h3 id="server端并发线程数上不去"><a href="#server端并发线程数上不去" class="headerlink" title="server端并发线程数上不去"></a>server端并发线程数上不去</h3><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ ps -ef | grep javahpms     17623 17622  4 20:59 pts/13   00:00:45 java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addition-location=~/xxh009/miaosha/application.propertieshpms     17914 15396  0 21:15 pts/13   00:00:00 grep --color=auto java##可以看17623这个进程上面对应有多少个线程hpms@hpms-1:~/xxh009/miaosha$ pstree -p 17623java(17623)─┬─{java}(17624)            ├─{java}(17625)            ├─{java}(17626)            ├─{java}(17627)            ├─{java}(17628)            ├─{java}(17629)            ├─{java}(17630)            ├─{java}(17631)            ├─{java}(17632)            ├─{java}(17633)            ├─{java}(17634)            ├─{java}(17635)            ├─{java}(17636)            ├─{java}(17637)            ├─{java}(17638)            ├─{java}(17639)            ├─{java}(17640)            ├─{java}(17641)            ├─{java}(17642)            ├─{java}(17643)            ├─{java}(17644)            ├─{java}(17645)            ├─{java}(17646)            ├─{java}(17647)            ├─{java}(17648)            ├─{java}(17649)            ├─{java}(17650)            ├─{java}(17651)            ├─{java}(17652)            ├─{java}(17653)            ├─{java}(17654)            ├─{java}(17655)            ├─{java}(17660)            ├─{java}(17661)            ├─{java}(17662)            ├─{java}(17663)            ├─{java}(17664)            ├─{java}(17665)            ├─{java}(17666)            ├─{java}(17667)            ├─{java}(17668)            ├─{java}(17669)            ├─{java}(17670)            ├─{java}(17671)            ├─{java}(17672)            ├─{java}(17673)            ├─{java}(17674)            ├─{java}(17675)            ├─{java}(17676)            ├─{java}(17682)            ├─{java}(17683)            └─{java}(17684)##tomcat服务器在没有丝毫压力的情况下内部维护了52个线程hpms@hpms-1:~/xxh009/miaosha$ pstree -p 17623 | wc -l52</code></pre><h4 id="查看SpringBoot配置"><a href="#查看SpringBoot配置" class="headerlink" title="查看SpringBoot配置"></a>查看SpringBoot配置</h4><p>spring-configuration-metadata.json文件下</p><pre><code class="json">{      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 100,      &quot;name&quot;: &quot;server.tomcat.accept-count&quot;,      &quot;description&quot;: &quot;Maximum queue length for incoming connection requests when all possible request processing threads are in use.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    },  {    &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 10000,      &quot;name&quot;: &quot;server.tomcat.max-connections&quot;,      &quot;description&quot;: &quot;Maximum number of connections that the server accepts and processes at any given time. Once the limit has been reached, the operating system may still accept connections based on the \&quot;acceptCount\&quot; property.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    },{      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 200,      &quot;name&quot;: &quot;server.tomcat.max-threads&quot;,      &quot;description&quot;: &quot;Maximum number of worker threads.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    },{      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 10,      &quot;name&quot;: &quot;server.tomcat.min-spare-threads&quot;,      &quot;description&quot;: &quot;Minimum number of worker threads.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    }</code></pre><p>查看各个节点的配置</p><pre><code class="properties">server.tomcat.accept-count:等待队列长度，默认100server.tomcat.max-connections:最大可被连接数，默认10000server.tomcat.max-threads:最大工作线程数，默认200server.tomcat.min-spare-threads:最小工作线程数，默认10默认配置下，连接超过 10000 后出现拒绝连接情况默认配置下，并发的请求数量超过 200（max-threads）+ 100（accept-count）后拒绝处理</code></pre><p>当对应的所有的工作线程全部用完后，tomcat会将之后的请求丢到 accept-count 这个等待队列中，当等待队列还被塞满，对应的请求会被拒绝</p><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>4核8G内存tomcat的最大线程数是：800</p><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ cat application.propertiesserver.port=8080server.tomcat.accept-count=1000server.tomcat.max-threads=800server.tomcat.min-spare-threads=100</code></pre><p>再次查看java进程PID</p><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ ps -ef |grep javahpms     18945 18944 92 22:18 pts/13   00:00:39 java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addition-location=~/xxh009/miaosha/application.propertieshpms@hpms-1:~/xxh009/miaosha$ pstree -p 18945|wc -l139</code></pre><p>上面我们可以看到是52</p><p>当再次压测时</p><pre><code>线程数：2000Rame-up时间：10循环次数：100</code></pre><p>此时</p><p>服务端</p><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ pstree -p 18945|wc -l842</code></pre><h4 id="定制化内嵌Tomcat开发"><a href="#定制化内嵌Tomcat开发" class="headerlink" title="定制化内嵌Tomcat开发"></a>定制化内嵌Tomcat开发</h4><p>关注参数:</p><p>keepAliveTimeOut:多少毫秒后不响应断开keepalive</p><p>maxKeepAliveRequests:多少次请求后keepalive断开失效</p><p>使用WebServerFactoryCustomizer&lt; ConfigurableServletWebServer &gt;定制化内嵌tomc配置</p><h3 id="响应时间变长-TPS上不去"><a href="#响应时间变长-TPS上不去" class="headerlink" title="响应时间变长 TPS上不去"></a>响应时间变长 TPS上不去</h3><h4 id="单Web容器上限"><a href="#单Web容器上限" class="headerlink" title="单Web容器上限"></a>单Web容器上限</h4><p>线程数量： 4核CPU 8G内存单进程调度线程数800-1000以上，后即花费巨大的时间CPU调度上</p><p>等待队列的长度：队列做缓冲池，但也不能无限长，消耗内存，出入队也耗CPU</p><h4 id="MySql数据库QPS容量问题"><a href="#MySql数据库QPS容量问题" class="headerlink" title="MySql数据库QPS容量问题"></a>MySql数据库QPS容量问题</h4><p>主键查询：千万级别数据=1-10毫秒</p><p>唯一索引查询：千万级别数据=10-100毫秒</p><p>非唯一索引查询：千万级别数据=100-1000毫秒</p><p>无索引：百万级别数据=1000毫秒+    (全表扫描)</p><h4 id="MySql数据库TPS容量问题"><a href="#MySql数据库TPS容量问题" class="headerlink" title="MySql数据库TPS容量问题"></a>MySql数据库TPS容量问题</h4><p>非插入更新删除操作：同查询</p><p>插入操作：1W~10w tps</p>]]></content>
      
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 秒杀项目框架回顾</title>
      <link href="/2019/06/12/di-2-zhang-miao-sha-xiang-mu-kuang-jia-hui-gu/"/>
      <url>/2019/06/12/di-2-zhang-miao-sha-xiang-mu-kuang-jia-hui-gu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="秒杀系统的框架"><a href="#秒杀系统的框架" class="headerlink" title="秒杀系统的框架"></a>秒杀系统的框架</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150917.png" alt="屏幕快照 2019-06-13 下午8.23.37"></p><h1 id="层与层之间的交互方式"><a href="#层与层之间的交互方式" class="headerlink" title="层与层之间的交互方式"></a>层与层之间的交互方式</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150918.png" alt="屏幕快照 2019-06-13 下午11.57.01"></p><h2 id="Data-Obiect和Domain-Model"><a href="#Data-Obiect和Domain-Model" class="headerlink" title="Data Obiect和Domain Model"></a>Data Obiect和Domain Model</h2><p>比如我们需要刻画的用户，</p><h3 id="在业务层的Domain-Model中"><a href="#在业务层的Domain-Model中" class="headerlink" title="在业务层的Domain Model中"></a>在业务层的Domain Model中</h3><p>UserModel的属性</p><pre><code class="java">private Integer id;    @NotBlank(message = &quot;用户名不能为空&quot;)    private String name;    @NotNull(message = &quot;性别不能不填写&quot;)    private Byte gender;    @NotNull(message = &quot;年龄不能不填写&quot;)    @Min(value = 0,message = &quot;年龄必须大于0岁&quot;)    @Max(value = 150,message = &quot;年龄必须小于150岁&quot;)    private Integer age;    @NotBlank(message = &quot;手机号不能为空&quot;)    private String telphone;    private String registerMode;    private String thirdPartyId;    @NotBlank(message = &quot;密码不能为空&quot;)    private String encrptPassword;</code></pre><h3 id="在数据层UserDO和UserPasswordDO表中："><a href="#在数据层UserDO和UserPasswordDO表中：" class="headerlink" title="在数据层UserDO和UserPasswordDO表中："></a>在数据层UserDO和UserPasswordDO表中：</h3><p>在企业中，由于用户的密码属性会由其他，于是用户的密码生成另外的表，UserModel的属性由UserDO和UserPasswordDO的属性拼接而成。</p><p>UserDO：</p><pre><code class="java">    private Integer id;    private String name;    private Byte gender;    private Integer age;    private String telphone;    private String registerMode;    private String thirdPartyId;</code></pre><p>UserPasswordDO：</p><pre><code class="java">    private Integer id;    private String encrptPassword;    private Integer userId;</code></pre><h2 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h2><p>Domain Model使用的是贫血模型</p><p>对应的Domain Model 仅仅只有自己的属性，比如用户的基础属性和用户的密码属性，另外提供get个set方法，除此以外不提供注册、登录、注销这些服务，用户想使用这些服务，必须通过service服务输出能力。</p><h2 id="接入层模型"><a href="#接入层模型" class="headerlink" title="接入层模型"></a>接入层模型</h2><p>接入层 View Object 是对前端负责</p><h3 id="与springMVC"><a href="#与springMVC" class="headerlink" title="与springMVC"></a>与springMVC</h3><p>Controller管理的是 View Objec 接入层模型</p><p>Model对应的是 Domain Model 业务层模型</p><h3 id="项目VO、Model和DO图"><a href="#项目VO、Model和DO图" class="headerlink" title="项目VO、Model和DO图"></a>项目VO、Model和DO图</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150919.png" alt="屏幕快照 2019-06-14 上午12.23.42"></p><h1 id="项目类图"><a href="#项目类图" class="headerlink" title="项目类图"></a>项目类图</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150920.png" alt="屏幕快照 2019-06-14 上午12.35.58"></p><h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1><p>跨域session共享问题(safari浏览器 )</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150921.png" alt="屏幕快照 2019-06-14 上午2.02.17"></p><p>全局异常处理器404，405问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个完整的HTTP请求过程</title>
      <link href="/2019/04/29/yi-ge-wan-zheng-de-http-qing-qiu-guo-cheng/"/>
      <url>/2019/04/29/yi-ge-wan-zheng-de-http-qing-qiu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h1><p>域名解析 —&gt;与服务器建立连接 —&gt; 发起HTTP请求 —&gt; 服务器响应HTTP请求 —&gt;浏览器得到html代码 —&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片） —&gt; 浏览器对页面进行渲染呈现给用户</p><a id="more"></a><h1 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1. 域名解析"></a>1. 域名解析</h1><p>以Chrome浏览器为例：</p><p>① Chrome浏览器会首先搜索<strong>浏览器自身的DNS缓存</strong>（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="https://www.cnblogs.com" target="_blank" rel="noopener">https://www.cnblogs.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p><p>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索<strong>操作系统自身的DNS缓存</strong>,如果找到且没有过期则停止搜索解析到此结束.</p><p>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看</p><p>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取<strong>hosts文件</strong>（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p><p>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向<strong>本地配置的首选DNS服务器</strong>（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起==域名解析请求==（通过的是UDP协议向DNS的<strong>53</strong>端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<code>www.cnblogs.com</code>)这个域名的IP地址是多少啊？），根域发现这是一个<strong>顶级域com域</strong>的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问<code>www.cnblogs.com</code>这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道<code>www.cnblogs.com</code>这个域名的IP地址，但是我知道cnblogs.com这个域的DNS地址，你去找它去，于是运营商的DNS又向cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问<code>www.cnblogs.com</code>这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了<code>www.cnblogs.com</code>这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了<code>www.cnblogs.com</code> 对应的IP地址，该进行一步的动作了。</p><h1 id="2-与服务器建立连接"><a href="#2-与服务器建立连接" class="headerlink" title="2. 与服务器建立连接"></a>2. 与服务器建立连接</h1><p>客户端的请求到达服务器，首先就是建立TCP连接</p><ol><li><p>Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p></li><li><p>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p></li><li><p>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p></li></ol><h1 id="3-发起HTTP请求"><a href="#3-发起HTTP请求" class="headerlink" title="3. 发起HTTP请求"></a>3. 发起HTTP请求</h1><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>一个HTTP请求报文由<strong>请求行</strong>（request line）、<strong>请求头部</strong>（header）、<strong>空行</strong>和<strong>请求数据</strong>4个部分组成</p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行分为三个部分：<strong>请求方法</strong>、<strong>请求地址</strong>和<strong>协议版本</strong></p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><h4 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h4><p>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</p><p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 注：端口和路径有时可以省略（HTTP默认端口号是80）</p><p><a href="https://localhost:8080/index.html?key1=value1&amp;keys2=value2" target="_blank" rel="noopener">https://localhost:8080/index.html?key1=value1&amp;keys2=value2</a></p><h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p><h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p>可选部分，比如GET请求就没有请求数据。</p><p>###一个POST方法的请求报文：</p><pre><code>POST 　/index.php　HTTP/1.1 　　 请求行 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: zh-cn,zh;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive Referer: http://localhost/ Content-Length：25 Content-Type：application/x-www-form-urlencoded 　　空行 username=aa&amp;password=1234　　请求数据</code></pre><h1 id="4-服务器响应HTTP请求"><a href="#4-服务器响应HTTP请求" class="headerlink" title="4. 服务器响应HTTP请求"></a>4. 服务器响应HTTP请求</h1><h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p>HTTP响应报文主要由<strong>==状态行==</strong>、<strong>==响应头部==</strong>、<strong>==空行==</strong>以及<strong>==响应数据==</strong>组成。</p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>由3部分组成，分别为：<strong>协议版本</strong>，<strong>状态码</strong>，<strong>状态码描述</strong>。</p><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><p>状态码</p><p>状态代码为3位数字。</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><p>与请求头部类似，为响应报文添加了一些附加信息</p><h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p>用于存放需要返回给客户端的数据信息。</p><h3 id="一个响应报文的实例："><a href="#一个响应报文的实例：" class="headerlink" title="一个响应报文的实例："></a>一个响应报文的实例：</h3><pre><code>HTTP/1.1 200 OK　　状态行 Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部 Server: Apache/2.2.8 (Win32) PHP/5.2.5 X-Powered-By: PHP/5.2.5 Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 4393 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html; charset=utf-8 　　空行 　　响应数据 HTTP响应示例 Hello HTTP! </code></pre><h1 id="5-浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源"><a href="#5-浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="5.浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源"></a>5.浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源</h1><p>浏览器拿到index.html文件后，就开始<strong>解析</strong>其中的html代码，遇到js/css/image等<strong>静态资源</strong>时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p><p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151235.png" alt="20180529143316"></p><h1 id="6-浏览器对页面进行渲染呈现给用户"><a href="#6-浏览器对页面进行渲染呈现给用户" class="headerlink" title="6. 浏览器对页面进行渲染呈现给用户"></a>6. 浏览器对页面进行渲染呈现给用户</h1><p>最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。<img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151247.png" alt="3985563-1891c256487e9d85"></p><p>当目的主机收到一个以太网数据帧时，数据就开始从<strong>协议栈</strong>中由底向上升，<strong>同时去掉各层协议加上的报文首部</strong>。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作<strong>分用</strong>（Demultiplexing）。<strong>协议是通过目的端口号、源IP地址和源端口号进行解包的</strong>。</p><p>通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151248.png" alt="3985563-ecf824604debcdf1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2019/04/29/http/"/>
      <url>/2019/04/29/http/</url>
      
        <content type="html"><![CDATA[<p>#前言：</p><p>TCP协议实现了==数据流==的可靠传输。然而，人们更加习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档(hypertext document)。</p><p>==超文本文档==中包含有超链接，指向其他的资源。超文本文档是万维网(World Wide Web，即www)的基础。</p><p>HTTP协议==解决文件传输==的问题。HTTP是应用层协议，==主要建立在TCP协议之上==(偶尔也可以UDP为底层)。它随着万维网的发展而流行。HTTP协议目的是，如何在万维网的网络环境下，更好的利用TCP协议，以实现文件，特别是超文本文件的传输。</p><a id="more"></a><p>早期的HTTP协议主要传输静态文件，即真实存储在服务器上的文件。随着万维网的发展，HTTP协议被用于传输“动态文件”，服务器上的程序根据HTTP请求即时生成的动态文件。我们将HTTP的传输对象统称为==资源==(resource)。</p><p><strong>点单</strong></p><p>HTTP实现了资源的订购和传送。其工作方式类似于快餐点单。</p><p>1：==请求==(request): 顾客向服务员提出请求：“来个鸡腿汉堡”。</p><p>2：==回复==(response):服务员根据情况，回应顾客的请求</p><p>根据情况的不同，服务员的回应可能有很多，比如:</p><p>服务员准备鸡腿汉堡，将鸡腿汉堡交给顾客。（一切OK）</p><p>服务员发现自己只是个甜品站。他让顾客前往正式柜台点单。（重新定向）</p><p>服务员告诉顾客鸡腿汉堡没有了。(无法找到)</p><p>交易结束后，服务员就将刚才的交易抛到脑后，准备服务下一位顾客。</p><h1 id="HTTP具体实现"><a href="#HTTP具体实现" class="headerlink" title="HTTP具体实现"></a>HTTP具体实现</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a><strong>格式</strong></h2><p>HTTP协议的通信是一次==request-responce==交流。客户端(guest)向服务器发出请求(request)，服务器(server)回复(response)客户端。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151158.png" alt="img"></p><p>HTTP协议规定了请求和回复的格式:</p><pre><code>起始行 (start line)头信息 (headers)主体(entity body)</code></pre><p>==起始行==只有一行。它包含了请求/回复最重要的信息。请求的起始行表示(顾客)“想要什么”。回复的起始行表示(后厨)“发生什么”。</p><p>==头信息==可以有多行。每一行是一对键值对(key-value pair)，比如:</p><pre><code>Content-type: text/plain </code></pre><p>它表示，包含有一个名为Content-type的参数，该参数的值为text/plain。头信息是对起始行的补充。请求的头信息对服务器有指导意义 (好像在菜单上注明: 鸡腿不要辣)。回复的头信息则是提示客户端（比如，在盒子上注明: 小心烫）</p><p>==主体部分==包含了具体的资源。上图的请求中并没有主体，因为我们只是在下单，而不用管后厨送什么东西 (请求是可以有主体内容的)。回复中包含的主体是一段文本文字(Hello World!)。这段文本文字正是顾客所期待的，鸡腿汉堡。</p><p>##请求（Request）</p><p>我们深入一些细节。先来看一下请求的第一行:</p><pre><code>GET /index.html HTTP/1.1Host: www.example.com</code></pre><p>在起始行中，有三段信息:</p><p>==GET== ：用于说明想要服务器执行的操作，此外还有<strong>PUT、POST等操作</strong></p><p>==/index.html== ：资源的路径。这里指向服务器上的index.html文件。</p><p>==HTTP/1.1==： 协议的版本。HTTP第一个广泛使用的版本是1.0，当前版本为1.1。</p><p>早期的HTTP协议只有GET方法。遵从HTTP协议，服务器接收到GET请求后，会将特定资源传送给客户。这类似于客户点单，并获得汉堡的过程。使用GET方法时，是客户向服务器索取资源，所以请求往往没有主体部分。</p><p>GET方法也可以用于传输一些不重要的数据。它是通过改写URL的方式实现的。GET的数据利用==URL?变量名＝变量值==的方法传输。比如向<a href="http://127.0.0.1发送一个变量“q”，它的值为“a”。那么，实际的URL为http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。" target="_blank" rel="noopener">http://127.0.0.1发送一个变量“q”，它的值为“a”。那么，实际的URL为http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。</a></p><p>GET方法之外，最常用的是POST方法。它用于从客户端向服务器提交数据。使用POST方法时，URL不再被改写。数据位于http请求的主体。POST方法最用于提交HTML的form数据。服务器往往会对POST方法提交的数据进行一定的处理，比如存入服务器数据库。</p><p>样例请求中有一行头信息。该头信息的名字是Host。HTTP的请求必须有Host头信息，用于说明服务器的地址和端口。HTTP协议的默认端口是80，如果在HOST中没有说明端口，那么将默认采取该端口。在该例子中，服务器的域名为<a href="http://www.example.com，端口为80。域名将通过DNS服务器转换为IP地址，从而确定服务器在互联网上的地址。" target="_blank" rel="noopener">www.example.com，端口为80。域名将通过DNS服务器转换为IP地址，从而确定服务器在互联网上的地址。</a></p><p>牛客项目中<strong>Request Headers</strong>：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151159.png" alt="屏幕快照 2019-03-21 下午10.34.28"></p><p>##回复(Response)</p><p>服务器在接收到请求之后，会根据程序，生成对应于该请求的回复，比如:</p><pre><code>HTTP/1.1 200 OKContent-type: text/plainContent-length: 12Hello World!</code></pre><p>回复的起始行同样包含三段信息</p><pre><code>HTTP/1.1 协议版本200 状态码(status code)OK 状态描述</code></pre><p>OK是对状态码200的文字描述，它只是为了便于人类的阅读。电脑只关心三位的状态码(status code)，即这里的200。200表示一切OK，资源正常返回。状态码代表了服务器回应动作的类型。</p><p>其它常见的状态码还有:</p><p>302，重定向(redirect): 我这里没有你想要的资源，但我知道另一个地方xxx有，你可以去那里找。</p><p>404，无法找到(not found): 我找不到你想要的资源，无能为力。</p><p>Content-type说明了主体所包含的资源的类型。根据类型的不同，客户端可以启动不同的处理程序(比如显示图像文件，播放声音文件等等)。下面是一些常见的资源：</p><pre><code>text/plain 普通文本text/html HTML文本image/jpeg jpeg图片image/gif gif图片</code></pre><p>Content-length说明了主体部分的长度，以字节(byte)为单位。</p><p>回应的主体部分为一段普通文本，即Hello World!</p><p>牛客项目中<strong>Response Headers</strong></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151201.png" alt="屏幕快照 2019-03-21 下午10.37.03"></p><p>##常见的请求和相应头</p><h4 id="请求-客户端-gt-服务端-request"><a href="#请求-客户端-gt-服务端-request" class="headerlink" title="请求(客户端-&gt;服务端[request])"></a>请求(客户端-&gt;服务端[<strong>request</strong>])</h4><blockquote><p>GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)<br>Accept: <em>/</em>(客户端能接收的资源类型)<br>Accept-Language: en-us(客户端接收的语言类型)<br>Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>Host: localhost:8080(连接的目标主机和端口号)<br>Referer: <a href="https://link.jianshu.com/?t=http%3A%2F%2Flocalhost%2Flinks.jsp%28" target="_blank" rel="noopener">http://localhost/links.jsp(</a>告诉服务器我来自于哪里)<br>User-Agent: Mozilla/4.0(客户端版本号的名字)<br>Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>If-Modified-Since: Tue, 11 Jul 2017 18:23:51 GMT(缓存时间)<br>Cookie(客户端暂存服务端的信息)<br>Date: Tue, 18 Jul 12:15:02 GMT(客户端请求服务端的时间)</p></blockquote><h4 id="响应-服务端-gt-客户端-response"><a href="#响应-服务端-gt-客户端-response" class="headerlink" title="响应(服务端-&gt;客户端[response])"></a>响应(服务端-&gt;客户端[<strong>response</strong>])</h4><blockquote><p>HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)<br>Location: <a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.baidu.com%28" target="_blank" rel="noopener">http://www.baidu.com(</a>服务端需要客户端访问的页面路径)<br>Server:apache tomcat(服务端的Web服务端名)<br>Content-Encoding: gzip(服务端能够发送压缩编码类型)<br>Content-Length: 80(服务端发送的压缩数据的长度)<br>Content-Language: zh-cn(服务端发送的语言类型)<br>Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)<br>Last-Modified: Tue, 18 Jul 2017 12:15:02 GMT(服务端对该资源最后修改的时间)<br>Refresh: 1;url=<a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.helloyoucan.com.%28" target="_blank" rel="noopener">http://www.helloyoucan.com.(</a>服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)<br>Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)<br>Transfer-Encoding: chunked(分块传递数据到客户端）<br>Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)<br>Expires: -1//3种(服务端禁止客户端缓存页面数据)<br>Cache-Control: no-cache(服务端禁止客户端缓存页面数据)<br>Pragma: no-cache(服务端禁止客户端缓存页面数据)<br>Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)<br>Date: Tue, 18 Jul 2017 12:18:03 GMT(服务端响应客户端的时间)</p></blockquote><p>##无状态</p><p>根据早期的HTTP协议，每次request-reponse时，都要重新建立TCP连接。TCP连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，HTTP通信是无状态(stateless)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。</p><p>想象高级餐厅和快餐店。高级餐厅会知道客人所在的位置，如果新增点单，那么服务员知道这和上一单同一桌。而在快餐店中，不好意思，服务员并不记录客人的特征。想再次点单？请重新排队……</p><p>随着HTTP协议的发展，HTTP协议允许TCP连接复用，以节省建立连接所耗费的时间。但HTTP协议依然保持无状态的特性。</p><p>#两种 HTTP 方法：GET 和 POST</p><table><thead><tr><th></th><th align="left"><strong>GET</strong></th><th><strong>POST</strong></th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td align="left">无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td align="left">可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td align="left">能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td align="left">application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或   multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td align="left">参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td align="left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td align="left">只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。   在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td align="left">数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>###什么是HTTPS?</p><p>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。  </p><p>###<strong>https</strong> 与 <strong>http</strong> 区别 ?</p><p>1)https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 </p><p>2)http 是超文本传输协议，==信息是明文传输==，https 则是具有安全性的 ssl 加密传输协议。 </p><p>3)http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 ==80==，后者是 ==443==。 </p><p>4)http 的连接很简单，==是无状态的==;HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151202.gif" alt="page242image3818784"></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151203.gif" alt="page242image3851264"></p><p>文字简述:客户端 A 和服务器 B 之间的交互 </p><ol><li><p>A与B通过TCP建立链接，初始化SSL层。 </p></li><li><p>进行 SSL 握手，A 发送 https 请求，传送客户端 SSL 协议版本号、支持的加密算法、 随机数等。 </p></li><li><p>服务器 B 把 CA 证书(包含 B 的公钥)，把自己支持的加密算法、随机数等回传给 A。 </p></li><li><p>A 接收到 CA 证书，验证证书有效性。 </p></li><li><p>校验通过，客户端随机产生一个字符串作为与 B 通信的对称密钥，通过 CA 证书解出服务器 B 的公钥，对其加密，发送给服务器。</p></li><li><p>B 用私钥解开信息，得到随机的字符串(对称密钥)，利用这个密钥作为之后的通信密钥。 </p></li><li><p>客户端向服务器发出信息，指明后面的数据使用该对称密钥进行加密，同时通知服 务器 SSL 握手结束。 </p></li><li><p>服务器接收到信息，使用对称密钥通信，通知握手接收。 </p></li><li><p>SSL 握手结束，使用对称密钥加密数据。 </p></li></ol><p>###安全加密</p><p>1.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151203.png" alt="bg2011080901"></p><p>鲍勃有两把钥匙，一把是公钥，另一把是私钥。</p><p>2.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151204.png" alt="bg2011080902"></p><p>鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</p><p>3.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151205.png" alt="bg2011080903"></p><p>苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。</p><p>4.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151206.png" alt="bg2011080904"></p><p>鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p><p>5.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151207.png" alt="bg2011080905"></p><p>鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。</p><blockquote><p>这里主要解释一下签名，签名就是在信息的后面再加上一段内容，==可以证明信息没有被修改过==，怎么样可以达到这个效果呢？一般是对信息做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的信息内容。在把信息发送出去时，把这个hash值加密后做为一个签名和信息一起发出去。<br>接收方在收到信息后，会重新计算信息的hash值，并和信息所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据信息内容计算的hash值就会变化。当然，不怀好意的人也可以修改信息内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和信息一起发送，以保证这个hash值不被修改。</p></blockquote><p><strong>补充知识点</strong>：</p><p>那么问题来了，==是将发送的全部内容hash嘛==？</p><p>这里用到的hash算法其实就是==将一段非常长的数据通过hash变换为一个固定长度相对较短的数据==，简称“<strong>摘要</strong>”，你可以理解成把一本书通过hash变成一段很短的话，算法最关键的要点是，哪怕你改动了这本书里面的一个标点符号，hash后的摘要都会改变。</p><p>以MD5这种hash算法为例，他可以将任意长度的数据变成128位的散列值，所谓任意长度的意思就是你的数据可以是一篇文章，一部电影，或者只是一个字母，哪怕是个空字符串。</p><p>6.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151208.png" alt="bg2011080906"></p><p>然后，鲍勃使用私钥，对这个摘要加密，生成”==数字签名==”（signature）。</p><p>7.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151209.png" alt="bg2011080907"></p><p>鲍勃将这个签名，附在信件下面，一起发给苏珊。</p><p>8.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151210.png" alt="bg2011080908"></p><p>苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</p><p>9.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151211.png" alt="bg2011080909"></p><p>苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p><p>10.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151212.png" alt="bg2011080910"></p><p>复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p><p>11.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151213.png" alt="bg2011080911"></p><p>后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</p><p><strong>知识点补充</strong>：</p><blockquote><p>介绍下数字证书：</p><p>数字证书则是由证书认证机构(CA, Certificate Authority)对证书申请者真实身份验证之后，用CA的根证书对申请人的一些基本信息以及申请人的公钥进行签名(相当于加盖发证书机构的公章)后形成的一个数字文件。</p><p><strong>数字证书验证过程</strong>:CA 机构的公钥已经是==在浏览器发布前提前嵌入到浏览器内部了==， 所以 CA 的公钥是真实可靠的(如果 CA 机构被黑客攻陷，那么也可能是不可靠的)，然后服务器发送自己的公钥给 CA(用 CA 的公钥进行加密)，CA 对服务器的发来的内容解密得到服务器的公钥，然后 CA 对服务器的公钥进行颁发数字证书(就是数字签名)，发给服务器，服务器收到以后，将==数字证书，公开密钥发送给客户端==，客户端用 CA 的公开密钥验证得到服务器的公开密钥，然后这样客户端就得到了真正可靠的服务器的公开密钥。 </p></blockquote><p>12.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151214.png" alt="bg2011080912"></p><p>鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</p><p>13.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151215.png" alt="bg2011080913"></p><p>苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</p><p>##HTTPS的实际应用</p><p>下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151213.jpg" alt="bg2011080914"></p><p>1.首先，客户端向服务器发出加密请求。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151216.png" alt="bg2011080915"></p><p>2.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151217.png" alt="bg2011080916"></p><p>3.客户端（浏览器）的”==证书管理器==”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151218.png" alt="bg2011080917"></p><p>4.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151219.png" alt="bg2011080918"></p><p>5.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151218.jpg" alt="bg2011080919"></p><p>6.如果数字证书是可靠的，==客户端就可以使用证书中的服务器公钥==，对信息进行加密，然后与服务器交换加密信息。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151220.png" alt="bg2011080920"></p><p>##总结：</p><p>HTTPS为了兼顾安全与效率，同时使用了==对称加密==和==非对称加密==。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，==对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输==。</p><p>也就是说客户端使用对称加密加密数据，服务端通过非对称加密得到对称加密的秘钥。</p><p>为什么用对称秘钥加密数据呢？</p><p>可能是为了传输效率。因为私钥只有服务端自己有，足够安全，再加上对称加密的效率更高</p><p><strong>知识点补充：</strong></p><p><strong>对称加密</strong>：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。<br>其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文<br>解密过程如下：密文 + 解密算法 + 私钥 =&gt; 明文<br>对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。<br>其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。</p><p><strong>非对称加密</strong>：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。<br>被公钥加密过的密文只能被私钥解密，过程如下：<br>明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文<br>被私钥加密过的密文只能被公钥解密，过程如下：<br>明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文<br>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。<br>==非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。==<br>在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/2019/04/29/tcp/"/>
      <url>/2019/04/29/tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h1><p>三次握手需要的信息:</p><p>==ACK== : TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1。 </p><p>==SYN==(SYNchronization) : 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。 </p><p>==FIN== (finish)即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段 的发送方的数据已经发送完毕，并要求释放连接 。</p><p>==seq==(序号):</p><a id="more"></a><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151220.jpg" alt="1350984685_4221"></p><p>三次握手：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151221.jpg" alt="1350985085_3123"></p><ol><li>首先由Client发出请求连接即 SYN=1，ACK=0， TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x；</li><li>然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1；</li><li>再然后 Client 再进行一次确认，但不用SYN了，这时即为 ACK=1, seq=x+1, ack=y+1.然后连接建立。</li></ol><p>四次挥手：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151222.jpg" alt="1350990937_5362"></p><p>【注意】中断连接端可以是Client端，也可以是Server端。</p><p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了==2MSL==（<em>Maximum Segment Lifetime</em>，中文可以译为“==报文最大生存时间==”）后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p>整个过程Client端所经历的状态如下：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151222.gif" alt="0_1312719804oSkK"></p><p>而Server端所经历的过程如下：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151223.gif" alt="0_1312719833030b"></p><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>###1.为什么要进行三次握手呢（两次确认）？</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151223.jpg" alt="1350985432_2318"></p><p>###2.为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>###3.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h1 id="TCP如何保证可靠性传输"><a href="#TCP如何保证可靠性传输" class="headerlink" title="TCP如何保证可靠性传输"></a>TCP如何保证可靠性传输</h1><p><strong>确保传输可靠性的方式：</strong></p><p>TCP协议保证数据传输可靠性的方式主要有：</p><ol><li>连接管理</li><li>序列号</li><li>确认应答</li><li>超时重传</li><li>流量控制</li><li>拥塞控制</li><li>校验和</li></ol><p>##1.连接管理</p><p>连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。</p><h2 id="2-amp-3-确认应答与序列号"><a href="#2-amp-3-确认应答与序列号" class="headerlink" title="2&amp;3. 确认应答与序列号"></a>2&amp;3. <strong>确认应答与序列号</strong></h2><p><strong>序列号</strong>：TCP传输时将每个字节的数据都进行了编号，这就是序列号。 </p><p><strong>确认应答</strong>：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，==接收到了哪些数据，下一次的数据从哪里发==。</p><h2 id="4-超时重传"><a href="#4-超时重传" class="headerlink" title="4. 超时重传"></a>4. 超时重传</h2><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？</p><p>首先，发送方没有介绍到响应的ACK报文原因可能有两点：</p><p>1.数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。</p><p>2.接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</p><p>TCP在解决这个问题的时候引入了一个新的机制，叫做==超时重传机制==。<strong>简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送</strong>。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</p><p>###补充知识点： </p><p>==那么发送方发送完毕后等待的时间是多少呢？==如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p><p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p><p>   在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。   </p><h2 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5.  流量控制"></a>5.  <strong>流量控制</strong></h2><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而==TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制==。</p><p>在TCP协议的报头信息当中，有一个<strong>16位字段的窗口大小</strong>。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151224.gif" alt="70"></p><p><strong>注</strong>：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。</p><h3 id="滑动窗口协议（连续ARQ协议）"><a href="#滑动窗口协议（连续ARQ协议）" class="headerlink" title="滑动窗口协议（连续ARQ协议）"></a>滑动窗口协议（连续ARQ协议）</h3><p><strong>连续ARQ协议</strong></p><p>在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。 </p><p><strong>累计确认</strong></p><p>在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。</p><p>==发送窗口==</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151225.gif" alt="1"></p><p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。发送窗口由三个指针构成：</p><p>发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。当p2和前沿重合时，发送者必须等待确认应答。</p><p><strong>p1</strong></p><p>p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。 </p><p><strong>p2</strong></p><p>p2指向尚未发送的第一个字节。p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。p2-p3间的字节表示可以发送，但还没有发送的字节。</p><p><strong>p3</strong></p><p>p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。</p><p>==接收窗口==</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151226.gif" alt="2"></p><p>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。<br> 如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</p><p><strong>连续ARQ的注意点</strong></p><p>同一时刻发送窗口的大小并不一定和接收窗口一样大。虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。</p><p>TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。 </p><p>TCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5S以内。此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。</p><h2 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h2><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><p>所以TCP引入了==慢启动的机制==，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。 </p><p>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。 </p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151233.gif" alt="70"></p><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p><p>##7. 校验和<strong>（</strong>用于接收端检验整个数据包在传输过程中是否出错<strong>）</strong></p><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。 </p><p>发送方：在发送数据之前计算检验和，并进行校验和的填充。 </p><p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151234.gif" alt="71"></p><p>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p><h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a><strong>TCP与UDP的区别</strong></h1><p>1.基于连接与无连接；</p><p>2.对系统资源的要求（TCP较多，UDP少）；</p><p>3.UDP程序结构较简单；</p><p>4.流模式与数据报模式 ；</p><p>5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151235.gif" alt="page218image3854176"></p><p><strong>对应的协议不同</strong> </p><p><strong>TCP</strong> 对应的协议: </p><p>(1) <strong>FTP</strong>:定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传 输服务。下载文件，上传主页，都要用到 FTP 服务。 </p><p>2)<strong>Telnet</strong> :它是一种用于远程登录的端口，用户可以以自己的身份远程连接到计算机上，种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服 务器将 23 端口打开，对外提供服务。 </p><p>(3) <strong>SMTP</strong>:定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。 如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。 </p><p>(4) <strong>POP3</strong>:它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端 口。也是说，只要你有相应的使用 POP3 协议的程序(例如 Fo-xmail 或 Outlook)，就可以不以 We b 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件(如是 163 邮箱就没有必要先进入网易网站， 再进入自己的邮-箱来收信)。 </p><p>(5)<strong>HTTP 协议</strong>:是从 Web 服务器传输超文本到本地浏览器的传送协议。 </p><p><strong>UDP</strong> 对应的协议: </p><p>(1) <strong>DNS</strong>:用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。 </p><p>(2) <strong>SNMP</strong>:简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多， 无连接的服务就体现出其优势。 </p><p>(3)<strong>TFTP</strong>(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP 服务。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网协议入门</title>
      <link href="/2019/04/28/hu-lian-wang-xie-yi-ru-men/"/>
      <url>/2019/04/28/hu-lian-wang-xie-yi-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a><strong>五层模型</strong></h2><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p><p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p><a id="more"></a><p>如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151252.jpg" alt="img"></p><p>如上图所示，最底下的一层叫做”物理层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p><p>###补充：网络分层的优点</p><p>1）各层之间是独立的。某一层并不需要知道它下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可以将一个难以处理的复杂问题分解为若干个较容易处理的更小问题，这样，整个问题的复杂度就下降了。</p><p>2）灵活性好。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响，此外，对某一层提供的服务还可以进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</p><p>3）结构上可分割开。各层都可以采用最合适的技术来实现。</p><p>4）易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个系统已被分解为若干个相对独立的子系统。</p><p>5）能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。</p><h2 id="层与协议"><a href="#层与协议" class="headerlink" title="层与协议"></a><strong>层与协议</strong></h2><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则，大家都遵守的规则，就叫做”协议”（protocol）。</p><p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p><p>#实体层</p><p>我们从最底下的一层开始。电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用<strong>光缆、电缆、双绞线、无线电波</strong>等方式。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151253.jpg" alt="img"></p><p>这就叫做”==实体层==”，也叫物理层，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是==负责传送0和1的电信号==。</p><p>#链路层</p><p>##<strong>以太网协议</strong></p><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，==确定了0和1的分组方式==。</p><p>早期的时候，每家公司都有自己的==电信号分组方式==。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：首部（Head）和数据（Data）。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151252.png" alt="img"></p><p>“首部”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“==首部==”的长度，固定为<strong>18</strong>字节。”数据”的长度，<strong>最短为46字节，最长为1500字节</strong>。因此，==整个”帧”最短为64字节，最长为1518字节==。如果数据很长，就必须分割成多个帧进行发送。</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>上面提到，以太网数据包的”首部”，包含了发送者和接受者的信息。那么，==发送者和接受者是如何标识呢？==</p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。==数据包必须是从一块网卡，传送到另一块网卡==。网卡的地址，就是数据包的发送地址和接收地址，这叫做==MAC地址==。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151255.jpg" alt="640"></p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是==48个二进制位==，通常用12个十六进制数表示。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151259.jpg" alt="640-3"></p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a><strong>广播</strong></h2><p>定义地址只是第一步，后面还有更多的步骤。首先，<strong>一块网卡怎么会知道另一块网卡的MAC地址</strong>？回答是有一种==ARP协议==，可以解决这个问题。这个留到后面介绍，这里只需要知道，<strong>以太网数据包必须知道接收方的MAC地址，然后才能发送</strong>。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151260.jpg" alt="640-4"></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个<strong>子网络</strong>的3号、4号、5号计算机都会收到这个包。它们读取这个包的”首部”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”==广播==”（broadcasting）。</p><p><strong>有了数据包的定义（以太网协议规定的）、网卡的MAC地址（根据ARP协议知道）、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</strong></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的由来"><a href="#网络层的由来" class="headerlink" title="网络层的由来"></a><strong>网络层的由来</strong></h2><p><strong>以太网协议，依靠MAC地址发送数据</strong>。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。<strong>以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络</strong>。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151261.jpg" alt="640-5"></p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。==如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送==。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，<strong>使得我们能够区分不同的计算机是否属于同一个子网络</strong>。这套地址就叫做”网络地址”，简称”网址”。</p><p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，<strong>MAC地址是绑定在网卡上的，网络地址则是管理员分配的</strong>，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a><strong>IP协议</strong></h2><p><strong>规定网络地址的协议</strong>，叫做IP协议。它所定义的地址，就被称为==IP地址==。目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151262.jpg" alt="640-6"></p><p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，==怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？==这就要用到另一个参数”子网掩码”（subnet mask）。</p><p>所谓”==子网掩码==”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是</p><p>11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行==AND运算==（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，I==P协议的作用主要有两个==，一个是<strong>为每一台计算机分配IP地址</strong>，另一个是<strong>确定哪些地址在同一个子网络</strong>。</p><h2 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a><strong>IP数据包</strong></h2><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。==这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构==。</p><p>具体来说，==IP数据包==也分为”首部”和”数据”两个部分。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151300.png" alt="640"></p><p>“首部”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151301.png" alt="640-2"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a><strong>ARP协议</strong></h2><p>关于”网络层”，还有最后一点需要说明。因为IP数据包是放在以太网数据包里发送的，所以我们<strong>必须同时知道两个地址</strong>，一个是==对方的MAC地址==，另一个是==对方的IP地址==。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>所以，==我们需要一种机制，能够从IP地址得到MAC地址==。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用==ARP协议==，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。<strong>如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包</strong>。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层的由来"><a href="#传输层的由来" class="headerlink" title="传输层的由来"></a><strong>传输层的由来</strong></h2><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，<strong>我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用</strong>。这个参数就叫做”==端口==”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>==”传输层”的功能，就是建立”端口到端口”的通信==。相比之下，==”网络层”的功能是建立”主机到主机”的通信==。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把<strong>主机+端口，叫做”套接字”（socket</strong>）。有了它，就可以进行网络应用程序开发了。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a><strong>UDP协议</strong></h2><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”首部”和”数据”两部分组成。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151302.png" alt="img"></p><p>“==首部==”部分主要定义了<strong>发出端口</strong>和<strong>接收端口</strong>，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151302.jpg" alt="img"></p><p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><strong>TCP协议</strong></h2><p><strong>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到</strong>。</p><p>为了解决这个问题，==提高网络可靠性==，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它==就是有确认机制的UDP协议==，<strong>每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了</strong>。因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h1 id="一个小结"><a href="#一个小结" class="headerlink" title="一个小结"></a>一个小结</h1><p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：<img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151306.jpg" alt="img"></p><p><strong>==发送这个包，需要知道两个地址==：</strong></p><p><strong>1</strong>：对方的MAC地址</p><p><strong>2</strong>：对方的IP地址</p><p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过==网关（gateway）==转发。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151307.jpg" alt="img"></p><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过==路由协议==，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p><strong>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</strong></p><table><thead><tr><th>场景</th><th>数据包地址</th></tr></thead><tbody><tr><td>同一个子网络</td><td>对方的MAC地址，对方的IP地址</td></tr><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr></tbody></table><p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p><h1 id="用户的上网设置"><a href="#用户的上网设置" class="headerlink" title="用户的上网设置"></a>用户的上网设置</h1><h2 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a><strong>静态IP地址</strong></h2><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p><p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p><table><thead><tr><th><strong>1：本机的IP地址</strong></th></tr></thead><tbody><tr><td><strong>2：子网掩码</strong></td></tr><tr><td><strong>3：网关的IP地址</strong></td></tr><tr><td><strong>4：DNS的IP地址</strong></td></tr></tbody></table><p>下图是==Windows系统==的设置窗口:</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151308.png" alt="img"></p><p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”==静态IP地址上网==”。</p><p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p><p>##动态IP地址</p><p>所谓”==动态IP地址==”，<strong>指计算机开机后，会自动分配到一个IP地址，不用人为设定</strong>。它使用的协议叫做==DHCP协议==。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定。</p><p>###<strong>DHCP协议</strong></p><p>首先，它是一种==应用层协议==，建立在UDP协议之上，所以整个数据包是这样的：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151309.jpg" alt="img"></p><blockquote><p><strong>1</strong>：最前面的”以太网标头（也就是14字节首部）”，<strong>设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址</strong>。前者就是==本机网卡的MAC地址==，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p><strong>2</strong>：后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p><strong>3</strong>：最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是==68端口==，接收方是==67端口==。</p></blockquote><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”==DHCP响应==”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><p>#上网设置：小结</p><p>这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p><blockquote><p><strong>1</strong>：本机的IP地址</p><p><strong>2</strong>：子网掩码</p><p><strong>3</strong>：网关的IP地址</p><p><strong>4</strong>：DNS的IP地址</p></blockquote><p>有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p><p>#一个实例：访问网页</p><p>##<strong>本机参数</strong></p><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数，在继续往下看之前，大家可以先记在自己的草稿纸上：</p><p><strong>==本机的IP地址==</strong>：192.168.1.100</p><p><strong>==子网掩码==</strong>：255.255.255.0</p><p><strong>==网关的IP地址==</strong>：192.168.1.1</p><p><strong>==DNS的IP地址==</strong>：8.8.8.8</p><p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151310.jpg" alt="img"></p><p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><p>##<strong>DNS协议</strong></p><p><strong>Domain Name System</strong></p><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a href="http://www.google.com，不知道它的IP地址。" target="_blank" rel="noopener">www.google.com，不知道它的IP地址。</a></p><p>DNS协议可以帮助我们，==将这个网址转换成IP地址==。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个<strong>DNS数据包</strong>（==53端口==）。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151311.jpg" alt="img"></p><p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><p>##<strong>子网掩码</strong></p><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到==子网掩码==。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的==AND运算==（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须==通过网关192.168.1.1转发==，也就是说，接收方的MAC地址将是网关的MAC地址。</p><p>#应用层协议</p><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151312.jpg" alt="img"></p><p>HTTP部分的内容，类似于下面这样：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151313.png" alt="img"></p><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><p>##<strong>TCP协议</strong></p><p>TCP数据包需要设置端口，接收方（Google）的==HTTP端口==默认是80，发送方（本机）的端口是一个==随机生成==的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为==20字节==，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h2 id="IP协议-1"><a href="#IP协议-1" class="headerlink" title="IP协议"></a><strong>IP协议</strong></h2><p>然后，TCP数据包再嵌入IP数据包。==IP数据包需要设置双方的IP地址==，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为==20字节==，加上嵌入的TCP数据包，总长度变为5000字节。</p><p>##<strong>以太网协议</strong></p><p>最后，IP数据包嵌入以太网数据包。<strong>以太网数据包需要设置双方的MAC地址</strong>，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151314.jpg" alt="img"></p><h2 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a><strong>服务器端响应</strong></h2><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>==根据IP标头的序号，Google将四个包拼起来==，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151317.jpg" alt="img"></p><p>这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式也可以这么简单</title>
      <link href="/2019/03/25/she-ji-mo-shi/"/>
      <url>/2019/03/25/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p><a id="more"></a><p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。是的，我不善于扯这些有的没的，还是少点废话吧<del>~</del></p><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><p><strong>目录</strong></p><!-- toc --><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p><pre><code class="java">public class FoodFactory {    public static Food makeFood(String name) {        if (name.equals(&quot;noodle&quot;)) {            Food noodle = new LanZhouNoodle();            noodle.addSpicy(&quot;more&quot;);            return noodle;        } else if (name.equals(&quot;chicken&quot;)) {            Food chicken = new HuangMenChicken();            chicken.addCondiment(&quot;potato&quot;);            return chicken;        } else {            return null;        }    }}</code></pre><p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p><p>简单地说，==简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。==</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。但是违反了开放封闭原则。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><pre><code class="java">public interface FoodFactory {    Food makeFood(String name);}public class ChineseFoodFactory implements FoodFactory {    @Override    public Food makeFood(String name) {        if (name.equals(&quot;A&quot;)) {            return new ChineseFoodA();        } else if (name.equals(&quot;B&quot;)) {            return new ChineseFoodB();        } else {            return null;        }    }}public class AmericanFoodFactory implements FoodFactory {    @Override    public Food makeFood(String name) {        if (name.equals(&quot;A&quot;)) {            return new AmericanFoodA();        } else if (name.equals(&quot;B&quot;)) {            return new AmericanFoodB();        } else {            return null;        }    }}</code></pre><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><pre><code class="java">public class APP {    public static void main(String[] args) {        // 先选择一个具体的工厂        FoodFactory factory = new ChineseFoodFactory();        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象        Food food = factory.makeFood(&quot;A&quot;);    }}</code></pre><p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>==核心在于，我们需要在第一步选好我们需要的工厂==</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/factory-1.png" alt="factory-1"></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-1.png" alt="factory-1"></p><p>这个时候的客户端调用是这样的：</p><pre><code class="java">// 得到 Intel 的 CPUCPUFactory cpuFactory = new IntelCPUFactory();CPU cpu = intelCPUFactory.makeCPU();// 得到 AMD 的主板MainBoardFactory mainBoardFactory = new AmdMainBoardFactory();MainBoard mainBoard = mainBoardFactory.make();// 组装 CPU 和主板Computer computer = new Computer(cpu, mainBoard);</code></pre><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-2.png" alt="abstract-factory-2"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/abstract-factory-3.png" alt="abstract-factory-3"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><pre><code class="java">public static void main(String[] args) {    // 第一步就要选定一个“大厂”    ComputerFactory cf = new AmdFactory();    // 从这个大厂造 CPU    CPU cpu = cf.makeCPU();    // 从这个大厂造主板    MainBoard board = cf.makeMainBoard();      // 从这个大厂造硬盘      HardDisk hardDisk = cf.makeHardDisk();    // 将同一个厂子出来的 CPU、主板、硬盘组装在一起    Computer result = new Computer(cpu, board, hardDisk);}</code></pre><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>==对修改关闭，对扩展开放==</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><pre><code class="java">public class Singleton {    // 首先，将 new Singleton() 堵死    private Singleton() {};    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建    private static Singleton instance = new Singleton();    public static Singleton getInstance() {        return instance;    }    // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，    // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了    public static Date getDate(String mode) {return new Date();}}</code></pre><blockquote><p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><pre><code class="java">public class Singleton {    // 首先，也是先堵死 new Singleton() 这条路    private Singleton() {}    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的    private static volatile Singleton instance = null;    public static Singleton getInstance() {        if (instance == null) {            // 加锁            synchronized (Singleton.class) {                // 这一次判断也是必须的，不然会有并发问题                if (instance == null) {                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><pre><code class="java">public class Singleton3 {    private Singleton3() {}    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性    private static class Holder {        private static Singleton3 instance = new Singleton3();    }    public static Singleton3 getInstance() {        return Holder.instance;    }}</code></pre><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，一定有人跳出来说用枚举实现单例，是的没错，枚举类很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。不说了，读者自己看着办吧，不建议使用。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><pre><code class="java">Food food = new FoodBuilder().a().b().c().build();Food food = Food.builder().a().b().c().build();</code></pre><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p><p>来一个中规中矩的建造者模式：</p><pre><code class="java">class User {    // 下面是“一堆”的属性    private String name;    private String password;    private String nickName;    private int age;    // 构造方法私有化，不然客户端就会直接调用构造方法了    private User(String name, String password, String nickName, int age) {        this.name = name;        this.password = password;        this.nickName = nickName;        this.age = age;    }    // 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，    // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好    public static UserBuilder builder() {        return new UserBuilder();    }    public static class UserBuilder {        // 下面是和 User 一模一样的一堆属性        private String  name;        private String password;        private String nickName;        private int age;        private UserBuilder() {        }        // 链式调用设置各个属性值，返回 this，即 UserBuilder        public UserBuilder name(String name) {            this.name = name;            return this;        }        public UserBuilder password(String password) {            this.password = password;            return this;        }        public UserBuilder nickName(String nickName) {            this.nickName = nickName;            return this;        }        public UserBuilder age(int age) {            this.age = age;            return this;        }        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。        // 当然，可以在 “复制” 之前做点检验        public User build() {            if (name == null || password == null) {                throw new RuntimeException(&quot;用户名和密码必填&quot;);            }            if (age &lt;= 0 || age &gt;= 150) {                throw new RuntimeException(&quot;年龄不合法&quot;);            }            // 还可以做赋予”默认值“的功能              if (nickName == null) {                nickName = name;            }            return new User(name, password, nickName, age);        }    }}</code></pre><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><pre><code class="java">public class APP {    public static void main(String[] args) {        User d = User.builder()                .name(&quot;foo&quot;)                .password(&quot;pAss12345&quot;)                .age(25)                .build();    }}</code></pre><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><pre><code class="java">@Builderclass User {    private String  name;    private String password;    private String nickName;    private int age;}</code></pre><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><pre><code class="java">User user = new User().setName(&quot;&quot;).setPassword(&quot;&quot;).setAge(20);</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><pre><code class="java">protected native Object clone() throws CloneNotSupportedException;</code></pre><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><pre><code class="java">public interface FoodService {    Food makeChicken();    Food makeNoodle();}public class FoodServiceImpl implements FoodService {    public Food makeChicken() {          Food f = new Chicken()        f.setChicken(&quot;1kg&quot;);          f.setSpicy(&quot;1g&quot;);          f.setSalt(&quot;3g&quot;);        return f;    }    public Food makeNoodle() {        Food f = new Noodle();        f.setNoodle(&quot;500g&quot;);        f.setSalt(&quot;5g&quot;);        return f;    }}// 代理要表现得“就像是”真实实现类，所以需要实现 FoodServicepublic class FoodServiceProxy implements FoodService {    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入    private FoodService foodService = new FoodServiceImpl();    public Food makeChicken() {        System.out.println(&quot;我们马上要开始制作鸡肉了&quot;);        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，        // 代理只是在核心代码前后做些“无足轻重”的事情        Food food = foodService.makeChicken();        System.out.println(&quot;鸡肉制作完成啦，加点胡椒粉&quot;); // 增强          food.addCondiment(&quot;pepper&quot;);        return food;    }    public Food makeNoodle() {        System.out.println(&quot;准备制作拉面~&quot;);        Food food = foodService.makeNoodle();        System.out.println(&quot;制作完成啦&quot;)        return food;    }}</code></pre><p>客户端调用，注意，我们要用代理来实例化接口：</p><pre><code class="java">// 这里用代理类来实例化FoodService foodService = new FoodServiceProxy();foodService.makeChicken();</code></pre><p><img src="https://www.javadoop.com/blogimages/design-pattern/proxy-1.png" alt="proxy"></p><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，算了还是不要吹捧这个名词了，在 AOP 中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说 …… ==Spring 中实现动态代理有两种==，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><pre><code class="java">public interface FileAlterationListener {    void onStart(final FileAlterationObserver observer);    void onDirectoryCreate(final File directory);    void onDirectoryChange(final File directory);    void onDirectoryDelete(final File directory);    void onFileCreate(final File file);    void onFileChange(final File file);    void onFileDelete(final File file);    void onStop(final FileAlterationObserver observer);}</code></pre><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><pre><code class="java">public class FileAlterationListenerAdaptor implements FileAlterationListener {    public void onStart(final FileAlterationObserver observer) {    }    public void onDirectoryCreate(final File directory) {    }    public void onDirectoryChange(final File directory) {    }    public void onDirectoryDelete(final File directory) {    }    public void onFileCreate(final File file) {    }    public void onFileChange(final File file) {    }    public void onFileDelete(final File file) {    }    public void onStop(final FileAlterationObserver observer) {    }}</code></pre><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><pre><code class="java">public class FileMonitor extends FileAlterationListenerAdaptor {    public void onFileCreate(final File file) {        // 文件创建        doSomething();    }    public void onFileDelete(final File file) {        // 文件删除        doSomething();    }}</code></pre><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><pre><code class="java">public interface Duck {    public void quack(); // 鸭的呱呱叫      public void fly(); // 飞}public interface Cock {    public void gobble(); // 鸡的咕咕叫      public void fly(); // 飞}public class WildCock implements Cock {    public void gobble() {        System.out.println(&quot;咕咕叫&quot;);    }      public void fly() {        System.out.println(&quot;鸡也会飞哦&quot;);    }}</code></pre><p>鸭接口有 fly() 和 quack() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><pre><code class="java">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用public class CockAdapter implements Duck {    Cock cock;    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用      public CockAdapter(Cock cock) {        this.cock = cock;    }    // 实现鸭的呱呱叫方法      @Override      public void quack() {        // 内部其实是一只鸡的咕咕叫        cock.gobble();    }      @Override      public void fly() {        cock.fly();    }}</code></pre><p>客户端调用很简单了：</p><pre><code class="java">public static void main(String[] args) {    // 有一只野鸡      Cock wildCock = new WildCock();      // 成功将野鸡适配成鸭      Duck duck = new CockAdapter(wildCock);      ...}</code></pre><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-1.png" alt="adapter-1"></p><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-2.png" alt="adapter-1"></p><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，<strong>代理模式做的是增强原方法的活</strong>；<strong>适配器做的是适配的活</strong>，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/adapter-5.png" alt="adapter-5"></p></li></ol><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><pre><code class="java">public interface DrawAPI {   public void draw(int radius, int x, int y);}</code></pre><p>然后是一系列实现类：</p><pre><code class="java">public class RedPen implements DrawAPI {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class GreenPen implements DrawAPI {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class BluePen implements DrawAPI {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}</code></pre><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><pre><code class="java">public abstract class Shape {   protected DrawAPI drawAPI;   protected Shape(DrawAPI drawAPI){      this.drawAPI = drawAPI;   }   public abstract void draw();    }</code></pre><p>定义抽象类的子类：</p><pre><code class="java">// 圆形public class Circle extends Shape {   private int radius;   public Circle(int radius, DrawAPI drawAPI) {      super(drawAPI);      this.radius = radius;   }   public void draw() {      drawAPI.draw(radius, 0, 0);   }}// 长方形public class Rectangle extends Shape {    private int x;      private int y;      public Rectangle(int x, int y, DrawAPI drawAPI) {        super(drawAPI);          this.x = x;          this.y = y;    }      public void draw() {      drawAPI.draw(0, x, y);   }}</code></pre><p>最后，我们来看客户端演示：</p><pre><code class="java">public static void main(String[] args) {    Shape greenCircle = new Circle(10, new GreenPen());      Shape redRectangle = new Rectangle(4, 8, new RedPen());      greenCircle.draw();      redRectangle.draw();}</code></pre><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><blockquote><p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm" target="_blank" rel="noopener">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 Java IO 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-1.png" alt="decorator-1"></p><p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 ConcreteDecorator* 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？万一有个变态要四份柠檬，所以这种做法是给自己找加班的。</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><pre><code class="java">public abstract class Beverage {      // 返回描述      public abstract String getDescription();      // 返回价格      public abstract double cost();}</code></pre><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><pre><code class="java">public class BlackTea extends Beverage {      public String getDescription() {        return &quot;红茶&quot;;    }      public double cost() {        return 10;    }}public class GreenTea extends Beverage {    public String getDescription() {        return &quot;绿茶&quot;;    }      public double cost() {        return 11;    }}...// 咖啡省略</code></pre><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><pre><code class="java">// 调料public abstract class Condiment extends Beverage {}</code></pre><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承 Condiment 类：</p><pre><code class="java">public class Lemon extends Condiment {    private Beverage bevarage;      // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，      // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶      public Lemon(Beverage bevarage) {        this.bevarage = bevarage;    }      public String getDescription() {        // 装饰        return bevarage.getDescription() + &quot;, 加柠檬&quot;;    }      public double cost() {          // 装饰        return beverage.cost() + 2; // 加柠檬需要 2 元    }}public class Mango extends Condiment {    private Beverage bevarage;      public Mango(Beverage bevarage) {        this.bevarage = bevarage;    }      public String getDescription() {        return bevarage.getDescription() + &quot;, 加芒果&quot;;    }      public double cost() {        return beverage.cost() + 3; // 加芒果需要 3 元    }}...// 给每一种调料都加一个类</code></pre><p>看客户端调用：</p><pre><code class="java">public static void main(String[] args) {      // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡    Beverage beverage = new GreenTea();      // 开始装饰      beverage = new Lemon(beverage); // 先加一份柠檬      beverage = new Mongo(beverage); // 再加一份芒果      System.out.println(beverage.getDescription() + &quot; 价格：￥&quot; + beverage.cost());      //&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;}</code></pre><p>如果我们需要芒果珍珠双份柠檬红茶：</p><pre><code class="java">Beverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea()))));</code></pre><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-2.png" alt="decorator-2"></p><p>到这里，大家应该已经清楚装饰模式了吧。</p><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/decorator-3.png" alt="decorator-3"></p><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，其实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><pre><code class="java">InputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(&quot;&quot;)));</code></pre><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><pre><code class="java">DataInputStream is = new DataInputStream(                              new BufferedInputStream(                                  new FileInputStream(&quot;&quot;)));</code></pre><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><pre><code class="java">public interface Shape {   void draw();}</code></pre><p>定义几个实现类：</p><pre><code class="java">public class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Circle::draw()&quot;);   }}public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Rectangle::draw()&quot;);   }}</code></pre><p>客户端调用：</p><pre><code class="java">public static void main(String[] args) {    // 画一个圆形      Shape circle = new Circle();      circle.draw();      // 画一个长方形      Shape rectangle = new Rectangle();      rectangle.draw();}</code></pre><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><pre><code class="java">public class ShapeMaker {   private Shape circle;   private Shape rectangle;   private Shape square;   public ShapeMaker() {      circle = new Circle();      rectangle = new Rectangle();      square = new Square();   }  /**   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定   */   public void drawCircle(){      circle.draw();   }   public void drawRectangle(){      rectangle.draw();   }   public void drawSquare(){      square.draw();   }}</code></pre><p>看看现在客户端怎么调用：</p><pre><code class="java">public static void main(String[] args) {  ShapeMaker shapeMaker = new ShapeMaker();  // 客户端调用现在更加清晰了  shapeMaker.drawCircle();  shapeMaker.drawRectangle();  shapeMaker.drawSquare();        }</code></pre><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><pre><code class="java">public class Employee {   private String name;   private String dept;   private int salary;   private List&lt;Employee&gt; subordinates; // 下属   public Employee(String name,String dept, int sal) {      this.name = name;      this.dept = dept;      this.salary = sal;      subordinates = new ArrayList&lt;Employee&gt;();   }   public void add(Employee e) {      subordinates.add(e);   }   public void remove(Employee e) {      subordinates.remove(e);   }   public List&lt;Employee&gt; getSubordinates(){     return subordinates;   }   public String toString(){      return (&quot;Employee :[ Name : &quot; + name + &quot;, dept : &quot; + dept + &quot;, salary :&quot; + salary+&quot; ]&quot;);   }   }</code></pre><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><p>首先，先定义一个策略接口：</p><pre><code class="java">public interface Strategy {   public void draw(int radius, int x, int y);}</code></pre><p>然后我们定义具体的几个策略：</p><pre><code class="java">public class RedPen implements Strategy {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class GreenPen implements Strategy {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class BluePen implements Strategy {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}</code></pre><p>使用策略的类：</p><pre><code class="java">public class Context {   private Strategy strategy;   public Context(Strategy strategy){      this.strategy = strategy;   }   public int executeDraw(int radius, int x, int y){      return strategy.draw(radius, x, y);   }}</code></pre><p>客户端演示：</p><pre><code class="java">public static void main(String[] args) {    Context context = new Context(new BluePen()); // 使用绿色笔来画      context.executeDraw(10, 0, 0);}</code></pre><p>放到一张图上，让大家看得清晰些：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/strategy-1.png" alt="strategy-1"></p><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><p><img src="https://www.javadoop.com/blogimages/design-pattern/bridge-1.png" alt="bridge-1"></p><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><pre><code class="java">public class Subject {   private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();   private int state;   public int getState() {      return state;   }   public void setState(int state) {      this.state = state;      // 数据已变更，通知观察者们      notifyAllObservers();   }   public void attach(Observer observer){      observers.add(observer);           }   // 通知观察者们   public void notifyAllObservers(){      for (Observer observer : observers) {         observer.update();      }   }     }</code></pre><p>定义观察者接口：</p><pre><code class="java">public abstract class Observer {   protected Subject subject;   public abstract void update();}</code></pre><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><p>我们来定义具体的几个观察者类：</p><pre><code class="java">public class BinaryObserver extends Observer {      // 在构造方法中进行订阅主题    public BinaryObserver(Subject subject) {        this.subject = subject;        // 通常在构造方法中将 this 发布出去的操作一定要小心        this.subject.attach(this);    }      // 该方法由主题类在数据变更的时候进行调用    @Override    public void update() {        String result = Integer.toBinaryString(subject.getState());        System.out.println(&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot; + result);    }}public class HexaObserver extends Observer {    public HexaObserver(Subject subject) {        this.subject = subject;        this.subject.attach(this);    }    @Override    public void update() {          String result = Integer.toHexString(subject.getState()).toUpperCase();        System.out.println(&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot; + result);    }}</code></pre><p>客户端使用也非常简单：</p><pre><code class="java">public static void main(String[] args) {    // 先定义一个主题      Subject subject1 = new Subject();      // 定义观察者      new BinaryObserver(subject1);      new HexaObserver(subject1);      // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用      subject.setState(11);}</code></pre><p>output:</p><pre><code>订阅的数据发生变化，新的数据处理为二进制值为：1011订阅的数据发生变化，新的数据处理为十六进制值为：B</code></pre><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><pre><code class="java">public abstract class RuleHandler {      // 后继节点    protected RuleHandler successor;    public abstract void apply(Context context);    public void setSuccessor(RuleHandler successor) {        this.successor = successor;    }    public RuleHandler getSuccessor() {        return successor;    }}</code></pre><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><pre><code class="java">public class NewUserRuleHandler extends RuleHandler {    public void apply(Context context) {        if (context.isNewUser()) {              // 如果有后继节点的话，传递下去            if (this.getSuccessor() != null) {                this.getSuccessor().apply(context);            }        } else {            throw new RuntimeException(&quot;该活动仅限新用户参与&quot;);        }    }}</code></pre><p>校验用户所在地区是否可以参与：</p><pre><code class="java">public class LocationRuleHandler extends RuleHandler {    public void apply(Context context) {        boolean allowed = activityService.isSupportedLocation(context.getLocation);          if (allowed) {            if (this.getSuccessor() != null) {                this.getSuccessor().apply(context);            }        } else  {            throw new RuntimeException(&quot;非常抱歉，您所在的地区无法参与本次活动&quot;);        }    }}</code></pre><p>校验奖品是否已领完：</p><pre><code class="java">public class LimitRuleHandler extends RuleHandler {    public void apply(Context context) {          int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品        if (remainedTimes &gt; 0) {            if (this.getSuccessor() != null) {                this.getSuccessor().apply(userInfo);            }        } else {            throw new RuntimeException(&quot;您来得太晚了，奖品被领完了&quot;);        }    }}</code></pre><p>客户端：</p><pre><code class="java">public static void main(String[] args) {    RuleHandler newUserHandler = new NewUserRuleHandler();      RuleHandler locationHandler = new LocationRuleHandler();      RuleHandler limitHandler = new LimitRuleHandler();      // 假设本次活动仅校验地区和奖品数量，不校验新老用户      locationHandler.setSuccessor(limitHandler);      locationHandler.apply(context);}</code></pre><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的，这也是在开源代码中大量被使用的。</p><p>通常会有一个抽象类：</p><pre><code class="java">public abstract class AbstractTemplate {    // 这就是模板方法      public void templateMethod(){        init();        apply(); // 这个是重点        end(); // 可以作为钩子方法    }    protected void init() {        System.out.println(&quot;init 抽象层已经实现，子类也可以选择覆写&quot;);    }      // 留给子类实现    protected abstract void apply();    protected void end() {    }}</code></pre><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>我们写一个实现类：</p><pre><code class="java">public class ConcreteTemplate extends AbstractTemplate {    public void apply() {        System.out.println(&quot;子类实现抽象方法 apply&quot;);    }      public void end() {        System.out.println(&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;);    }}</code></pre><p>客户端调用演示：</p><pre><code class="java">public static void main(String[] args) {    AbstractTemplate t = new ConcreteTemplate();      // 调用模板方法      t.templateMethod();}</code></pre><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><pre><code class="java">public interface State {   public void doAction(Context context);}</code></pre><p>定义减库存的状态：</p><pre><code class="java">public class DeductState implements State {   public void doAction(Context context) {      System.out.println(&quot;商品卖出，准备减库存&quot;);      context.setState(this);      //... 执行减库存的具体操作   }   public String toString(){      return &quot;Deduct State&quot;;   }}</code></pre><p>定义补库存状态：</p><pre><code class="java">public class RevertState implements State {    public void doAction(Context context) {        System.out.println(&quot;给此商品补库存&quot;);          context.setState(this);          //... 执行加库存的具体操作    }      public String toString() {        return &quot;Revert State&quot;;    }}</code></pre><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><pre><code class="java">public class Context {    private State state;      private String name;      public Context(String name) {        this.name = name;    }      public void setState(State state) {        this.state = state;    }      public void getState() {        return this.state;    }}</code></pre><p>我们来看下客户端调用，大家就一清二楚了：</p><pre><code class="java">public static void main(String[] args) {    // 我们需要操作的是 iPhone X    Context context = new Context(&quot;iPhone X&quot;);    // 看看怎么进行补库存操作      State revertState = new RevertState();      revertState.doAction(context);    // 同样的，减库存操作也非常简单      State deductState = new DeductState();      deductState.doAction(context);      // 如果需要我们可以获取当前的状态    // context.getState().toString();}</code></pre><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p>（全文完）</p>]]></content>
      
      
      
        <tags>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
