<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>部署linux服务器遇到的坑</title>
      <link href="/2019/06/30/linux/bu-shu-linux-fu-wu-qi-yu-dao-de-keng/"/>
      <url>/2019/06/30/linux/bu-shu-linux-fu-wu-qi-yu-dao-de-keng/</url>
      
        <content type="html"><![CDATA[<h1 id="解决ubuntu终端无法输入中文的问题"><a href="#解决ubuntu终端无法输入中文的问题" class="headerlink" title="解决ubuntu终端无法输入中文的问题"></a>解决ubuntu终端无法输入中文的问题</h1><p>首先要从Ubuntu语言设置那里，把中文语言包安装上</p><p>打开<code>/etc/environment</code>,增添如下:</p><pre><code class="bash">root@xxh:~# vim /etc/environmentPATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;LANG=”zh_CN.UTF-8″LANGUAGE=”zh_CN:zh:en_US:en”</code></pre><p>打开 <code>/var/lib/locales/supported.d/local</code></p><pre><code class="bash">root@xxh:~# vim /var/lib/locales/supported.d/local</code></pre><p>增添</p><pre><code class="bash">en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8zh_CN.GBK GBKzh_CN GB2312</code></pre><p>保存后，执行命令：</p><pre><code class="bash">sudo locale-gen</code></pre><p>打开<code>/etc/default/locale</code></p><p>修改为</p><pre><code>LANG=”zh_CN.UTF-8″LANGUAGE=”zh_CN:zh:en_US:en”</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 阿里云服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客搭建过程细节记录</title>
      <link href="/2019/06/29/blog/bo-ke-da-jian-guo-cheng-de-xi-jie/"/>
      <url>/2019/06/29/blog/bo-ke-da-jian-guo-cheng-de-xi-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="怎么直接修改-blog-source-posts下的-md文章"><a href="#怎么直接修改-blog-source-posts下的-md文章" class="headerlink" title="怎么直接修改/blog/source/_posts下的.md文章"></a>怎么直接修改/blog/source/_posts下的.md文章</h1><p>因为hexo默认用户是不能随便修改<code>/blog/source/_posts</code>下的.md文件的，如果每次直接在命令行下新建文章：</p><pre><code class="bash">hexo new &#39;文章名字&#39;</code></pre><p>在命令行下编辑就太麻烦了</p><p>解决方法：</p><p>hexo默认是不能编辑blog/目录下的文件的，这时候我们需要赋权限</p><pre><code class="bash">sudo chmod -R  777 blog</code></pre><h1 id="如何让博文列表不显示全部内容？"><a href="#如何让博文列表不显示全部内容？" class="headerlink" title="如何让博文列表不显示全部内容？"></a>如何让博文列表不显示全部内容？</h1><p>iPIC默认情况下，生成的博文目录会显示全部的文章内容，如果这样我们的网站会很麻烦</p><p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可。</p><h1 id="本地写作时图床的最佳解决方案"><a href="#本地写作时图床的最佳解决方案" class="headerlink" title="本地写作时图床的最佳解决方案"></a>本地写作时图床的最佳解决方案</h1><p>因为markdown本身不能存储图片,一般会把图片存到本地或者可以选择存到阿里云和七牛云上.</p><p>之前用过七牛云,因为七牛云对象存储中的bucket(你想要存储空间的标识)一个月就过期,bucket的外网连接地址会改变,所以干脆我直接使用了阿里云的对象存储OSS(好像可以领个6个月的免费资源包40G).</p><p>而图床功能用的是iPic这个软件,但是这个软件的图床如果想用阿里云,需要付费的,其实可以根据阿里云提供的SDK自己写,顺便可以练练自己的代码能力</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035417.png" alt="屏幕快照 2019-07-12 上午11.53.50"></p><p>此外,如果说没有用到ipic之前,图片都存在本地,怎么将图片的地址改为阿里云OSS中的地址呢?</p><p>其实可以结合<code>iPic Mover</code>,</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035316.png" alt="屏幕快照 2019-07-12 上午11.52.30"></p><ul><li>选择Markdown文件所在文件夹:markdown文件的批量操作,直接选择文件夹即可</li><li>选择Markdown文件:针对单个markdown文件</li></ul><p>使用完成,markdown文件中的文件引用就会变成阿里云中OSS中的文件</p><h1 id="Node-js报错：SyntaxError-Use-of-const-in-strict-mode"><a href="#Node-js报错：SyntaxError-Use-of-const-in-strict-mode" class="headerlink" title="Node.js报错：SyntaxError: Use of const in strict mode."></a>Node.js报错：SyntaxError: Use of const in strict mode.</h1><pre><code>const utils = require(&#39;./utils&#39;);^^^^^SyntaxError: Use of const in strict mode.    at Module._compile (module.js:439:25)    at Object.Module._extensions..js (module.js:474:10)    at Module.load (module.js:356:32)    at Function.Module._load (module.js:312:12)    at Module.require (module.js:364:17)    at require (module.js:380:17)    at Object.&lt;anonymous&gt; (/home/de/projects/xxx/login.js:1:70)    at Module._compile (module.js:456:26)    at Object.Module._extensions..js (module.js:474:10)    at Module.load (module.js:356:32)</code></pre><p> 意思是不能使用const。查了下，原因是Node.js版本太低，需要升级node.js。</p><p>升级Node.js：</p><pre><code class="bash">npm cache clean -fsudo npm install -g nsudo n stable</code></pre>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
            <tag> hexo </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>外网SSH连接内网Windows上linux虚拟机</title>
      <link href="/2019/06/28/linux/wai-wang-ssh-lian-jie-nei-wang-windows-shang-linux-xu-ni-ji/"/>
      <url>/2019/06/28/linux/wai-wang-ssh-lian-jie-nei-wang-windows-shang-linux-xu-ni-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>外网SSH连接学校内网的Windows科研电脑上的linux虚拟机</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>学校网络之外的外网机器 SSH远程连接 内网电脑对应的外网IP，内网电脑接受到外网SSH连接请求，再通过虚拟机的NAT模式（端口转发模式），即宿主PC机转发外网SSH请求到虚拟机对应的端口号，间接的访问虚拟机的Linux。</p><a id="more"></a><h1 id="prerequisite"><a href="#prerequisite" class="headerlink" title="prerequisite"></a>prerequisite</h1><p>有了思路，我们需要做的准备</p><ol><li>VMware的网络连接选择NAT模式—&gt;达到转发SSH请求到虚拟机的效果</li><li>虚拟机要有对应的SSH服务—&gt;<code>sudo apt-get install openssh-server</code></li><li>使用<strong>nat123</strong>达到内网穿透</li></ol><h2 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h2><p>学校内网的ip实际上网络经过了很多中间层的映射，而这个映射很复杂的，学校也不可能告诉我们，所以不可以或者很难直接用内网IP映射成外网IP，进而提供SSH服务。</p><p>但是我们可以使用工具，如nat123、神卓互联、花生壳等，将学校内网IP直接映射成外网IP</p><h1 id="let’s-start"><a href="#let’s-start" class="headerlink" title="let’s start"></a>let’s start</h1><h2 id="1-设置VMware"><a href="#1-设置VMware" class="headerlink" title="1 设置VMware"></a>1 设置VMware</h2><ol><li>虚拟网络编辑器</li></ol><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035557.png" alt="虚拟网络编辑器"></p><p>在VMnet8类型换成NAT模式</p><p>在进行NAT设置之前，需要查看虚拟机的IP，使用<code>ifconfig</code></p><pre><code class="bash">aliceyu@aliceyu-virtual-machine:~$ ifconfig ens33     Link encap:Ethernet  HWaddr 00:0c:29:14:cd:ad            inet addr:192.168.11.128  Bcast:192.168.11.255  Mask:255.255.255.0          inet6 addr: fe80::f557:95a2:e8bf:5b89/64 Scope:Link          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1          RX packets:9979 errors:0 dropped:0 overruns:0 frame:0          TX packets:2844 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:8368432 (8.3 MB)  TX bytes:201165 (201.1 KB)lo        Link encap:Local Loopback            inet addr:127.0.0.1  Mask:255.0.0.0          inet6 addr: ::1/128 Scope:Host          UP LOOPBACK RUNNING  MTU:65536  Metric:1          RX packets:789 errors:0 dropped:0 overruns:0 frame:0          TX packets:789 errors:0 dropped:0 overruns:0 carrier:0          collisions:0 txqueuelen:1000           RX bytes:63342 (63.3 KB)  TX bytes:63342 (63.3 KB)</code></pre><p>可以看到<code>inet addr:192.168.11.128</code>，这个IP其实是<strong>内网IP</strong></p><ol start="2"><li><p>设置NAT</p><ul><li>添加端口转发：</li></ul><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035559.png" alt="屏幕快照 2019-06-26 下午8.35.22"></p><ul><li>设置端口转发</li></ul><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035559-1.png" alt="屏幕快照 2019-06-26 下午9.06.55"></p></li></ol><p>到现在为止，Windows宿主机已经可以将请求通过虚拟机的NAT模式转发到虚拟机了。</p><p>但是前提是虚拟机要支持openssh-server。默认linux系统里是没有的。</p><h2 id="2-在虚拟机中下载SSH服务"><a href="#2-在虚拟机中下载SSH服务" class="headerlink" title="2 在虚拟机中下载SSH服务"></a>2 在虚拟机中下载SSH服务</h2><h3 id="1-下载-openssh-server"><a href="#1-下载-openssh-server" class="headerlink" title="1. 下载 openssh-server"></a>1. 下载 openssh-server</h3><p>打开Ubuntu的终端，输入：</p><pre><code class="bash">sudo apt-get install openssh-server</code></pre><p>安装完毕后ssh默认已启动。可以使用下述命令查看是否有进程在22端口上监听，即是否已启动：</p><pre><code class="bash">netstat -nat | grep 22</code></pre><h3 id="2-允许root用户远程登录"><a href="#2-允许root用户远程登录" class="headerlink" title="2. 允许root用户远程登录"></a>2. <strong>允许root用户远程登录</strong></h3><ul><li><p>终端输入命令 <strong>sudo vim /etc/ssh/sshd_config</strong> ，修改ssh服务配置文件</p><pre><code class="bash">sudo vim /etc/ssh/sshd_config</code></pre></li><li><p>找到PermitRootLogin，将参数<strong>prohibit-password</strong>改为<strong>yes</strong>，原来是<strong>prohibit-password</strong>，如图所示：</p></li></ul><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035600.png" alt="屏幕快照 2019-06-26 下午8.47.47"></p><ul><li>设置完需ssh配置文件，我们需要要重启ssh服务，命令 <strong>service sshd restart</strong>  或者  <strong>/etc/initd.d/sshd restart</strong></li></ul><h3 id="3-测试"><a href="#3-测试" class="headerlink" title="3. 测试"></a>3. 测试</h3><p>在Windows宿主机上下载SecureCRT软件。</p><p>打开SecureCRT软件，进行配置：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035601.png" alt="屏幕快照 2019-06-26 下午9.12.05"></p><p>ProtoCol模式选为 <code>SSH2</code>，Port为 <code>22</code>（前面NAT设置等虚拟机端口号），HostName为<code>192.168.124.23</code>（那就是我们宿主PC机的IP地址），UserName为我们Ubuntu的登录账户。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035602.png" alt="屏幕快照 2019-06-26 下午9.13.51"></p><p>PassWord为我们Ubuntu的登录密码</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035603.png" alt="屏幕快照 2019-06-26 下午9.14.29"></p><p>配置完成后，如果成功，会进入虚拟机的界面</p><p>到现在为止，我们已经完成了Windows宿主机通过虚拟机NAT模式转发SSH请求到虚拟机，并且虚拟机支持openssh-server操作。接下来就剩下最后一步：<strong>将windows宿主机的内网IP（就是例子中的192.168.124.23）映射到外网。</strong></p><h2 id="3-使用nat123达到内网穿透"><a href="#3-使用nat123达到内网穿透" class="headerlink" title="3 使用nat123达到内网穿透"></a>3 使用<strong>nat123</strong>达到内网穿透</h2><h3 id="nat相关操作"><a href="#nat相关操作" class="headerlink" title="nat相关操作"></a>nat相关操作</h3><p>在宿主机上下载<a href="http://www.nat123.com/Pages_2_32.jsp" target="_blank" rel="noopener">nat123程序</a> ，使用自己的帐号登录。如没有帐号，可以“注册帐号”进入网站进行注册。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035604.png" alt="屏幕快照 2019-06-26 下午9.21.33"></p><p>主面板/端口映射列表/添加映射</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035605.png" alt="屏幕快照 2019-06-26 下午9.24.47"></p><p>设置映射信息。选择<strong>非网站应用映射类型</strong>。填写内网LINUX地址端口，和外网访问的域名。可以使用自己的域名，也可以使用免费二级域名。外网端口在添加映射时，会自动分配一个可用端口，不用更改。将鼠标放在输入框有向导提示。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035606.png" alt="屏幕快照 2019-06-26 下午9.37.17"></p><p>这是官网的教程：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035607.png" alt="屏幕快照 2019-06-26 下午9.27.54"></p><p>添加映射后，可查看映射状态。将鼠标放在映射图标上有提示当着状态信息。新添加映射一般几分钟内生效。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/035609.png" alt="屏幕快照 2019-06-26 下午9.40.31"></p><h2 id="4-进行SSH连接"><a href="#4-进行SSH连接" class="headerlink" title="4 进行SSH连接"></a>4 进行SSH连接</h2><p>用处在外网的电脑连接</p><p>命令行输入：</p><pre><code class="bash">ssh aliceyu@160b2b1e.nat123.cc -p 13604</code></pre><p>解释：</p><pre><code class="properties">aliceyu:虚拟机用户名160b2b1e.nat123.cc:nat123随机分配的域名-p 13604:指定的服务端口号，也是nat123分配的</code></pre><p>其实还有一种连接方式：</p><ol><li><code>ping</code>域名得到外网IP</li></ol><pre><code class="bash">AliceYudeMacBook-Pro:~ alice$ ping 160b2b1e.nat123.ccPING 160b2b1e.nat123.cc (139.199.62.115): 56 data bytes64 bytes from 139.199.62.115: icmp_seq=0 ttl=229 time=42.318 ms64 bytes from 139.199.62.115: icmp_seq=1 ttl=229 time=40.618 ms64 bytes from 139.199.62.115: icmp_seq=2 ttl=229 time=39.732 ms64 bytes from 139.199.62.115: icmp_seq=3 ttl=229 time=46.012 ms64 bytes from 139.199.62.115: icmp_seq=4 ttl=229 time=56.567 ms64 bytes from 139.199.62.115: icmp_seq=5 ttl=229 time=43.138 ms64 bytes from 139.199.62.115: icmp_seq=6 ttl=229 time=56.581 ms64 bytes from 139.199.62.115: icmp_seq=7 ttl=229 time=39.161 ms64 bytes from 139.199.62.115: icmp_seq=8 ttl=229 time=50.325 ms64 bytes from 139.199.62.115: icmp_seq=9 ttl=229 time=37.974 ms64 bytes from 139.199.62.115: icmp_seq=10 ttl=229 time=38.712 ms64 bytes from 139.199.62.115: icmp_seq=11 ttl=229 time=50.818 ms64 bytes from 139.199.62.115: icmp_seq=12 ttl=229 time=39.310 ms</code></pre><p>上述：<code>PING 160b2b1e.nat123.cc (139.199.62.115): 56 data bytes</code>，139.199.62.115就是域名对应的外网IP。</p><ol start="2"><li>ssh连接<code>ssh aliceyu@139.199.62.115 -p 13604</code></li></ol><pre><code class="bash">AliceYudeMacBook-Pro:~ alice$ ssh aliceyu@139.199.62.115 -p 13604aliceyu@139.199.62.115&#39;s password: Welcome to Ubuntu 16.04.5 LTS (GNU/Linux 4.15.0-51-generic x86_64) * Documentation:  https://help.ubuntu.com * Management:     https://landscape.canonical.com * Support:        https://ubuntu.com/advantage148 个可升级软件包。0 个安全更新。New release &#39;18.04.2 LTS&#39; available.Run &#39;do-release-upgrade&#39; to upgrade to it.*** 需要重启系统 ***Last login: Wed Jun 26 21:35:04 2019 from 192.168.124.23aliceyu@aliceyu-virtual-machine:~$ lscore     Downloads         Files  ncbi    TemplatesDesktop  examples.desktop  igv    Public  vmware-rootaliceyu@aliceyu-virtual-machine:~$ </code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/xuliangxing/p/4462929.html" target="_blank" rel="noopener">SSH安装篇之——SecureCRT连接(内网和外网)虚拟机中的Linux系统(Ubuntu)</a></p><p><a href="http://www.nat123.com/Pages_23_539.jsp" target="_blank" rel="noopener">外网SSH访问内网LINUX-非网站应用映射方法</a></p>]]></content>
      
      
      <categories>
          
          <category> 个人探索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> linux虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux安装mysql</title>
      <link href="/2019/06/28/linux/linux-an-zhuang-mysql/"/>
      <url>/2019/06/28/linux/linux-an-zhuang-mysql/</url>
      
        <content type="html"><![CDATA[<p>linux下安装和配置mysql相对在windows上还是比较简单的，不需要自己创建my.cnf文件等。以下步骤亲测有效</p><h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><p>先使用命令：</p><pre><code class="bash">apt-get update </code></pre><p>更新apt-get的package；<br>更新成功后可以使用命令：</p><pre><code class="bash">apt-get install mysql-server </code></pre><p>根据提示输入 root密码后等待即可安装完成。 </p><p>安装完成后 默认账户是 root，密码是root密码</p><h1 id="mysql开启远程连接"><a href="#mysql开启远程连接" class="headerlink" title="mysql开启远程连接"></a>mysql开启远程连接</h1><p>默认情况下，mysql帐号不允许从远程登陆，只能在localhost登录。</p><h2 id="添加用户权限"><a href="#添加用户权限" class="headerlink" title="添加用户权限"></a>添加用户权限</h2><ol><li>如果你想root使用123456（密码）从任何主机连接到mysql服务器的话。</li></ol><pre><code class="mysql">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;</code></pre><p>*.*：所有的databases和所有的表</p><p><strong>‘root’@’%’</strong>：用户名为root的用户，%：所有的host</p><p><strong>IDENTIFIED BY ‘123456’</strong>：但是必须知道密码：123456</p><ol start="2"><li>使修改生效，就可以了</li></ol><pre><code class="mysql">mysql&gt;FLUSH PRIVILEGES;</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>修改 /etc/mysql/my.cnf 配置文件 </p><p>默认</p><pre><code class="bash">bind-address = 127.0.0.1 </code></pre><p>表示只能本地访问(就是localhost)</p><p>修改为：</p><pre><code class="bash">bind-address        =0.0.0.0</code></pre><p>表示任何ip都能访问</p><h1 id="查看mysql服务"><a href="#查看mysql服务" class="headerlink" title="查看mysql服务"></a>查看mysql服务</h1><pre><code class="bash">netstat -tap|grep mysql</code></pre><h1 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h1><p>方式一：</p><pre><code class="bash">sudo /etc/init.d/mysql start </code></pre><p>方式二：</p><pre><code class="bash">sudo service mysql start</code></pre><h1 id="停止mysql"><a href="#停止mysql" class="headerlink" title="停止mysql"></a>停止mysql</h1><p>方式一：</p><pre><code class="bash">sudo /etc/init.d/mysql stop </code></pre><p>方式二：</p><pre><code class="bash">sudo service mysql stop</code></pre><h1 id="重启mysql"><a href="#重启mysql" class="headerlink" title="重启mysql"></a>重启mysql</h1><p>方式一：</p><pre><code class="bash">sudo /etc/init.d/mysql restart</code></pre><p>方式二：</p><pre><code class="bash">sudo service mysql restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux开发必会命令</title>
      <link href="/2019/06/28/linux/linux-kai-fa-bi-hui-ming-ling/"/>
      <url>/2019/06/28/linux/linux-kai-fa-bi-hui-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1.查找文件"></a>1.查找文件</h2><p><code>find / -name filename.txt</code> 根据名称查找/目录下的filename.txt文件。</p><p><code>find . -name &quot;*.xml&quot;</code> 递归查找所有的xml文件</p><p><code>find . -name &quot;*.xml&quot; |xargs grep &quot;hello world&quot;</code> 递归查找所有文件内容中包含hello world的xml文件</p><p><code>grep -H &#39;spring&#39; *.xml</code> 查找所以有的包含spring的xml文件</p><p><code>find ./ -size 0 | xargs rm -f &amp;</code> 删除文件大小为零的文件</p><p><code>ls -l | grep &#39;.jar&#39;</code> 查找当前目录中的所有jar文件</p><p><code>grep &#39;test&#39; d*</code> 显示所有以d开头的文件中包含test的行。</p><p><code>grep &#39;test&#39; aa bb cc</code> 显示在aa，bb，cc文件中匹配test的行。</p><p><code>grep &#39;[a-z]\{5\}&#39; aa</code> 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><h2 id="2-查看一个程序是否运行"><a href="#2-查看一个程序是否运行" class="headerlink" title="2.查看一个程序是否运行"></a>2.查看一个程序是否运行</h2><p><code>ps –ef|grep tomcat</code> 查看所有有关tomcat的进程</p><p><code>ps -ef|grep --color java</code> 高亮要查询的关键字</p><h2 id="3-终止线程"><a href="#3-终止线程" class="headerlink" title="3.终止线程"></a>3.终止线程</h2><p><code>kill -9 19979</code> 终止线程号位19979的进程</p><h2 id="4-查看文件，包含隐藏文件"><a href="#4-查看文件，包含隐藏文件" class="headerlink" title="4.查看文件，包含隐藏文件"></a>4.查看文件，包含隐藏文件</h2><pre><code>ls -al</code></pre><h2 id="5-当前工作目录"><a href="#5-当前工作目录" class="headerlink" title="5.当前工作目录"></a>5.当前工作目录</h2><pre><code>pwd</code></pre><h2 id="6-复制文件"><a href="#6-复制文件" class="headerlink" title="6.复制文件"></a>6.复制文件</h2><p><code>cp source dest</code> 复制文件</p><p><code>cp -r sourceFolder targetFolder</code> 递归复制整个文件夹</p><p><code>scp sourecFile romoteUserName@remoteIp:remoteAddr</code> 远程拷贝</p><h2 id="7-创建目录"><a href="#7-创建目录" class="headerlink" title="7.创建目录"></a>7.创建目录</h2><pre><code>mkdir newfolder</code></pre><h2 id="8-删除目录"><a href="#8-删除目录" class="headerlink" title="8.删除目录"></a>8.删除目录</h2><p><code>rmdir deleteEmptyFolder</code> 删除空目录 <code>rm -rf deleteFile</code> 递归删除目录中所有内容</p><h2 id="9-移动文件"><a href="#9-移动文件" class="headerlink" title="9.移动文件"></a>9.移动文件</h2><pre><code>mv /temp/movefile /targetFolder</code></pre><h2 id="10-重命令"><a href="#10-重命令" class="headerlink" title="10.重命令"></a>10.重命令</h2><pre><code>mv oldNameFile newNameFile</code></pre><h2 id="11-切换用户"><a href="#11-切换用户" class="headerlink" title="11.切换用户"></a>11.切换用户</h2><pre><code>su -username</code></pre><h2 id="12-修改文件权限"><a href="#12-修改文件权限" class="headerlink" title="12.修改文件权限"></a>12.修改文件权限</h2><p><code>chmod 777 file.java</code> </p><p>file.java的权限-rwxrwxrwx，r表示读、w表示写、x表示可执行</p><p><code>chmod -R 777 filename</code> 将文件设置为可执行</p><h2 id="13-压缩文件"><a href="#13-压缩文件" class="headerlink" title="13.压缩文件"></a>13.压缩文件</h2><pre><code>tar -czf test.tar.gz /test1 /test2</code></pre><h2 id="14-列出压缩文件列表"><a href="#14-列出压缩文件列表" class="headerlink" title="14.列出压缩文件列表"></a>14.列出压缩文件列表</h2><pre><code>tar -tzf test.tar.gz</code></pre><h2 id="15-解压文件"><a href="#15-解压文件" class="headerlink" title="15.解压文件"></a>15.解压文件</h2><pre><code>tar -xvzf test.tar.gz</code></pre><h2 id="16-查看文件头10行"><a href="#16-查看文件头10行" class="headerlink" title="16.查看文件头10行"></a>16.查看文件头10行</h2><pre><code>head -n 10 example.txt</code></pre><h2 id="17-查看文件尾10行"><a href="#17-查看文件尾10行" class="headerlink" title="17.查看文件尾10行"></a>17.查看文件尾10行</h2><pre><code>tail -n 10 example.txt</code></pre><h2 id="18-查看日志类型文件"><a href="#18-查看日志类型文件" class="headerlink" title="18.查看日志类型文件"></a>18.查看日志类型文件</h2><p><code>tail -f exmaple.log</code> //这个命令会自动显示新增内容，屏幕只显示10行内容的（可设置）。</p><h2 id="19-使用超级管理员身份执行命令"><a href="#19-使用超级管理员身份执行命令" class="headerlink" title="19.使用超级管理员身份执行命令"></a>19.使用超级管理员身份执行命令</h2><p><code>sudo rm a.txt</code> 使用管理员身份删除文件</p><h2 id="20-查看端口占用情况"><a href="#20-查看端口占用情况" class="headerlink" title="20.查看端口占用情况"></a>20.查看端口占用情况</h2><p><code>netstat -tln | grep 8080</code> 查看端口8080的使用情况</p><h2 id="21-查看端口属于哪个程序"><a href="#21-查看端口属于哪个程序" class="headerlink" title="21.查看端口属于哪个程序"></a>21.查看端口属于哪个程序</h2><pre><code>lsof -i :8080</code></pre><h2 id="22-查看进程"><a href="#22-查看进程" class="headerlink" title="22.查看进程"></a>22.查看进程</h2><p><code>ps aux|grep java</code> 查看java进程</p><p><code>ps aux</code> 查看所有进程</p><h2 id="23-以树状图列出目录的内容"><a href="#23-以树状图列出目录的内容" class="headerlink" title="23.以树状图列出目录的内容"></a>23.以树状图列出目录的内容</h2><pre><code>tree a</code></pre><p>ps:<a href="http://www.hollischuang.com/archives/546" target="_blank" rel="noopener">Mac下使用tree命令</a></p><h2 id="24-文件下载"><a href="#24-文件下载" class="headerlink" title="24. 文件下载"></a>24. 文件下载</h2><p><code>wget http://file.tgz</code> <a href="http://www.hollischuang.com/archives/548" target="_blank" rel="noopener">mac下安装wget命令</a></p><pre><code>curl http://file.tgz</code></pre><h2 id="25-网络检测"><a href="#25-网络检测" class="headerlink" title="25. 网络检测"></a>25. 网络检测</h2><pre><code>ping www.just-ping.com</code></pre><h2 id="26-远程登录"><a href="#26-远程登录" class="headerlink" title="26.远程登录"></a>26.远程登录</h2><pre><code>ssh userName@ip</code></pre><h2 id="27-打印信息"><a href="#27-打印信息" class="headerlink" title="27.打印信息"></a>27.打印信息</h2><p><code>echo $JAVA_HOME</code> 打印java home环境变量的值</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux平时积累</title>
      <link href="/2019/06/28/linux/linux-ping-shi-ji-lei/"/>
      <url>/2019/06/28/linux/linux-ping-shi-ji-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h1><p>Linux也提供了<code>ssh</code>客户端工具，以<code>ssh</code>命令的形式存在，最常使用的格式是：<code>ssh [&lt;user&gt;@]&lt;hostname&gt;</code>，但是这种登录方式每次都需要输入密码，而<code>ssh</code>还提供了另一种免密登录方式，其原理如下：</p><p><img src="https://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-08/ef7b8c9afdf54f17b07842ce260dfdb2-1559784259318.png" alt="ssh免密登陆原理"></p><p><code>machine1</code>要想免密登录<code>machine2</code>首先要通过<code>ssh-keygen</code>通过<code>rsa</code>算法生成一对非对称加密的秘钥对（将保存在<code>/root/.ssh</code>中）:</p><pre><code class="bash">hpms@hpms-1:~$ ssh-keygenGenerating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa):Enter passphrase (empty for no passphrase):#(回车)Enter same passphrase again:#(回车)Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:34:c3:41:d2:1f:3d:67:75:63:72:40:d2:25:ff:80:90 root@xxhThe key&#39;s randomart image is:+--[ RSA 2048]----+|      .oo .+o=o*o||       o..E.+oO o||        =. ..+.. ||       . o.    ..||        S       .||                 ||                 ||                 ||                 |+-----------------+</code></pre><p><strong>这个passphrase设置为空,这是ssh免密码登陆的必须条件</strong></p><p>生成后</p><pre><code class="bash">hpms@hpms-1:~$ ll .ssh/总用量 24-rw-------  1 root root 1675  7月  8 22:32 id_rsa-rw-r--r--  1 root root  390  7月  8 22:32 id_rsa.pub</code></pre><p>其中<code>id_rsa.pub</code>称为公钥，<code>id_rsa</code>称为私钥，公钥用来加密，私钥用来解密。公钥用来复制到要登录的目标主机的受信任列表<code>authorized_keys</code>中，可以借助<code>ssh-copy-id [&lt;user&gt;@]&lt;hostname&gt;</code>来完成：</p><pre><code class="bash">hpms@hpms-1:~$ ssh-copy-id hpms@202.117.35.220</code></pre><p>查看<code>202.117.35.220</code>的受信任列表：</p><pre><code class="bash">hpms@hpms-2:~$ cat .ssh/authorized_keysssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDprJNzEdgG0ED1WmfyuRlShc2V++eHRBAY3lZOjLswlYNmdnzlm4m42da8Ao/XhtKv4+bsjWJaKMh6+ca0TNwc9phZvI04qwB0xx/cGdMc82kv83p5R8HScgnlrg3v4V9Vwq5r5utUwpCKdUb5FsDLdr6fSBoM+rb/bIceY7neoVW9B+ZAgzZjdR08d1ASblFjCSGy77qmXO2UmTtLEhtgQTZi1yLv2WwMsWq9gMUM9tRNoEnhz5GF0a+XHo9X8g4VjZmzKW6wAC4xUS9Z9iq0QEn7UEOzLmE26lKCds4fvfKVmerIwpvsIPqIcsOfZ8YvvcdnQgp8mcog7GTqeRfJ hpms@hpms-1</code></pre><p>其中的表项就是由<code>id_rsa.pub</code>中的内容和远程登录信息<code>hpms@hpms-1</code>组成。以后当<code>hpms-1</code>机器上的<code>root</code>用户远程登录到<code>hpms-2(202.117.35.220)</code>时，<code>220</code>发现在自己的受信任列表中包含了<code>hpms@hpms-1</code>于是会用这个表项对应的公钥加密一个随机字符串发送到企图连接到<code>220</code>的机器上，如果该机器真的是<code>hpms-1</code>而不是伪装的，那么它就能用自己的私钥将密文解密并返给<code>220</code>，<code>220</code>发现解密后的正确才会让其登录。因为每个主机的私钥唯一，因此只要自己不泄露，其他主机就无法伪装成<code>hpms-1</code>登录<code>220</code>。</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人博客</title>
      <link href="/2019/06/28/blog/da-jian-ge-ren-bo-ke/"/>
      <url>/2019/06/28/blog/da-jian-ge-ren-bo-ke/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h1><a id="more"></a><p>在root下安装</p><pre><code class="bash">sudo su</code></pre><ol><li>安装nodejs</li></ol><pre><code class="bash">brew install nodejs</code></pre><ol start="2"><li>更改镜像元</li></ol><pre><code class="bash">npm install -g cnpm --registery=https://registry.npm.taobao.org</code></pre><ol start="3"><li>安装haxo博客</li></ol><pre><code class="bash">cnpm install -g hexo-cli</code></pre><ol start="4"><li>初始化博客</li></ol><p>在根目录创建文件夹</p><pre><code class="bash">sh-3.2# pwd/Users/xuxinghuash-3.2# mkdir blogsh-3.2# cd blog/sh-3.2# lssh-3.2# pwd/Users/xuxinghua/blog</code></pre><p>用管理员的命令来执行</p><pre><code class="bash">sh-3.2# sudo hexo initINFO  Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitCloning into &#39;/Users/xuxinghua/blog&#39;...remote: Enumerating objects: 9, done.remote: Counting objects: 100% (9/9), done.remote: Compressing objects: 100% (7/7), done.remote: Total 77 (delta 4), reused 5 (delta 2), pack-reused 68Unpacking objects: 100% (77/77), done.Submodule &#39;themes/landscape&#39; (https://github.com/hexojs/hexo-theme-landscape.git) registered for path &#39;themes/landscape&#39;Cloning into &#39;/Users/xuxinghua/blog/themes/landscape&#39;...remote: Enumerating objects: 33, done.remote: Counting objects: 100% (33/33), done.remote: Compressing objects: 100% (29/29), done.remote: Total 929 (delta 12), reused 12 (delta 3), pack-reused 896Receiving objects: 100% (929/929), 2.56 MiB | 181.00 KiB/s, done.Resolving deltas: 100% (492/492), done.Submodule path &#39;themes/landscape&#39;: checked out &#39;73a23c51f8487cfcd7c6deec96ccc7543960d350&#39;INFO  Install dependenciesnpm WARN deprecated core-js@1.2.7: core-js@&lt;2.6.8 is no longer maintained. Please, upgrade to core-js@3 or at least to actual version of core-js@2.&gt; fsevents@1.2.9 install /Users/xuxinghua/blog/node_modules/fsevents&gt; node installnode-pre-gyp WARN Using needle for node-pre-gyp https download[fsevents] Success: &quot;/Users/xuxinghua/blog/node_modules/fsevents/lib/binding/Release/node-v64-darwin-x64/fse.node&quot; is installed via remotenpm notice created a lockfile as package-lock.json. You should commit this file.added 408 packages from 520 contributors and audited 6879 packages in 22.577sfound 0 vulnerabilitiesINFO  Start blogging with Hexo!</code></pre><p>可以看下在blog文件夹下生成了哪些文件</p><pre><code class="bash">sh-3.2# ls -ltotal 120-rw-r--r--   1 root staff   1765 Jun 28 19:14 _config.ymldrwxr-xr-x 274 root staff   8768 Jun 28 19:14 node_modules-rw-r--r--   1 root staff 110677 Jun 28 19:14 package-lock.json-rw-r--r--   1 root staff    443 Jun 28 19:14 package.jsondrwxr-xr-x   5 root staff    160 Jun 28 19:14 scaffoldsdrwxr-xr-x   3 root staff     96 Jun 28 19:14 sourcedrwxr-xr-x   3 root staff     96 Jun 28 19:14 themes</code></pre><ol start="5"><li>启动博客</li></ol><pre><code class="bash">sh-3.2# hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre><ol start="6"><li>写博客</li></ol><p>比如博客名叫做：我的第一篇博客文章</p><pre><code class="bash">sh-3.2# hexo n &quot;我的第一篇博客文章&quot;</code></pre><h1 id="博客部署到github上公开使用"><a href="#博客部署到github上公开使用" class="headerlink" title="博客部署到github上公开使用"></a>博客部署到github上公开使用</h1><ol><li>新建仓库</li></ol><p>Reposity name：<code>Xumingmingming.github.io</code></p><p>必须是你的github的昵称</p><p>![屏幕快照 2019-06-28 下午10.29.43](assets/屏幕快照 2019-06-28 下午10.29.43.png)</p><ol start="2"><li><p>安装git的部署插件</p><pre><code class="bash">sh-3.2# cnpm install --save hexo-deployer-git</code></pre><p>peerDependencies WARNING 不用管</p></li><li><p>修改_config.yml</p><p>在最后：</p><pre><code class="yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: https://github.com/Xumingmingming/xuxinghua.github.io.git  branch: master</code></pre></li><li><p>部署到远端</p><pre><code class="bash">sh-3.2# hexo d</code></pre></li></ol><h1 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h1><p>换的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">这个主题</a></p><ul><li><p>下载主题：</p><p>当前目录在blog目录，clone到<code>blog/themes</code>下的<code>yilia</code>文件夹下</p><pre><code class="bash">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</code></pre></li><li><p>配置主题</p><p>修改_config.yml</p><pre><code class="yml"># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape</code></pre><p>改成：</p><pre><code class="yml"># Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: yilia</code></pre></li><li><p>重启</p><p>Clean—&gt;g(重新生成)—&gt;s(start)</p><pre><code class="bash">sh-3.2# hexo cleanINFO  Deleted database.INFO  Deleted public folder.sh-3.2# hexo gINFO  Start processingINFO  Files loaded in 403 msINFO  Generated: index.htmlINFO  Generated: archives/index.htmlINFO  Generated: fonts/default-skin.b257fa.svgINFO  Generated: img/preloader.gifINFO  Generated: fonts/iconfont.16acc2.ttfINFO  Generated: fonts/iconfont.45d7ee.svgINFO  Generated: img/scrollbar_arrow.pngINFO  Generated: fonts/iconfont.b322fa.eotINFO  Generated: fonts/iconfont.8c627f.woffINFO  Generated: fonts/tooltip.4004ff.svgINFO  Generated: archives/2019/06/index.htmlINFO  Generated: img/default-skin.pngINFO  Generated: archives/2019/index.htmlINFO  Generated: 2019/06/28/我的第一篇博客文章/index.htmlINFO  Generated: 2019/06/28/hello-world/index.htmlINFO  Generated: slider.e37972.jsINFO  Generated: main.0cf68a.cssINFO  Generated: main.0cf68a.jsINFO  Generated: mobile.992cbe.jsINFO  19 files generated in 241 mssh-3.2# hexo sINFO  Start processingINFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</code></pre></li><li><p>重新部署到远端</p><p>注意修改完后，需要重新在git上部署</p><pre><code class="bash">sh-3.2# hexo d</code></pre></li></ul><h1 id="走过的坑"><a href="#走过的坑" class="headerlink" title="走过的坑"></a>走过的坑</h1><h2 id="访问网站时，网站加载速度慢"><a href="#访问网站时，网站加载速度慢" class="headerlink" title="访问网站时，网站加载速度慢"></a>访问网站时，网站加载速度慢</h2><p>打开Chrome的开发者工具，有2个URL超时，大概1.2min，拖慢速度的就是这两条！！</p><ol><li><p>Request URL: <a href="https://fonts.googleapis.com/css?family=Source+Code+Pro" target="_blank" rel="noopener">https://fonts.googleapis.com/css?family=Source+Code+Pro</a></p></li><li><p>Request URL: <a href="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js" target="_blank" rel="noopener">http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js</a></p></li></ol><p>措施：</p><ul><li>定位<code>fonts.googleapis.com/css?family=Source+Code+Pro</code>到<code>blog/themes/landscape/layout/_partial/head.ejs</code></li></ul><pre><code class="bash">sudo vi /Users/xuxinghua/blog/themes/landscape/layout/_partial/head.ejs</code></pre><p>将下面注释掉：</p><pre><code class="html">&lt;link href=&quot;//fonts.googleapis.com/css?family=Source+Code+Pro&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</code></pre><ul><li><p>定位<code>ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js</code>到<code>blog/themes/landscape/layout/_partial/after-footer.ejs</code></p><pre><code class="bash">sudo vi /Users/xuxinghua/blog/themes/landscape/layout/_partial/after-footer.ejs</code></pre><p>将</p><pre><code class="html">&lt;script src=&quot;//lib.sinaapp.com/js/jquery/2.0.3/jquery-2.0.3.min.js&quot;&gt;&lt;/script&gt;</code></pre></li></ul><p>​       改为</p><pre><code class="html">&lt;script src=&quot;//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;</code></pre><p>成功！</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux上安装RabbitMQ</title>
      <link href="/2019/06/28/linux/linux-shang-an-zhuang-rabbitmq/"/>
      <url>/2019/06/28/linux/linux-shang-an-zhuang-rabbitmq/</url>
      
        <content type="html"><![CDATA[<p>安装RabbitMQ也非常简单，无需自己安装erlang，直接 <code>apt-get install</code>  即可</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="bash">sudo apt-get install rabbitmq-server</code></pre><h1 id="启动RabbitMQ管理插件，用于web界面管理"><a href="#启动RabbitMQ管理插件，用于web界面管理" class="headerlink" title="启动RabbitMQ管理插件，用于web界面管理"></a>启动RabbitMQ管理插件，用于web界面管理</h1><pre><code class="bash">sudo rabbitmq-plugins enable rabbitmq_managementsudo service rabbitmq-server restart</code></pre><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><pre><code class="bash">service rabbitmq-server stop 会将节点及应用程序同时关闭。</code></pre><h1 id="测试安装完成的RabbitMQ"><a href="#测试安装完成的RabbitMQ" class="headerlink" title="测试安装完成的RabbitMQ"></a>测试安装完成的RabbitMQ</h1><pre><code class="bash">sudo rabbitmqctl status</code></pre><p>安装完成后，登录 主机名+端口号登录RabbitMQ页面，比如 202.117.35.221:15672 ，账号和密码默认都是:guest</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux上安装rocketmq</title>
      <link href="/2019/06/28/linux/linux-shang-an-zhuang-rocketmq/"/>
      <url>/2019/06/28/linux/linux-shang-an-zhuang-rocketmq/</url>
      
        <content type="html"><![CDATA[<ul><li><p>在官网下载rocketmq的zip包</p></li><li><p>在rocketmq目录下，将<code>rocketmq-all-4.3.2-bin-release.zip</code>变成可以执行的文件</p><pre><code class="bash">hpms@hpms-1:~/xxh009/soft$ chmod -R 777 *</code></pre></li><li><p>unzip 命令解压缩</p><pre><code class="bash">hpms@hpms-1:~/xxh009/soft$ unzip rocketmq-all-4.3.2-bin-release.zip</code></pre></li><li><p>进入rockmq</p><pre><code class="bash">hpms@hpms-1:~/xxh009/soft$ cd rocketmq-all-4.3.2-bin-release/hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release$ cd bin/hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release/bin$ lscachedog.sh       mqadmin.xml         mqbroker.numanode2  mqnamesrv.xml   play.cmd       runserver.cmd  tools.shcleancache.sh     mqbroker            mqbroker.numanode3  mqshutdown      play.sh        runserver.shcleancache.v1.sh  mqbroker.cmd        mqbroker.xml        mqshutdown.cmd  README.md      setcache.shmqadmin           mqbroker.numanode0  mqnamesrv           nohup.out       runbroker.cmd  startfsrv.shmqadmin.cmd       mqbroker.numanode1  mqnamesrv.cmd       os.sh           runbroker.sh   tools.cmd</code></pre></li></ul><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>运行前修改rocketmq默认配置</p><h3 id="1-修改mqbroker-xml"><a href="#1-修改mqbroker-xml" class="headerlink" title="1 修改mqbroker.xml"></a>1 修改mqbroker.xml</h3><pre><code class="bahs">hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release/bin$ vi mqbroker.xml</code></pre><pre><code class="xml"> &lt;options&gt;        &lt;-Xms512m&gt;    &lt;/-Xms512m&gt;    &lt;-Xmx1g&gt;&lt;/-Xmx1g&gt;&lt;-XX:NewSize&gt;256M&lt;/-XX:NewSize&gt;&lt;-XX:MaxNewSize&gt;512M&lt;/-XX:MaxNewSize&gt;&lt;-XX:PermSize&gt;128M&lt;/-XX:PermSize&gt;&lt;-XX:MaxPermSize&gt;128M&lt;/-XX:MaxPermSize&gt;    &lt;/options&gt;</code></pre><p>改为</p><pre><code class="xml"> &lt;options&gt;        &lt;-Xms512m&gt;    &lt;/-Xms512m&gt;    &lt;-Xmx1g&gt;&lt;/-Xmx1g&gt;&lt;-XX:NewSize&gt;256M&lt;/-XX:NewSize&gt;&lt;-XX:MaxNewSize&gt;512M&lt;/-XX:MaxNewSize&gt;&lt;-XX:PermSize&gt;128M&lt;/-XX:PermSize&gt;&lt;-XX:MaxPermSize&gt;128M&lt;/-XX:MaxPermSize&gt;    &lt;/options&gt;</code></pre><h3 id="2-修改-runbroker-sh"><a href="#2-修改-runbroker-sh" class="headerlink" title="2 修改 runbroker.sh"></a>2 修改 runbroker.sh</h3><pre><code class="bash">hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release/bin$ vim runbroker.sh</code></pre><p>将</p><pre><code class="sh">#===========================================================================================# JVM Configuration#===========================================================================================JAVA_OPT=&quot;${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g&quot;</code></pre><p>改为</p><pre><code class="sh">JAVA_OPT=&quot;${JAVA_OPT} -server -Xms512m -Xmx512m -Xmn512m&quot;</code></pre><h2 id="Start-Name-Server"><a href="#Start-Name-Server" class="headerlink" title="Start Name Server"></a>Start Name Server</h2><p>rocketmq目录下：</p><pre><code class="bash">nohup sh bin/mqnamesrv &amp;</code></pre><p>mqnamesrv进程默认是在9876端口</p><pre><code class="bash">hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release$ netstat -anp|grep 9876tcp6       0      0 :::9876                 :::*                    LISTEN      11491/java</code></pre><p>还可以<code>tail -f ~/logs/rocketmqlogs/namesrv.log</code>查看日志</p><pre><code class="bash">hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release$ tail -f ~/logs/rocketmqlogs/namesrv.log2019-07-03 09:38:52 INFO main - tls.client.certPath = null2019-07-03 09:38:52 INFO main - tls.client.authServer = false2019-07-03 09:38:52 INFO main - tls.client.trustCertPath = null2019-07-03 09:38:53 INFO main - Using OpenSSL provider2019-07-03 09:38:53 INFO main - SSLContext created for server2019-07-03 09:38:53 INFO NettyEventExecutor - NettyEventExecutor service started2019-07-03 09:38:53 INFO FileWatchService - FileWatchService service started2019-07-03 09:38:53 INFO main - The Name Server boot success. serializeType=JSON2019-07-03 09:39:53 INFO NSScheduledThread1 - --------------------------------------------------------2019-07-03 09:39:53 INFO NSScheduledThread1 - configTable SIZE: 0</code></pre><h2 id="Start-Broker"><a href="#Start-Broker" class="headerlink" title="Start Broker"></a>Start Broker</h2><pre><code class="bash">hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release$ nohup sh bin/mqbroker -n localhost:9876 &amp;</code></pre><p>查看日志</p><pre><code class="bash">tail -f ~/logs/rocketmqlogs/broker.log </code></pre><p>broker.log ：</p><pre><code class="bash">hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release$ tail -f ~/logs/rocketmqlogs/broker.log2019-07-03 09:46:08 INFO main - The broker[hpms-1, 202.117.35.221:10911] boot success. serializeType=JSON and name server is localhost:98762019-07-03 09:46:18 INFO BrokerControllerScheduledThread1 - dispatch behind commit log 0 bytes2019-07-03 09:46:18 INFO BrokerControllerScheduledThread1 - Slave fall behind master: 0 bytes2019-07-03 09:46:18 INFO brokerOutApi_thread_2 - register broker to name server localhost:9876 OK2019-07-03 09:46:48 INFO brokerOutApi_thread_3 - register broker to name server localhost:9876 OK2019-07-03 09:47:08 INFO TransactionalMessageCheckService - create new topic TopicConfig [topicName=RMQ_SYS_TRANS_HALF_TOPIC, readQueueNums=1, writeQueueNums=1, perm=RW-, topicFilterType=SINGLE_TAG, topicSysFlag=0, order=false]2019-07-03 09:47:08 INFO brokerOutApi_thread_4 - register broker to name server localhost:9876 OK2019-07-03 09:47:18 INFO BrokerControllerScheduledThread1 - dispatch behind commit log 0 bytes2019-07-03 09:47:18 INFO BrokerControllerScheduledThread1 - Slave fall behind master: 0 bytes2019-07-03 09:47:18 INFO brokerOutApi_thread_1 - register broker to name server localhost:9876 OK2019-07-03 09:47:48 INFO brokerOutApi_thread_2 - register broker to name server localhost:9876 OK2019-07-03 09:48:18 INFO BrokerControllerScheduledThread1 - dispatch behind commit log 0 bytes2019-07-03 09:48:18 INFO BrokerControllerScheduledThread1 - Slave fall behind master: 0 bytes2019-07-03 09:48:18 INFO brokerOutApi_thread_3 - register broker to name server localhost:9876 OK</code></pre><h2 id="Send-amp-Receive-Messages"><a href="#Send-amp-Receive-Messages" class="headerlink" title="Send &amp; Receive Messages"></a>Send &amp; Receive Messages</h2><p>Before sending/receiving messages, we need to tell clients the location of name servers. RocketMQ provides multiple ways to achieve this. For simplicity, we use environment variable <code>NAMESRV_ADDR</code></p><pre><code class="bash"> &gt; export NAMESRV_ADDR=localhost:9876 //投放消息 &gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.ProducerSendResult [sendStatus=SEND_OK, msgId= ...//消费消息 &gt; sh bin/tools.sh org.apache.rocketmq.example.quickstart.Consumer ConsumeMessageThread_%d Receive New Messages: [MessageExt...</code></pre><h2 id="Shutdown-Servers"><a href="#Shutdown-Servers" class="headerlink" title="Shutdown Servers"></a>Shutdown Servers</h2><pre><code class="bash">&gt; sh bin/mqshutdown brokerThe mqbroker(36695) is running...Send shutdown request to mqbroker(36695) OK&gt; sh bin/mqshutdown namesrvThe mqnamesrv(36664) is running...Send shutdown request to mqnamesrv(36664) OK</code></pre><h2 id="topic创建"><a href="#topic创建" class="headerlink" title="topic创建"></a>topic创建</h2><p>使用<code>/bin/mqadmin updateTopic</code> 命令创建topic</p><pre><code class="bash">hpms@hpms-1:~/xxh009/soft/rocketmq-all-4.3.2-bin-release/bin$ sudo suroot@hpms-1:/home/hpms/xxh009/soft/rocketmq-all-4.3.2-bin-release/bin# ./mqadmin updateTopic -n localhost:9876 -t stock -c DefaultClusterERROR: Please set the JAVA_HOME variable in your environment, We need java(x64)! !!</code></pre><p>但是正如命令行显示，出现了错误，在后面坑中有解决方法。</p><p>解决完后，我们继续创建topic：</p><pre><code class="bash">soft/rocketmq-all-4.3.2-bin-release/bin# ./mqadmin updateTopic -n localhost:9876 -t stock -c DefaultClusterJava HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m; support was removed in 8.0Java HotSpot(TM) 64-Bit Server VM warning: ignoring option MaxPermSize=128m; support was removed in 8.0create topic to 202.117.35.221:10911 success.TopicConfig [topicName=stock, readQueueNums=8, writeQueueNums=8, perm=RW-, topicFilterType=SINGLE_TAG, topicSysFlag=0, order=false]</code></pre><h1 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h1><h2 id="在ubuntu运行-sudo-java，但结果提示-sudo：java：command-not-found，为什么呢？我的java环境变量也配置了"><a href="#在ubuntu运行-sudo-java，但结果提示-sudo：java：command-not-found，为什么呢？我的java环境变量也配置了" class="headerlink" title="在ubuntu运行 sudo java，但结果提示 sudo：java：command not found，为什么呢？我的java环境变量也配置了"></a>在ubuntu运行 sudo java，但结果提示 sudo：java：command not found，为什么呢？我的java环境变量也配置了</h2><p>在Ubuntu环境中安装好Java环境后设置环境变量：在/etc/profile中设置好了JAVA_HOME变量并引入到PATH中，</p><p><code>vim /etc/profile</code>:</p><pre><code class="bash">export JAVA_HOME=/usr/local/jdk1.8.0_111export CLASSPATH=.:$JAVA_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$PATH</code></pre><p>sudo是切换用户存取权限，但是没有获得环境变量，所以PATH没有被带入</p><p>注：</p><p><code>/etc/environmen</code>t是设置<strong>整个系统的环境</strong>，而<code>/etc/profile</code>是设置所有<strong>用户的环境</strong>，前者与登陆用户无关，后者与登陆用户有关。<strong>系统应用程序的执行与用户环境可以是无关的，但与系统环境时相关的</strong>，所以当你登陆时，你看到的提示信息，如日期、时间信息的显示格式与系统环境的LANG是相关的，缺省LANG=en_US，如果系统环境LANG-zh_CN，则提示信息是中文的，否则是英文的。</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>设置整个系统的环境变量</p><pre><code class="bash">sudo vim /etc/environment//修改为PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin&quot;export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport JAVA_HOME=/usr/local/jdk1.8.0_111</code></pre><p>我的jdk是在<code>/usr/local/jdk1.8.0_111</code>目录下</p><p>使环境变量立刻生效</p><pre><code class="bash">source /etc/environment</code></pre><p> 解决</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> rocketmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux上安装Redis</title>
      <link href="/2019/06/28/linux/linux-shang-an-zhuang-redis/"/>
      <url>/2019/06/28/linux/linux-shang-an-zhuang-redis/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code class="bash">sudo apt-get install redis-server</code></pre><p>安装完成后，Redis服务器会自动启动，我们检查Redis服务器程序。</p><p>在终端中检查Redis服务器系统进程</p><pre><code class="bash">ps -aux|grep redis</code></pre><p>在终端中通过启动命令检查Redis服务器状态</p><pre><code class="bash">netstat -nlt|grep 6379</code></pre><p>通过启动命令检查Redis服务器状态</p><pre><code class="bash">sudo /etc/init.d/redis-server status</code></pre><p>显示: redis-server is running</p><h1 id="修改Redis的配置"><a href="#修改Redis的配置" class="headerlink" title="修改Redis的配置"></a>修改Redis的配置</h1><p><strong>修改redis.conf</strong></p><pre><code class="bash">sudo vi /etc/redis/redis.conf</code></pre><p>修改为：</p><pre><code>daemonize yesbind 0.0.0.0 //代表都能访问</code></pre><p>默认是</p><pre><code>bind 127.0.0.1</code></pre><p>代表只能本机访问</p><h1 id="远程登录redis服务器"><a href="#远程登录redis服务器" class="headerlink" title="远程登录redis服务器"></a>远程登录redis服务器</h1><pre><code>redis-cli -a redis -h ip地址(如202.117.35.220)</code></pre><h1 id="Redis服务"><a href="#Redis服务" class="headerlink" title="Redis服务"></a>Redis服务</h1><h2 id="重启Redis"><a href="#重启Redis" class="headerlink" title="重启Redis"></a>重启Redis</h2><p>1：</p><pre><code class="bash">sudo /etc/init.d/redis-server restart</code></pre><p>2：</p><pre><code class="bash">sudo service redis-server restart</code></pre>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客添加hexo-theme-matery主题</title>
      <link href="/2019/06/28/blog/hexo-theme-matery/"/>
      <url>/2019/06/28/blog/hexo-theme-matery/</url>
      
        <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>简单漂亮，文章内容美观易读</li><li>Material Design 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 Banner 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li>词云的标签页和雷达图的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 MathJax</li><li>TOC 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li>Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk）</li><li>集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li></ul><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master" target="_blank" rel="noopener">下载</a> master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。<br>当然你也可以在你的 themes 文件夹下使用 Git clone 命令来下载:</p><pre><code class="bash">git clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h2><p>修改 <code>Hexo</code> 根目录下的 <code>_config.yml</code> 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code><br><code>_config.yml</code> 文件的其它修改建议:</p><ul><li>请修改 _config.yml 的 url 的值为你的网站主 URL（如：<a href="http://xxx.github.io）。" target="_blank" rel="noopener">http://xxx.github.io）。</a></li><li>建议修改两个 per_page 的分页条数值为 6 的倍数，如：12、18 等，这样文章列表在各个屏幕下都能较好的显示。</li><li>如果你是中文用户，则建议修改 language 的值为 zh-CN。</li></ul><h2 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h2><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;categories&quot;</code></pre><p>编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容：</p><pre><code class="yml">---title: categoriesdate: 2018-09-30 17:25:30type: &quot;categories&quot;layout: &quot;categories&quot;---</code></pre><h2 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h2><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;tags&quot;</code></pre><h2 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h2><p><code>about</code> 页是用来展示关于我和我的博客信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;about&quot;</code></pre><p>编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容：</p><pre><code class="yml">---title: aboutdate: 2018-09-30 17:25:30type: &quot;about&quot;layout: &quot;about&quot;---</code></pre><h2 id="新建友情连接-friends-页（可选的）"><a href="#新建友情连接-friends-页（可选的）" class="headerlink" title="新建友情连接 friends 页（可选的）"></a>新建友情连接 friends 页（可选的）</h2><p><code>friends</code> 页是用来展示友情连接信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p><pre><code class="bash">hexo new page &quot;friends&quot;</code></pre><p>编辑你刚刚新建的页面文件 /source/friends/index.md，至少需要以下内容：</p><pre><code class="yml">---title: friendsdate: 2018-12-12 21:25:30type: &quot;friends&quot;layout: &quot;friends&quot;---</code></pre><p>同时，在你的博客 source 目录下新建 _data 目录，在 _data 目录中新建 friends.json 文件，文件内容如下所示：</p><pre><code class="json">[{    &quot;avatar&quot;: &quot;http://image.luokangyuan.com/1_qq_27922023.jpg&quot;,    &quot;name&quot;: &quot;码酱&quot;,    &quot;introduction&quot;: &quot;我不是大佬，只是在追寻大佬的脚步&quot;,    &quot;url&quot;: &quot;http://luokangyuan.com/&quot;,    &quot;title&quot;: &quot;前去学习&quot;}, {    &quot;avatar&quot;: &quot;http://image.luokangyuan.com/4027734.jpeg&quot;,    &quot;name&quot;: &quot;闪烁之狐&quot;,    &quot;introduction&quot;: &quot;编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬&quot;,    &quot;url&quot;: &quot;https://blinkfox.github.io/&quot;,    &quot;title&quot;: &quot;前去学习&quot;}, {    &quot;avatar&quot;: &quot;http://image.luokangyuan.com/avatar.jpg&quot;,    &quot;name&quot;: &quot;ja_rome&quot;,    &quot;introduction&quot;: &quot;平凡的脚步也可以走出伟大的行程&quot;,    &quot;url&quot;: &quot;ttps://me.csdn.net/jlh912008548&quot;,    &quot;title&quot;: &quot;前去学习&quot;}]</code></pre><h2 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h2><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre><code class="bash">npm i -S hexo-prism-plugin</code></pre><p>然后，修改 <code>Hexo</code> 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p><pre><code class="yml">highlight:  enable: falseprism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;  line_number: false    # default false  custom_css:</code></pre><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 的 <code>Hexo</code> 插件来做内容搜索，安装命令如下：</p><pre><code class="bash">npm install hexo-generator-search --save</code></pre><p>在 Hexo 根目录下的 _config.yml 文件中，新增以下的配置项：</p><pre><code class="yml">search:  path: search.xml  field: post</code></pre><h2 id="中文链接转拼音（可选的）"><a href="#中文链接转拼音（可选的）" class="headerlink" title="中文链接转拼音（可选的）"></a>中文链接转拼音（可选的）</h2><p>如果你的文章名称是中文的，那么 <code>Hexo</code> 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre><code class="bash">npm i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="yml">permalink_pinyin:  enable: true  separator: &#39;-&#39; # default: &#39;-&#39;</code></pre><h2 id="文章字数统计插件（可选的）"><a href="#文章字数统计插件（可选的）" class="headerlink" title="文章字数统计插件（可选的）"></a>文章字数统计插件（可选的）</h2><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a>插件。<br>安装命令如下：</p><pre><code class="bash">npm i --save hexo-wordcount</code></pre><p>然后只需在本主题下的 <code>_config.yml</code> 文件中，激活以下配置项即可：</p><pre><code class="yml">wordCount:  enable: false # 将这个值设置为 true 即可.  postWordCount: true  min2read: true  totalCount: true</code></pre><h2 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h2><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 的 Hexo 插件来做 RSS，安装命令如下：</p><pre><code class="bash">npm install hexo-generator-feed --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre><code class="yml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: &#39; &#39;  order_by: -date</code></pre><p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p><h2 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h2><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 /layout/_partial/footer.ejs 文件中，包括站点、使用的主题、访问量等。</p><h2 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h2><p>在主题文件的 source/medias/reward 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h1 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h1><p><code>Front-matter</code> 选项中的所有内容均为非必填的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th align="center">配置选项</th><th align="left">默认值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">title</td><td align="left"><code>Markdown</code> 的文件标题</td><td align="left">文章标题，强烈建议填写此选项</td></tr><tr><td align="center">date</td><td align="left">文件创建时的日期时间</td><td align="left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td align="center">author</td><td align="left">根 <code>_config.yml</code>中的 <code>author</code></td><td align="left">文章作者</td></tr><tr><td align="center">img</td><td align="left"><code>featureImages</code>中的某个值</td><td align="left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td align="center">top</td><td align="left"><code>true</code></td><td align="left">推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td align="center">cover</td><td align="left"><code>false</code></td><td align="left"><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td align="center">coverImg</td><td align="left">无</td><td align="left"><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td align="center">password</td><td align="left">无</td><td align="left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td align="center">toc</td><td align="left"><code>true</code></td><td align="left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td align="center">mathjax</td><td align="left"><code>false</code></td><td align="left">是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td align="center">summary</td><td align="left">无</td><td align="left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td align="center">categories</td><td align="left">无</td><td align="left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td align="center">tags</td><td align="left">无</td><td align="left">文章标签，一篇文章可以多个标签</td></tr></tbody></table><blockquote><p>注意:<br>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。<br><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。<br>如果要对文章设置阅读验证密码的功能，不仅要在 <code>Front-matter</code> 中设置采用了 <code>SHA256</code> 加密的 <code>password</code> 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 <code>SHA256</code> 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2" target="_blank" rel="noopener">开源中国在线工具</a>、<a href="http://encode.chahuo.com/" target="_blank" rel="noopener">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx" target="_blank" rel="noopener">站长工具</a>。</p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>特别感谢<a href="https://blinkfox.github.io" target="_blank" rel="noopener">闪烁之狐</a>提供的开源项目</p>]]></content>
      
      
      <categories>
          
          <category> 个人博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
            <tag> hexo-theme-matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第7章 交易优化技术之缓存库存</title>
      <link href="/2019/06/19/miaosha/di-7-zhang-jiao-yi-you-hua-ji-zhu-zhi-huan-cun-ku-cun/"/>
      <url>/2019/06/19/miaosha/di-7-zhang-jiao-yi-you-hua-ji-zhu-zhi-huan-cun-ku-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ul><li>掌握高效交易验证方式</li><li>掌握缓存库存模型(解决库存行锁的性能问题)</li></ul><a id="more"></a><h1 id="交易性能瓶颈"><a href="#交易性能瓶颈" class="headerlink" title="交易性能瓶颈"></a>交易性能瓶颈</h1><h2 id="JMeter压测"><a href="#JMeter压测" class="headerlink" title="JMeter压测"></a>JMeter压测</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150922.png" alt="屏幕快照 2019-07-02 下午7.05.46"></p><h2 id="交易验证完全依赖数据库"><a href="#交易验证完全依赖数据库" class="headerlink" title="交易验证完全依赖数据库"></a>交易验证完全依赖数据库</h2><p>OrderServiceImpl.class:</p><pre><code class="java">    @Override    @Transactional    public OrderModel createOrder(Integer userId, Integer itemId, Integer promoId, Integer amount) throws BusinessException {        //1.校验下单状态,下单的商品是否存在，用户是否合法，购买数量是否正确        ItemModel itemModel = itemService.getItemById(itemId);        if(itemModel == null){            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;商品信息不存在&quot;);        }        //校验用户        UserModel userModel = userService.getUserById(userId);        if(userModel == null){            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;用户信息不存在&quot;);        }        if(amount &lt;= 0 || amount &gt; 99){//不能不买，也不能一次买多个            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;数量信息不正确&quot;);        }        //校验活动信息--&gt;是内存操作        if(promoId != null){            //（1）校验对应活动是否存在这个适用商品            if(promoId.intValue() != itemModel.getPromoModel().getId()){                throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;活动信息不正确&quot;);                //（2）校验活动是否正在进行中            }else if(itemModel.getPromoModel().getStatus().intValue() != 2) {                throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR,&quot;活动信息还未开始&quot;);            }        }        //2.落单减库存        boolean result = itemService.decreaseStock(itemId,amount);        if(!result){            throw new BusinessException(EmBusinessError.STOCK_NOT_ENOUGH);        }        //3.订单入库        OrderModel orderModel = new OrderModel();        orderModel.setUserId(userId);        orderModel.setItemId(itemId);        orderModel.setAmount(amount);        if(promoId != null){            orderModel.setItemPrice(itemModel.getPromoModel().getPromoItemPrice());        }else{            orderModel.setItemPrice(itemModel.getPrice());        }        orderModel.setPromoId(promoId);        orderModel.setOrderPrice(orderModel.getItemPrice().multiply(new BigDecimal(amount)));        //3.1生成交易流水号,订单号        orderModel.setId(generateOrderNo());        OrderDO orderDO = convertFromOrderModel(orderModel);        orderDOMapper.insertSelective(orderDO);        //加上商品的销量        itemService.increaseSales(itemId,amount);        //4.返回前端        return orderModel;    }</code></pre><p>分析：</p><ul><li><p>1.校验下单状态 中的<code>itemService.getItemById(itemId);</code>中，其实操作了3次数据库：</p><ul><li>根据商品id查询<code>item</code>表：<code>itemDOMapper.selectByPrimaryKey(id);</code></li><li>根据商品信息查询库存<code>item_stock</code>表：<code>itemStockDOMapper.selectByItemId(itemDO.getId());</code></li><li>根据商品id查询活动商品信息<code>promo</code>表：<code>promoService.getPromoByItemId(itemModel.getId());</code></li></ul></li><li><p>校验用户</p><ul><li>查询user表：<code>userDOMapper.selectByPrimaryKey(id);</code></li><li>查询use_password表：<code>userPasswordDOMapper.selectByUserId(userDO.getId());</code></li></ul></li><li><p>2.落单减库存 这将会是个热点操作</p><p>最终在<code>item_stock</code>表中完成减库存操作<code>itemStockDOMapper.decreaseStock(itemId,amount);</code></p><p>对应sql语句：有一个<code>item_id = #{itemId}</code>，比如说传入的itemId=6，就会在6这一行加入行锁</p><pre><code class="html">&lt;update id=&quot;decreaseStock&quot;&gt;    update item_stock    set stock = stock - #{amount}    where item_id = #{itemId} and stock &gt;= #{amount}  &lt;/update&gt;</code></pre></li><li><p>3.订单入库</p><ul><li>3.1生成交易流水号 对<code>order_info</code>表：<code>orderDOMapper.insertSelective(orderDO);</code></li><li>加销量，对<code>item</code>表：<code>itemService.increaseSales(itemId,amount);</code></li></ul></li></ul><p>可以看出这里有8次查询数据库的IO操作，而且减库存的操作有一个行锁等待。</p><h2 id="库存行锁"><a href="#库存行锁" class="headerlink" title="库存行锁"></a>库存行锁</h2><p>落单减库存：</p><pre><code class="java">boolean result = itemService.decreaseStock(itemId,amount);</code></pre><p>最终在<code>item_stock</code>表中完成减库存操作<code>itemStockDOMapper.decreaseStock(itemId,amount);</code></p><p>对应sql语句：有一个<code>item_id = #{itemId}</code>，比如说传入的itemId=6，就会在6这一行加入行锁</p><p>ItemStockDOMapper.xml：</p><pre><code class="html">&lt;update id=&quot;decreaseStock&quot;&gt;    update item_stock    set stock = stock - #{amount}    where item_id = #{itemId} and stock &gt;= #{amount}  &lt;/update&gt;</code></pre><p>补充：</p><pre><code class="mysql">update from table set xx=&#39;aa&#39; where yy=&#39;bb&#39;</code></pre><p>这里的yy字段不是主键，但值都是唯一的，这样的话，不加 rowlock时update是锁行还是锁表？</p><blockquote><p>锁表。</p><p>若指定的yy为索引（主键是特殊的索引），只有一条记录，则锁行。<br>若不指定yy为索引，则锁表。</p></blockquote><h2 id="后置处理逻辑"><a href="#后置处理逻辑" class="headerlink" title="后置处理逻辑"></a>后置处理逻辑</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150924.png" alt="未命名文件"></p><h1 id="交易链路优化"><a href="#交易链路优化" class="headerlink" title="交易链路优化"></a>交易链路优化</h1><h2 id="交易验证优化"><a href="#交易验证优化" class="headerlink" title="交易验证优化"></a>交易验证优化</h2><ul><li>用户风控策略优化：策略缓存模型优化</li><li>活动校验策略优化：引入活动发布流程，模型缓存化，紧急下限能力</li></ul><h3 id="UserModel和ItemModel缓存模型"><a href="#UserModel和ItemModel缓存模型" class="headerlink" title="UserModel和ItemModel缓存模型"></a>UserModel和ItemModel缓存模型</h3><ul><li><p>增加<code>UserService.getUserByIdInCache(Integer id);</code>方法</p><p>UserServiceImpl.class：</p><pre><code class="java">@Override    public UserModel getUserByIdInCache(Integer id) {        UserModel userModel= (UserModel) redisTemplate.opsForValue().get(&quot;user_validate_&quot;+id);        if (userModel==null){            userModel=this.getUserById(id);            redisTemplate.opsForValue().set(&quot;user_validate_&quot;+id,userModel);            redisTemplate.expire(&quot;user_validate_&quot;+id,10, TimeUnit.MINUTES);        }        return userModel;    }</code></pre></li></ul><ul><li><p>增加<code>ItemService.getItemByIdInCache(Integer id);</code>方法</p><p>ItemServiceImpl.class:</p><pre><code class="java">@Override    public ItemModel getItemByIdInCache(Integer id) {        ItemModel itemModel= (ItemModel) redisTemplate.opsForValue().get(&quot;item_validate_&quot;+id);        if (itemModel==null){            itemModel=this.getItemById(id);            redisTemplate.opsForValue().set(&quot;item_validate_&quot;+id,itemModel);            redisTemplate.expire(&quot;item_validate_&quot;+id,10, TimeUnit.MINUTES);        }        return itemModel;    }</code></pre></li></ul><h2 id="库存行锁优化"><a href="#库存行锁优化" class="headerlink" title="库存行锁优化"></a>库存行锁优化</h2><p>再回顾下我们的减库存操作：</p><p>ItemStockDOMapper.xml：</p><pre><code class="html">&lt;update id=&quot;decreaseStock&quot;&gt;    update item_stock    set stock = stock - #{amount}    where item_id = #{itemId} and stock &gt;= #{amount}  &lt;/update&gt;</code></pre><p>mysql将会在<code>item_id = #{itemId}</code>的地方加上一个行锁，前提是<code>item_id</code>在数据库里是必须是有索引的。如果没有索引是会锁表的。</p><p>默认<code>item_stock</code>表中的item_id字段是没有索引的，设置索引：</p><pre><code class="mysql">ALTER table item_stock add UNIQUE INDEXitem_id_index(item_id)</code></pre><h3 id="扣减库存缓存化"><a href="#扣减库存缓存化" class="headerlink" title="扣减库存缓存化"></a>扣减库存缓存化</h3><p>在内存中肯定比在磁盘中扣减库存快。</p><p>方案：</p><ul><li>活动发布同步库存进缓存</li><li>下单交易减缓存中库存</li></ul><h4 id="动发布同步库存进缓存"><a href="#动发布同步库存进缓存" class="headerlink" title="动发布同步库存进缓存"></a>动发布同步库存进缓存</h4><p>PromoServiceImpl.class</p><pre><code class="java">@Override    public void publishPromo(Integer promoId) {        //通过活动id获取活动        PromoDO promoDO=promoDOMapper.selectByItemId(promoId);        if (promoDO.getItemId()==null||promoDO.getItemId().intValue()==0){//说明对应的操作不存在，这个活动没有适应的商品            return;        }        ItemModel itemModel=itemService.getItemById(promoDO.getItemId());        //将库存同步到redis内        redisTemplate.opsForValue().set(&quot;promo_item_stock_&quot;+itemModel.getId(),itemModel.getStock());    }</code></pre><p>在ItemController.class中完成发布promo的操作</p><pre><code class="java">@RequestMapping(value = &quot;/publicpromo&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType publicpromo(@RequestParam(name = &quot;id&quot;)Integer id){        promoService.publishPromo(id);        return CommonReturnType.create(null);    }</code></pre><h4 id="下单交易减缓存中库存"><a href="#下单交易减缓存中库存" class="headerlink" title="下单交易减缓存中库存"></a>下单交易减缓存中库存</h4><p>ItemServiceImpl.class中</p><pre><code class="java">    @Override    @Transactional    public boolean decreaseStock(Integer itemId, Integer amount) throws BusinessException {       // int affectedRow =  itemStockDOMapper.decreaseStock(itemId,amount);        Long result=redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue()*-1);        if(result &gt;= 0){            //更新库存成功            return true;        }else{            //更新库存失败            return false;        }    }</code></pre><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li><p>数据库记录不一致</p><p>内存毕竟是不可靠的，如果宕机，库存信息就会全部消失</p></li></ul><h3 id="异步同步数据库"><a href="#异步同步数据库" class="headerlink" title="异步同步数据库"></a>异步同步数据库</h3><p>采用异步消息队列的方式，将对应的异步扣减的消息同步给消息的<code>consumer</code>端，由这个<code>consumer</code>端完成数据库的扣减操作。</p><h4 id="方案-前两种步骤不变"><a href="#方案-前两种步骤不变" class="headerlink" title="方案(前两种步骤不变)"></a>方案(前两种步骤不变)</h4><ul><li>活动发布同步库存进缓存</li><li>下单交易减缓存中库存</li><li>异步消息扣减数据库内库存</li></ul><p>异步扣减数据库：既能保证用户的一个高效的购买体验，又可以保证数据库最终一致性。</p><h4 id="异步消息队列中间件rocketmq"><a href="#异步消息队列中间件rocketmq" class="headerlink" title="异步消息队列中间件rocketmq"></a>异步消息队列中间件rocketmq</h4><ul><li>高性能，高并发，分布式消息中间件</li><li>典型应用场景：分布式事物，异步解耦</li></ul><h5 id="rocketmq概念模型"><a href="#rocketmq概念模型" class="headerlink" title="rocketmq概念模型"></a>rocketmq概念模型</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150930.png" alt="屏幕快照 2019-07-02 下午10.04.57"></p><h5 id="部署模型"><a href="#部署模型" class="headerlink" title="部署模型"></a>部署模型</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150936.png" alt="屏幕快照 2019-07-02 下午10.07.58"></p><h3 id="分布式事物"><a href="#分布式事物" class="headerlink" title="分布式事物"></a>分布式事物</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150939.png" alt="屏幕快照 2019-07-02 下午10.26.37"></p><h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>C：一致性</p><p>A：可用性</p><p>P：分区容忍性</p><p>分布式事物中，p分区容忍性是必须的，所以必须在<code>C一致性</code>和<code>A可用性</code>之间做一个选择</p><h4 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h4><p>不追求瞬时状态的强一致，追求的是最终的一致性，也就是我的数据最终会达到一致。</p><p>B：基础可用</p><p>S：软状态</p><p>E：最终一致性</p><p>软状态：在我们的应用当中，会瞬时的存在有数据不一致的情况，比如说一部分数据成功，另外一部分数据还在处理中，那我们的业务认为这些数据是可以容忍的。</p><h4 id="结合到我们缓存库存的模型当中，我们怎么解决这些问题？"><a href="#结合到我们缓存库存的模型当中，我们怎么解决这些问题？" class="headerlink" title="结合到我们缓存库存的模型当中，我们怎么解决这些问题？"></a>结合到我们缓存库存的模型当中，我们怎么解决这些问题？</h4><p>在我们缓存库存当中，我们的redis的状态是正确的状态，比如redis中的库存从87减到86，redis中的86是正确的，但是我们数据库中库存状态由于异步消息队列的consumer端还没有被触发，因此在consumer没有消费完消息之前，数据库里的库存数错的，比如还是87。但是只要这个分布式的消息投递成功了，consumer端消费了这个消息，最终我们数据库中的状态会从87减到86，达到最终一致性。</p><p>这样的话，只要我们使用的消息中间件的高可用性达到99.99%，那至少有99.99%以上的概率，我们数据库里的状态可以和redis中的数据保持一致的。</p><h3 id="数据库中库存数据和缓存中保持最终一致性"><a href="#数据库中库存数据和缓存中保持最终一致性" class="headerlink" title="数据库中库存数据和缓存中保持最终一致性"></a>数据库中库存数据和缓存中保持最终一致性</h3><h4 id="缓存库存接入异步化"><a href="#缓存库存接入异步化" class="headerlink" title="缓存库存接入异步化"></a>缓存库存接入异步化</h4><h5 id="ItemServiceImpl-java"><a href="#ItemServiceImpl-java" class="headerlink" title="ItemServiceImpl.java"></a>ItemServiceImpl.java</h5><pre><code class="java">@Override    @Transactional    public boolean decreaseStock(Integer itemId, Integer amount) throws BusinessException {       // int affectedRow =  itemStockDOMapper.decreaseStock(itemId,amount);        Long result=redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue()*-1);        if(result &gt;= 0){            //更新库存成功            boolean mqResult= mQproducer.ausncReduceStock(itemId,amount);            if (!mqResult){                redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue());                return false;            }            return true;        }else{            redisTemplate.opsForValue().increment(&quot;promo_item_stock_&quot;+itemId,amount.intValue());            //更新库存失败            return false;        }    }</code></pre><p>在redis中扣减完库存后，将扣减库存的消息发送给MQ。使用的是<code>mQproducer.ausncReduceStock(itemId,amount)</code>方法：</p><h5 id="引入消息生产者MQproducer-java"><a href="#引入消息生产者MQproducer-java" class="headerlink" title="引入消息生产者MQproducer.java"></a>引入消息生产者MQproducer.java</h5><pre><code class="java">//同步库存扣减消息    public boolean ausncReduceStock(Integer itemId,Integer amount)  {        Map&lt;String,Object&gt; bodyMap=new HashMap&lt;&gt;();        bodyMap.put(&quot;itemId&quot;,itemId);        bodyMap.put(&quot;amount&quot;,amount);        Message message=new Message(topicName,&quot;increase&quot;, JSON.toJSON(bodyMap).toString().getBytes(Charset.forName(&quot;UTF-8&quot;)));        try {            producer.send(message);        } catch (MQClientException e) {            return false;        } catch (RemotingException e) {            return false;        } catch (MQBrokerException e) {            return false;        } catch (InterruptedException e) {            return false;        }        return true;    }</code></pre><h5 id="引入MQconsumer-java"><a href="#引入MQconsumer-java" class="headerlink" title="引入MQconsumer.java"></a>引入MQconsumer.java</h5><pre><code class="java">@Componentpublic class MQconsumer {    private DefaultMQPushConsumer consumer;    @Value(&quot;${mq.nameserver.addr}&quot;)    private String nameAddr;    @Value(&quot;${mq.topicname}&quot;)    private String topicName;    @Autowired    private ItemStockDOMapper itemStockDOMapper;    @PostConstruct    public void init() throws MQClientException {        consumer=new DefaultMQPushConsumer(&quot;stock_consumer_group&quot;);        consumer.setNamesrvAddr(nameAddr);        consumer.subscribe(topicName,&quot;*&quot;);        consumer.registerMessageListener(new MessageListenerConcurrently() {            @Override            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext consumeConcurrentlyContext) {               //实现库存真正到数据库内扣减的逻辑                Message message=msgs.get(0);                String jsonstring=new String(message.getBody());                Map&lt;String,Object&gt; map= JSON.parseObject(jsonstring, Map.class);                Integer itemId= (Integer) map.get(&quot;itemId&quot;);                Integer amount= (Integer) map.get(&quot;amount&quot;);                itemStockDOMapper.decreaseStock(itemId,amount);                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;            }        });        consumer.start();    }}</code></pre><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li><p>异步消息发送失败</p><p><code>MQproducer.java</code>中的<code>producer.send(message)</code>消息发送失败了，我们现在没有解决。</p></li><li><p>扣减操作失败</p><p>若库存扣减这个操作执行失败了，这条扣减消息应该怎么处理</p></li><li><p>下单失败无法正确回补库存</p><p>若用户取消订单了，我们怎么回滚库存呢</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第6章 查询优化技术之页面静态化</title>
      <link href="/2019/06/18/miaosha/di-6-zhang-cha-xun-you-hua-ji-zhu-zhi-ye-mian-jing-tai-hua-dong-tai-qing-qiu-jia-jing-tai-ye-mian-yi-tong-jing-tai-hua/"/>
      <url>/2019/06/18/miaosha/di-6-zhang-cha-xun-you-hua-ji-zhu-zhi-ye-mian-jing-tai-hua-dong-tai-qing-qiu-jia-jing-tai-ye-mian-yi-tong-jing-tai-hua/</url>
      
        <content type="html"><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul><li><p>优化的是H5(static)，请求走静态资源文件。</p></li><li><p>将静态资源的请求路由到CDN</p></li></ul><a id="more"></a><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150911.png" alt="秒杀结构图"></p><h1 id="静态请求CDN"><a href="#静态请求CDN" class="headerlink" title="静态请求CDN"></a>静态请求CDN</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150911.jpg" alt="v2-2080dfe83dd76bd079dbf3e7348ca795_hd"></p><p>结构图</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150912.png" alt="秒杀结构图"></p><h2 id="DNS用CNAME解析源站"><a href="#DNS用CNAME解析源站" class="headerlink" title="DNS用CNAME解析源站"></a>DNS用CNAME解析源站</h2><h2 id="回源缓存设置"><a href="#回源缓存设置" class="headerlink" title="回源缓存设置"></a>回源缓存设置</h2><h3 id="cache-control响应头"><a href="#cache-control响应头" class="headerlink" title="cache control响应头"></a>cache control响应头</h3><p>Request Headers：</p><p>例：</p><pre><code class="properties">GET / HTTP/1.1Host: localhost:4000Connection: keep-alivePragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: Hm_lvt_512065947708a980c982b4401d14c2f5=1551084094; SESSION=OGQzOGIzMGEtZGYyNy00MjQ4LWI1ZGYtMjc2OTAxYjJmNjEz</code></pre><p>###cache control有几种取值：</p><ul><li><p>private：客户端可以缓存(请求发起的浏览器才可以缓存)</p></li><li><p>public：客户端和代理服务器（反向或正向代理）都可以缓存</p></li><li><p>max-age=xxx：缓存的内容将在xxx秒之后失效</p><p>也就是说我们对应缓存的内容，从收到服务端的这个max-age返回数据开始，存储xxx秒后这个请求就失效，客户端必须往对应的服务端上面再次发起请求，用来验证和结束对应的请求体</p></li><li><p>no-cache：强制向服务端再验证一次(<strong>会将对应的缓存存储在客户端，但是在下次用的时候要向服务端验证一次这个缓存到底是能用还是不能用，no-store是压根不存</strong>)</p></li><li><p>no-store：不缓存请求的任何返回内容</p></li></ul><h4 id="怎么选择HTTP-cache-control头？"><a href="#怎么选择HTTP-cache-control头？" class="headerlink" title="怎么选择HTTP cache control头？"></a>怎么选择HTTP cache control头？</h4><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150913.png" alt="未命名文件-2"></p><h3 id="有效性判断"><a href="#有效性判断" class="headerlink" title="有效性判断"></a>有效性判断</h3><ul><li>ETag：资源唯一标识</li><li>If-None-Match：客户端发送的匹配ETag标识符</li><li>Last-modified：资源最后被修改时间</li><li>If-Modified-Since：客户端发送的匹配资源最后修改时间的标识符</li></ul><p>补充：</p><p>ETag：</p><p>一般是将请求的资源做一个MD5或者类似hash操作，生成一个ETag的唯一标识，服务端在第一次返回内容中加上这个ETag的唯一标识，一起返回给浏览器，浏览器会存储下来这个ETag；下一次请求的时候，所谓的有效性判断，是浏览器将之前缓存下来内容的ETag的值一起带到服务器上，用来验证说它不发送具体的响应，而是发送一个对应的HTTP请求并且带上这个ETag的值，服务端会将这个ETag的值和我本地的文件ETag内容做比较，若比较是一致的，就返回304 not-modified，告诉客户端说服务端这个内容是有效的，直接使用浏览器里的缓存即可</p><p>若If-Modified-Since的值早于Last-modified的值，证明是无效的；若晚于Last-modified的值，则是有效的，说明这段时间资源没有被修改过。</p><h3 id="用户请求浏览器资源的网站路径"><a href="#用户请求浏览器资源的网站路径" class="headerlink" title="用户请求浏览器资源的网站路径"></a>用户请求浏览器资源的网站路径</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150914.png" alt="未命名文件"></p><h3 id="浏览器三种刷新方式"><a href="#浏览器三种刷新方式" class="headerlink" title="浏览器三种刷新方式"></a>浏览器三种刷新方式</h3><ul><li>回车刷新或者a链接(get请求跳转)：看cache-control对应的max-age是否仍然有效，有效则直接从cache取对应的数据，若cache-control中为no-cache，则进入缓存协商逻辑</li><li>F5刷新(Windows)或者command+R(macOS)刷新：去掉cache-control中的max-age或者直接设置max-age为0，然后进入缓存协商逻辑</li><li>ctrl+F5或commond+shift+R刷新：去掉cache-control和协商头，强制刷新 (强制从服务端拿内容)</li></ul><p>对应的协商机制：</p><p>比较Last-modified和ETag到服务端，若服务端判断没变化则304不返回数据，否则200返回数据</p><h3 id="CDN自定义缓存策略"><a href="#CDN自定义缓存策略" class="headerlink" title="CDN自定义缓存策略"></a>CDN自定义缓存策略</h3><ul><li>可自定义目录过期时间</li><li>可自定义后缀名过期时间</li><li>可自定义对应权重</li><li>可通过界面或api强制cdn对应目录刷新(不一定保证成功)</li></ul><h4 id="阿里云CDN配置"><a href="#阿里云CDN配置" class="headerlink" title="阿里云CDN配置"></a>阿里云CDN配置</h4><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150915.png" alt="屏幕快照 2019-07-01 下午9.20.29"></p><h3 id="静态资源部署策略-1"><a href="#静态资源部署策略-1" class="headerlink" title="静态资源部署策略(1)"></a>静态资源部署策略(1)</h3><ol><li>css,js,img等元素使用带版本号部署，例如<code>a.js？=v1.0</code>不便利，且维护困难</li><li>css,js,img等元素使用带摘要（hash获得）部署，例如a<code>.js？=45edw</code>，存在先部署html还是先部署资源的覆盖问题</li><li>css,js,img等元素使用带摘要做文件名部署，例如<code>45edw.js</code>，新老版本并存且可回滚，资源部署完后再部署HTML</li></ol><p>采用第三种</p><h3 id="静态资源部署策略-2"><a href="#静态资源部署策略-2" class="headerlink" title="静态资源部署策略(2)"></a>静态资源部署策略(2)</h3><ol><li><p>对静态资源保持生命周期内不会变，max-age可设置很长，无视失效更新周期</p></li><li><p>html文件设置no-cache或较短max-age，以便更新</p></li><li><p>html文件仍然设置较长的max-age，依靠动态的获取版本号请求发送到后端，异步下载最新的版本号的html展示渲染在前端</p><p>将html文件缓存。html每次都能展示缓存离的内容，没有问题，但是html文件里面每次在启动的时候有一个很小很小的<code>ajax</code>请求头，ajax请求做的事情就是带着本地的html版本号去我的服务端调用一个动态的接口，这个动态的接口比较ajax中html版本号和后端的版本号是否是最新的；如果是的话，对应的html渲染到前端即可；如果不是，就需要在后端从新下载最新版本号的html(<strong>异步更新策略</strong>)</p></li></ol><p>第三种方式是最好的，但是一般第二种也足够使用</p><h3 id="静态资源部署策略-3"><a href="#静态资源部署策略-3" class="headerlink" title="静态资源部署策略(3)"></a>静态资源部署策略(3)</h3><p>上面讨论的都是静态资源文件</p><ol><li>动态请求可以静态化成json资源推送到cdn上</li><li>依靠异步请求获取后端节点对应资源状态做紧急下架处理</li><li>可通过跑批紧急推送cdn内容以使其下架等操作</li></ol><h2 id="强推失效"><a href="#强推失效" class="headerlink" title="强推失效"></a>强推失效</h2><h1 id="全页面静态化"><a href="#全页面静态化" class="headerlink" title="全页面静态化"></a>全页面静态化</h1><ul><li>html，css，js静态资源cdn化</li><li>js，ajax动态请求cdn化</li><li>全页面静态化</li></ul><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在服务端完成html，css，甚至js的load；并且渲染成纯html文件后直接以静态资源的方式部署到cdn上</p><h2 id="phantomjs"><a href="#phantomjs" class="headerlink" title="phantomjs"></a>phantomjs</h2><p>可以理解为无头浏览器，可以借助其模拟webkit js的执行</p><ul><li>演示样例</li></ul><p>js:</p><pre><code class="js">var page = require(&#39;webpage&#39;).create();page.open(&#39;http://www.baidu.com&#39;, function() {    setTimeout(function() {        page.render(&#39;baidu.png&#39;);        phantom.exit();    }, 200);});</code></pre><ul><li>运行：</li></ul><pre><code class="bash">phantomjs spiderbaidu.js</code></pre><ul><li>结果：</li></ul><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150916.png" alt="baidu"></p><h2 id="phantomjs应用"><a href="#phantomjs应用" class="headerlink" title="phantomjs应用"></a>phantomjs应用</h2><ul><li>修改需要全页面静态化的实现，采用<code>initView</code>和<code>hasInit</code>方式防止多次初始化</li><li>编写对应轮询生成内容方式</li><li>将全静态化页面生成后推送到CDN</li></ul><p>1.在<code>/usr/local/Caskroom/phantomjs/2.1.1/phantomjs-2.1.1-macosx/js/</code>下创建<code>getitem.js</code></p><pre><code class="js">var page = require(&quot;webpage&quot;).create();var fs = require(&quot;fs&quot;);page.open(&quot;http://localhost/resources/getitem.html?id=6&quot;,function(status){    console.log(&quot;status= &quot;+status);   fs.write(&quot;getitem.html&quot;,page.content,&quot;w&quot;);   phantom.exit();});</code></pre><p>2.执行</p><pre><code class="bash">xuxinghua@xxhdemac:/usr/local/Caskroom/phantomjs/2.1.1/phantomjs-2.1.1-macosx/js$ phantomjs getitem.jsstatus= success</code></pre><p>成功后会在当前目录生成<code>getitem.html</code></p><pre><code class="bash">xuxinghua@xxhdemac:/usr/local/Caskroom/phantomjs/2.1.1/phantomjs-2.1.1-macosx/js$ lsgetitem.html  getitem.js</code></pre>]]></content>
      
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第5章 查询优化技术之多级缓存</title>
      <link href="/2019/06/17/miaosha/di-5-zhang-cha-xun-you-hua-ji-zhu-zhi-duo-ji-huan-cun/"/>
      <url>/2019/06/17/miaosha/di-5-zhang-cha-xun-you-hua-ji-zhu-zhi-duo-ji-huan-cun/</url>
      
        <content type="html"><![CDATA[<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ul><li>掌握多级缓存的定义</li><li>掌握redis缓存，本地缓存：不同应用场景的使用，以及他们的优劣</li><li>掌握热点nginx lua缓存</li></ul><a id="more"></a><h1 id="缓存设计原则"><a href="#缓存设计原则" class="headerlink" title="缓存设计原则"></a>缓存设计原则</h1><ul><li>用快速存取设备，用内存</li><li>将缓存推到离用户最近的地方</li><li>脏缓存清理</li></ul><p><strong>补：</strong></p><p>1.为什么将缓存推到离用户最近的地方？</p><p>现在有：前端的H5，nginx的反向代理，有miaoshaserver的Tomcat应用服务器，以及对应的数据库的mysql。缓存应该建在哪些地方呢？原则就是将缓存推到离用户最近的地方。<strong>==缓存离用户越近，用户对应访问的数据走的链路也就越少，对应的查询效率也就越高。==</strong></p><p>2.一旦数据库里面的数据发送变化，那么该数据在缓存中就成了脏数据</p><h1 id="多机缓存"><a href="#多机缓存" class="headerlink" title="多机缓存"></a>多机缓存</h1><ul><li>redis缓存</li><li>热点内存本地缓存</li><li>nginx proxy cache缓存</li><li>nginx lua 缓存</li></ul><p>补：</p><p><strong>==热点内存本地缓存：redis毕竟是有网络对应的开销，可以将热点数据做到jvm内存的本地缓存中==</strong></p><h1 id="redis缓存"><a href="#redis缓存" class="headerlink" title="redis缓存"></a>redis缓存</h1><p>redis具有存储数据库的能力，但是需要允许一定数量数据丢失的。在我们做redis使用的时候，我们其实很少特别关心数据的完整性问题，经常还会把它当做一个易失性的<strong>集中式缓存中间件</strong>并且<strong>基于KV内存级别的存储</strong>。</p><h3 id="redis定位"><a href="#redis定位" class="headerlink" title="redis定位"></a>redis定位</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150861.png" alt="未命名文件"></p><h2 id="redis使用"><a href="#redis使用" class="headerlink" title="redis使用"></a>redis使用</h2><h3 id="单机"><a href="#单机" class="headerlink" title="单机"></a>单机</h3><p>1.单个机子有内存上限</p><p>2.单点故障问题。单机redis服务器出现故障，整个应用程序就不能用了。比如将token存储在redis中的用户登录操作</p><h3 id="sentinal哨兵模式"><a href="#sentinal哨兵模式" class="headerlink" title="sentinal哨兵模式"></a>sentinal哨兵模式</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150900.png" alt="未命名文件-2"></p><h3 id="集群cluster模式"><a href="#集群cluster模式" class="headerlink" title="集群cluster模式"></a>集群cluster模式</h3><p>redis cluster数据同步+paxos竞争算法</p><h3 id="商品详情动态内容实现"><a href="#商品详情动态内容实现" class="headerlink" title="商品详情动态内容实现"></a>商品详情动态内容实现</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>在redis中存储对应商品ID的<code>ItemModel</code>对象(JSON序列化后的)</p><p>之后的请求可以根据URL上传来的商品ID在redis中查找对应的<code>ItemModel</code>对象，减少了3次mysql查询操作，加快查询效率</p><h4 id="优化前"><a href="#优化前" class="headerlink" title="优化前"></a>优化前</h4><p>ItemController.class</p><pre><code class="java">    //商品详情页浏览    @RequestMapping(value = &quot;/get&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType getItem(@RequestParam(name = &quot;id&quot;)Integer id){        ItemModel itemModel = itemService.getItemById(id);        ItemVO itemVO = convertVOFromModel(itemModel);        return CommonReturnType.create(itemVO);    }</code></pre><p>ItemServiceImpl.class</p><pre><code class="java">    @Override    public ItemModel getItemById(Integer id) {        ItemDO itemDO = itemDOMapper.selectByPrimaryKey(id);        if(itemDO == null){            return null;        }        //操作获得库存数量        ItemStockDO itemStockDO = itemStockDOMapper.selectByItemId(itemDO.getId());        //将dataobject-&gt;model        ItemModel itemModel = convertModelFromDataObject(itemDO,itemStockDO);        //获取活动商品信息        PromoModel promoModel = promoService.getPromoByItemId(itemModel.getId());        if(promoModel != null &amp;&amp; promoModel.getStatus().intValue() != 3){            itemModel.setPromoModel(promoModel);        }        return itemModel;    }</code></pre><p>有三次数据库操作：1.获得商品基本信息 2.获得商品库存信息 3.获得商品活动信息</p><h4 id="优化后"><a href="#优化后" class="headerlink" title="优化后"></a>优化后</h4><p>优化点：直接在Controller层缓存商品信息，不走<code>itemService.getItemById(id);</code>操作去查询数据库</p><pre><code class="java">    //商品详情页浏览    @RequestMapping(value = &quot;/get&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType getItem(@RequestParam(name = &quot;id&quot;)Integer id){        //根据商品的id到redis内获取        ItemModel itemModel= (ItemModel) redisTemplate.opsForValue().get(&quot;item_&quot;+id);        //若redis内存不存在对应的itemModel，则访问下游service        if (itemModel==null){            itemModel = itemService.getItemById(id);            //设置itemModel到redis内            redisTemplate.opsForValue().set(&quot;item_&quot;+id,itemModel);            //设置键值对的失效时间,10分钟            redisTemplate.expire(&quot;item_&quot;+id,10, TimeUnit.MINUTES);        }        ItemVO itemVO = convertVOFromModel(itemModel);        return CommonReturnType.create(itemVO);    }</code></pre><h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p>1.输入<code>http://localhost:8090/item/get?id=6</code></p><p>2.返回</p><pre><code class="json">status    &quot;success&quot;data    id    6title    &quot;iphone99&quot;price    800stock    60description    &quot;最好用的苹果手机&quot;sales    152imgUrl    &quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg&quot;promoStatus    2promoPrice    100promoId    1startDate    &quot;2018-01-19 00:04:30&quot;</code></pre><p>3.redis-server</p><pre><code class="bash">202.117.35.220:6379&gt; SELECT 10OK202.117.35.220:6379[10]&gt; KEYS *1) &quot;\xac\xed\x00\x05t\x00\x06item_6&quot;202.117.35.220:6379[10]&gt; get &quot;\xac\xed\x00\x05t\x00\x06item_6&quot;&quot;\xac\xed\x00\x05sr\x000com.imooc.miaoshaproject.service.model.ItemModeln\x88\x87\xf0:\xa5i\xdd\x02\x00\bL\x00\x0bdescriptiont\x00\x12Ljava/lang/String;L\x00\x02idt\x00\x13Ljava/lang/Integer;L\x00\x06imgUrlq\x00~\x00\x01L\x00\x05pricet\x00\x16Ljava/math/BigDecimal;L\x00\npromoModelt\x003Lcom/imooc/miaoshaproject/service/model/PromoModel;L\x00\x05salesq\x00~\x00\x02L\x00\x05stockq\x00~\x00\x02L\x00\x05titleq\x00~\x00\x01xpt\x00\x18\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xbasr\x00\x11java.lang.Integer\x12\xe2\xa0\xa4\xf7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xac\x95\x1d\x0b\x94\xe0\x8b\x02\x00\x00xp\x00\x00\x00\x06t\x00^https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpgsr\x00\x14java.math.BigDecimalT\xc7\x15W\xf9\x81(O\x03\x00\x02I\x00\x05scaleL\x00\x06intValt\x00\x16Ljava/math/BigInteger;xq\x00~\x00\b\x00\x00\x00\x00sr\x00\x14java.math.BigInteger\x8c\xfc\x9f\x1f\xa9;\xfb\x1d\x03\x00\x06I\x00\bbitCountI\x00\tbitLengthI\x00\x13firstNonzeroByteNumI\x00\x0clowestSetBitI\x00\x06signum[\x00\tmagnitudet\x00\x02[Bxq\x00~\x00\b\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff\xfe\x00\x00\x00\x01ur\x00\x02[B\xac\xf3\x17\xf8\x06\bT\xe0\x02\x00\x00xp\x00\x00\x00\x02\x03 xxsr\x001com.imooc.miaoshaproject.service.model.PromoModelC$\x13\x1f\x19\xa6\xe2\xa0\x02\x00\aL\x00\aendDatet\x00\x18Lorg/joda/time/DateTime;L\x00\x02idq\x00~\x00\x02L\x00\x06itemIdq\x00~\x00\x02L\x00\x0epromoItemPriceq\x00~\x00\x03L\x00\tpromoNameq\x00~\x00\x01L\x00\tstartDateq\x00~\x00\x14L\x00\x06statusq\x00~\x00\x02xpsr\x00\x16org.joda.time.DateTime\xb8&lt;xdj[\xdd\xf9\x02\x00\x00xr\x00\x1forg.joda.time.base.BaseDateTime\xff\xff\xf9\xe1O].\xa3\x02\x00\x02J\x00\aiMillisL\x00\x0biChronologyt\x00\x1aLorg/joda/time/Chronology;xp\x00\x00\x01oW\x89\x18\x00sr\x00&#39;org.joda.time.chrono.ISOChronology$Stub\xa9\xc8\x11fq7P&#39;\x03\x00\x00xpsr\x00\x1forg.joda.time.DateTimeZone$Stub\xa6/\x01\x9a|2\x1a\xe3\x03\x00\x00xpw\x0f\x00\rAsia/Shanghaixxsq\x00~\x00\a\x00\x00\x00\x01q\x00~\x00\tsq\x00~\x00\x0b\x00\x00\x00\x00sq\x00~\x00\x0e\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfe\xff\xff\xff\xfe\x00\x00\x00\x01uq\x00~\x00\x11\x00\x00\x00\x01dxxt\x00\x13iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8sq\x00~\x00\x16\x00\x00\x01a\n\x03\xb2\xb0q\x00~\x00\x1bsq\x00~\x00\a\x00\x00\x00\x02sq\x00~\x00\a\x00\x00\x00\x98sq\x00~\x00\a\x00\x00\x00&lt;t\x00\biphone99&quot;</code></pre><p>采用的是java序列化方式</p><h4 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h4><p>对应的<code>ItemModel</code>需要<code>implements Serializable</code></p><p>对应的<code>PromoModel</code>需要 <code>implements Serializable</code>  </p><h4 id="序列化优化"><a href="#序列化优化" class="headerlink" title="序列化优化"></a>序列化优化</h4><h5 id="1-将redis中的KV做指定序列化处理"><a href="#1-将redis中的KV做指定序列化处理" class="headerlink" title="1.将redis中的KV做指定序列化处理"></a>1.将redis中的KV做指定序列化处理</h5><p>key做String序列化，value做json序列化处理</p><p>RedisConfig.class</p><pre><code class="java">@Component@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)//默认是1800public class RedisConfig {    @Bean    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){        RedisTemplate redisTemplate=new RedisTemplate();        redisTemplate.setConnectionFactory(redisConnectionFactory);        //首先解决key的序列化方式,，序列化String        StringRedisSerializer stringRedisSerializer=new StringRedisSerializer();        redisTemplate.setKeySerializer(stringRedisSerializer);        //解决value的序列化方式        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=new Jackson2JsonRedisSerializer(Object.class);        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);        return redisTemplate;    }}</code></pre><p><strong>实验</strong></p><pre><code class="bash">202.117.35.220:6379[10]&gt; KEYS *1) &quot;item_6&quot;202.117.35.220:6379[10]&gt; get item_6&quot;{\&quot;id\&quot;:6,\&quot;title\&quot;:\&quot;iphone99\&quot;,\&quot;price\&quot;:800,\&quot;stock\&quot;:60,\&quot;description\&quot;:\&quot;\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xba\&quot;,\&quot;sales\&quot;:152,\&quot;imgUrl\&quot;:\&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg\&quot;,\&quot;promoModel\&quot;:{\&quot;id\&quot;:1,\&quot;status\&quot;:2,\&quot;promoName\&quot;:\&quot;iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8\&quot;,\&quot;startDate\&quot;:{\&quot;secondOfDay\&quot;:270,\&quot;minuteOfDay\&quot;:4,\&quot;centuryOfEra\&quot;:20,\&quot;yearOfEra\&quot;:2018,\&quot;yearOfCentury\&quot;:18,\&quot;weekyear\&quot;:2018,\&quot;monthOfYear\&quot;:1,\&quot;weekOfWeekyear\&quot;:3,\&quot;hourOfDay\&quot;:0,\&quot;minuteOfHour\&quot;:4,\&quot;secondOfMinute\&quot;:30,\&quot;millisOfSecond\&quot;:0,\&quot;millisOfDay\&quot;:270000,\&quot;dayOfMonth\&quot;:19,\&quot;dayOfWeek\&quot;:5,\&quot;era\&quot;:1,\&quot;dayOfYear\&quot;:19,\&quot;year\&quot;:2018,\&quot;chronology\&quot;:{\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;}},\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;millis\&quot;:1516291470000,\&quot;afterNow\&quot;:false,\&quot;beforeNow\&quot;:true,\&quot;equalNow\&quot;:false},\&quot;endDate\&quot;:{\&quot;secondOfDay\&quot;:0,\&quot;minuteOfDay\&quot;:0,\&quot;centuryOfEra\&quot;:20,\&quot;yearOfEra\&quot;:2019,\&quot;yearOfCentury\&quot;:19,\&quot;weekyear\&quot;:2020,\&quot;monthOfYear\&quot;:12,\&quot;weekOfWeekyear\&quot;:1,\&quot;hourOfDay\&quot;:0,\&quot;minuteOfHour\&quot;:0,\&quot;secondOfMinute\&quot;:0,\&quot;millisOfSecond\&quot;:0,\&quot;millisOfDay\&quot;:0,\&quot;dayOfMonth\&quot;:31,\&quot;dayOfWeek\&quot;:2,\&quot;era\&quot;:1,\&quot;dayOfYear\&quot;:365,\&quot;year\&quot;:2019,\&quot;chronology\&quot;:{\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;}},\&quot;zone\&quot;:{\&quot;fixed\&quot;:false,\&quot;uncachedZone\&quot;:{\&quot;cachable\&quot;:true,\&quot;fixed\&quot;:false,\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;id\&quot;:\&quot;Asia/Shanghai\&quot;},\&quot;millis\&quot;:1577721600000,\&quot;afterNow\&quot;:true,\&quot;beforeNow\&quot;:false,\&quot;equalNow\&quot;:false},\&quot;itemId\&quot;:6,\&quot;promoItemPrice\&quot;:100}}&quot;</code></pre><p>结果还是不好，进一步需要对<code>PromoModel</code>中的<code>Datetime</code>进行序列化</p><h5 id="2-对Datetime进行json序列化"><a href="#2-对Datetime进行json序列化" class="headerlink" title="2.对Datetime进行json序列化"></a>2.对Datetime进行json序列化</h5><p>RedisConfig.class</p><pre><code class="java">@Component@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)//默认是1800public class RedisConfig {    @Bean    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){        RedisTemplate redisTemplate=new RedisTemplate();        redisTemplate.setConnectionFactory(redisConnectionFactory);        //首先解决key的序列化方式,，序列化String        StringRedisSerializer stringRedisSerializer=new StringRedisSerializer();        redisTemplate.setKeySerializer(stringRedisSerializer);        //解决value的序列化方式        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer=new Jackson2JsonRedisSerializer(Object.class);        //序列化Datetime        ObjectMapper objectMapper=new ObjectMapper();        SimpleModule simpleModule=new SimpleModule();        simpleModule.addSerializer(DateTime.class,new JodaDatimeJsonSerializer());        simpleModule.addDeserializer(DateTime.class,new JodaDateTimeJsonDeserializer());        objectMapper.registerModule(simpleModule);        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);        return redisTemplate;    }}</code></pre><p>结果：</p><pre><code class="bash">202.117.35.220:6379[10]&gt; GEt item_6&quot;{\&quot;id\&quot;:6,\&quot;title\&quot;:\&quot;iphone99\&quot;,\&quot;price\&quot;:800,\&quot;stock\&quot;:60,\&quot;description\&quot;:\&quot;\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xba\&quot;,\&quot;sales\&quot;:152,\&quot;imgUrl\&quot;:\&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg\&quot;,\&quot;promoModel\&quot;:{\&quot;id\&quot;:1,\&quot;status\&quot;:2,\&quot;promoName\&quot;:\&quot;iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8\&quot;,\&quot;startDate\&quot;:\&quot;2018-01-19 00:04:30\&quot;,\&quot;endDate\&quot;:\&quot;2019-12-31 00:00:00\&quot;,\&quot;itemId\&quot;:6,\&quot;promoItemPrice\&quot;:100}}&quot;</code></pre><h5 id="3-在redis中value值里如类信息"><a href="#3-在redis中value值里如类信息" class="headerlink" title="3.在redis中value值里如类信息"></a>3.在redis中value值里如类信息</h5><p>RedisConfig.class</p><pre><code class="java">//在value中加入对应类的信息        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</code></pre><p>最终结果：</p><pre><code class="bash">202.117.35.220:6379[10]&gt; GEt item_6&quot;[\&quot;com.imooc.miaoshaproject.service.model.ItemModel\&quot;,{\&quot;id\&quot;:6,\&quot;title\&quot;:\&quot;iphone99\&quot;,\&quot;price\&quot;:[\&quot;java.math.BigDecimal\&quot;,800],\&quot;stock\&quot;:60,\&quot;description\&quot;:\&quot;\xe6\x9c\x80\xe5\xa5\xbd\xe7\x94\xa8\xe7\x9a\x84\xe8\x8b\xb9\xe6\x9e\x9c\xe6\x89\x8b\xe6\x9c\xba\&quot;,\&quot;sales\&quot;:152,\&quot;imgUrl\&quot;:\&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg\&quot;,\&quot;promoModel\&quot;:[\&quot;com.imooc.miaoshaproject.service.model.PromoModel\&quot;,{\&quot;id\&quot;:1,\&quot;status\&quot;:2,\&quot;promoName\&quot;:\&quot;iphone4\xe6\x8a\xa2\xe8\xb4\xad\xe6\xb4\xbb\xe5\x8a\xa8\&quot;,\&quot;startDate\&quot;:\&quot;2018-01-19 00:04:30\&quot;,\&quot;endDate\&quot;:\&quot;2019-12-31 00:00:00\&quot;,\&quot;itemId\&quot;:6,\&quot;promoItemPrice\&quot;:[\&quot;java.math.BigDecimal\&quot;,100]}]}]&quot;</code></pre><h2 id="redis集中式缓存压测效果验证"><a href="#redis集中式缓存压测效果验证" class="headerlink" title="redis集中式缓存压测效果验证"></a>redis集中式缓存压测效果验证</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150901.png" alt="屏幕快照 2019-06-23 下午2.03.04"></p><h1 id="本地热点缓存"><a href="#本地热点缓存" class="headerlink" title="本地热点缓存"></a>本地热点缓存</h1><ul><li>存放热点数据</li><li>脏读非常不敏感</li><li>内存可控</li></ul><p>注：</p><p><strong>本地缓存其实就是==java虚拟机JVM的缓存==</strong></p><h2 id="Guava-cache"><a href="#Guava-cache" class="headerlink" title="Guava cache"></a>Guava cache</h2><p>单纯的hashmap是无法满足的</p><p>1.并发读写</p><p>2.内存淘汰机制</p><h3 id="介绍-Guava"><a href="#介绍-Guava" class="headerlink" title="介绍 Guava"></a>介绍 Guava</h3><ul><li>可控制的大小和超时时间</li><li>可配置的lru策略</li><li>线程安全</li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为我们是多机缓存，先找<code>1.本地缓存</code>，不存在<code>2.找redis</code>，还不存在<code>3.找mysql数据库</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="引入jar包"><a href="#引入jar包" class="headerlink" title="引入jar包"></a>引入jar包</h4><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;com.google.guava&lt;/groupId&gt;      &lt;artifactId&gt;guava&lt;/artifactId&gt;      &lt;version&gt;18.0&lt;/version&gt;    &lt;/dependency&gt;</code></pre><h4 id="ItemController-class"><a href="#ItemController-class" class="headerlink" title="ItemController.class"></a>ItemController.class</h4><pre><code class="java">//商品详情页浏览    @RequestMapping(value = &quot;/get&quot;,method = {RequestMethod.GET})    @ResponseBody    public CommonReturnType getItem(@RequestParam(name = &quot;id&quot;)Integer id){        ItemModel itemModel=null;        //先取本地缓存        itemModel=(ItemModel)cacheService.getFromCommonCache(&quot;item_&quot;+id);        //本地缓存没有，找redis        if (itemModel==null){            //根据商品的id到redis内获取            itemModel= (ItemModel) redisTemplate.opsForValue().get(&quot;item_&quot;+id);            //若redis内存不存在对应的itemModel，则访问下游itemService查询数据库            if (itemModel==null){                itemModel = itemService.getItemById(id);                //设置itemModel到redis内                redisTemplate.opsForValue().set(&quot;item_&quot;+id,itemModel);                //设置键值对的失效时间,10分钟                redisTemplate.expire(&quot;item_&quot;+id,10, TimeUnit.MINUTES);            }            //填充本地缓存            cacheService.setCommonCache(&quot;item_&quot;+id,itemModel);        }        ItemVO itemVO = convertVOFromModel(itemModel);        return CommonReturnType.create(itemVO);    }</code></pre><h2 id="本地缓存缺点"><a href="#本地缓存缺点" class="headerlink" title="本地缓存缺点"></a>本地缓存缺点</h2><p>1.当本地热点缓存中数据发生更新时，本地热点缓存没有好的机制去更新</p><p>2.本地热点缓存还有一个JVM容量大小的限制</p><h1 id="nginx缓存"><a href="#nginx缓存" class="headerlink" title="nginx缓存"></a>nginx缓存</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150902.png" alt="秒杀结构图"></p><p>本地缓存：</p><p>1.nginx将用户请求分发到<code>miaosha.jar</code>中，并经过<code>org.springframework.web.servlet. DispatcherServlet</code>中转发，需要启动java代码完成对应的操作，总规是有消耗 </p><p>2.nginx和miaosha.jar直接的局域网连接</p><p>试想一下，我们是不是可以把缓存在nginx上做？</p><p>因为nginx是里用户H5最近的一个节点，若我们把对应的热点数据做到nginx上的话，优化的策略会更好。</p><h2 id="1-nginx-proxy-cache缓存"><a href="#1-nginx-proxy-cache缓存" class="headerlink" title="1.nginx proxy cache缓存"></a>1.nginx proxy cache缓存</h2><ul><li>nginx反向代理前置</li><li>依靠文件系统存对应索引的文件</li><li>依靠内存缓存文件地址</li></ul><h3 id="修改nginx-conf"><a href="#修改nginx-conf" class="headerlink" title="修改nginx.conf"></a>修改nginx.conf</h3><pre><code>#申明一个cache缓存节点的内容proxy_cache_path /usr/local/Cellar/openresty/1.15.8.1/nginx/tmp_cache levels=1:2 keys_zone=tmp_cache:100m inactive=7d max_size=10g;location / {proxy_pass http://backend_server;#nginx proxy cacheproxy_cache tmp_cache;proxy_cache_key $uri;proxy_cache_valid 200 206 304 302 7d;proxy_set_header Host $http_host:$proxy_port;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_http_version 1.1;proxy_set_header Connection &quot;&quot;;}</code></pre><h3 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h3><p>在浏览器输入<code>http://localhost/item/get?id=6</code></p><p>如果配置成功，linux服务器的<code>/xxh009/miaosha/tomcat/access_log.2019-06-23.log</code>里，多次刷新页面，也只有一行记录</p><pre><code class="bash">115.154.255.245 - - [23/Jun/2019:19:22:02 +0800] &quot;GET /item/get?id=6 HTTP/1.1&quot; 200 328 37</code></pre><p>并且在<code>/usr/local/Cellar/openresty/1.15.8.1/nginx/tmp_cache/中有对应的缓存文件</code></p><p>比如</p><pre><code class="bash"> xuxinghua@xxhdemac /usr/local/Cellar/openresty/1.15.8.1/nginx/tmp_cache/8/f6 cat 86e4d1b3ba4f1464e409c74be4ef6f68�]��������c`]ksr�`�KEY: /item/getHTTP/1.1 200Content-Type: application/json;charset=UTF-8Transfer-Encoding: chunkedDate: Sun, 23 Jun 2019 11:22:02 GMT{&quot;status&quot;:&quot;success&quot;,&quot;data&quot;:{&quot;id&quot;:6,&quot;title&quot;:&quot;iphone99&quot;,&quot;price&quot;:800,&quot;stock&quot;:60,&quot;description&quot;:&quot;最好用的苹果手机&quot;,&quot;sales&quot;:152,&quot;imgUrl&quot;:&quot;https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3974550569,4161544558&amp;fm=27&amp;gp=0.jpg&quot;,&quot;promoStatus&quot;:2,&quot;promoPrice&quot;:100,&quot;promoId&quot;:1,&quot;startDate&quot;:&quot;2018-01-19 00:04:30&quot;}}%</code></pre><h3 id="压测及结果分析"><a href="#压测及结果分析" class="headerlink" title="压测及结果分析"></a>压测及结果分析</h3><p>压测完后，其实还没有之前的速度快，为什么呢？</p><p>因为我们做的这个nginx proxy cache的数据是存放在本地磁盘的，读写磁盘效率很低，还不如nginx与miaosha.jar直接的网络传输效率高。</p><p>所以不用nginx proxy cache。</p><h2 id="2-nginx-lua"><a href="#2-nginx-lua" class="headerlink" title="2.nginx lua"></a>2.nginx lua</h2><ul><li>lua协程机制</li><li>nginx协程机制</li><li>nginx lua插载点</li><li>OpenResty</li></ul><h3 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h3><ul><li>依附于线程的内存模型，切换开销小</li><li>遇阻塞及归还执行权，代码同步</li><li>无需加锁</li></ul><h3 id="nginx协程"><a href="#nginx协程" class="headerlink" title="nginx协程"></a>nginx协程</h3><ul><li>nginx的每一个Worker进程都是在epoll或kqueue这种事件模型之上，封装成协程</li><li>每一个请求都有一个协程进行处理</li><li>即使ngx_lua需要运行lua，相对C有一定的开销，但依旧能保证高并发能力</li></ul><h4 id="nginx协程机制"><a href="#nginx协程机制" class="headerlink" title="nginx协程机制"></a>nginx协程机制</h4><ul><li>nginx每个工作进程创建一个lua虚拟机</li><li>工作进程内的所有协程共享同一个vm</li><li>每一个外部请求由一个lua协程处理，之间数据隔离</li><li>lua代码调用io等异步接口时，协程被挂起，保存上下文数据保持不变</li><li>自动保持，不阻塞工作进程</li><li>io异步操作完成后还有协程上下文，代码继续执行</li></ul><h3 id="nginx处理阶段"><a href="#nginx处理阶段" class="headerlink" title="nginx处理阶段"></a>nginx处理阶段</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150903.png" alt="屏幕快照 2019-06-23 下午8.04.21"></p><p>*_handler 用户可以定制</p><h3 id="nginx-lua插载点"><a href="#nginx-lua插载点" class="headerlink" title="nginx lua插载点"></a>nginx lua插载点</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150904.png" alt="屏幕快照 2019-06-23 下午8.07.26"></p><ol><li>Init_by_lua:系统启动时调用</li><li>init_worker_by_lua:worker进程启动时调用</li><li>set_by_lua:nginx变量使用复杂lua return</li><li>rewrite_by_lua:重写url规则</li><li>access_by_lua:权限验证阶段</li><li>content_by_lua:内容输出节点</li></ol><h4 id="content-by-lua-内容输出节点"><a href="#content-by-lua-内容输出节点" class="headerlink" title="content_by_lua:内容输出节点"></a>content_by_lua:内容输出节点</h4><h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p>拦截url为<code>/staticitem/get</code>的请求</p><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>1.在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下新建staticitem.lua脚本</p><p>staticitem.lua</p><pre><code class="lua">ngx.say(&quot;hello static item lua&quot;);</code></pre><p>意思就是：</p><p>以HTTP response的形式返回字符串<code>&quot;hello static item lua&quot;</code></p><p>2.修改nginx.conf</p><pre><code>location /staticitem/get {content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/staticitem.lua;}</code></pre><h5 id="实验-2"><a href="#实验-2" class="headerlink" title="实验"></a>实验</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150905.png" alt="屏幕快照 2019-06-23 下午8.35.18"></p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>nginx可以拦截nginx.conf中的location请求，将url路由到我们配置lua脚本做相应的处理。比如上面的例子中nginx就可以将<code>/staticitem/get</code>请求对应到我们编写的taticitem.lua，最终向浏览器返回<code>hello static item lua</code></p><h3 id="OpenResty"><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h3><ul><li>OpenResty由Nginx核心+很多第三方模块组成，默认集成Lua开发环境，使得Nginx可以作为一个Web Server使用。</li><li>借助于Nginx的事件驱动模型和非阻塞IO，可以实现高性能的Web应用程序</li><li>OpenResty提供了大量组件如mysql、redis、memcached等等，使在nginx上开发Web应用程序更方便更简单</li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><ul><li>OpenResty hello world</li><li>shared dic:共享内存字典，所有进程可见，lru淘汰(替换到nginx自己的基于文件系统的proxy cache)</li><li>OpenResty对redis的支持</li></ul><h5 id="OpenResty-hello-world"><a href="#OpenResty-hello-world" class="headerlink" title="OpenResty hello world"></a>OpenResty hello world</h5><ol><li>在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下创建helloworld.lua脚本</li></ol><pre><code class="lua">ngx.exec(&quot;/item/get?id=6&quot;);</code></pre><ol start="2"><li><p>修改nginx.conf配置</p><pre><code>#openresty helloworldlocation /helloworld{content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/helloworld.lua;}</code></pre></li><li><p>实验</p></li></ol><p>输入<a href="http://localhost/helloworld" target="_blank" rel="noopener"><code>http://localhost/helloworld</code></a></p><p>显示：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150905.jpg" alt="11"></p><h5 id="shared-dic"><a href="#shared-dic" class="headerlink" title="shared dic"></a>shared dic</h5><ol><li><p>在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下创建itemshareddic.lua脚本</p><pre><code class="lua">function get_from_cache(key)        local cache_ngx=ngx.shared.my_cache        local value=cache_ngx:get(key)        return valueendfunction set_to_cache(key,value,exptime)        if not exptime then              exptime =0        end        local cache_ngx=ngx.shared.my_cache        local succ,err,forcible=cache_ngx:set(key,value,exptime)        return succendlocal args=ngx.req.get_uri_args();local id=args[&quot;id&quot;]local item_model=get_from_cache(&quot;item_&quot;..id);if item_model == nil then      local resp=ngx.location.capture(&quot;/item/get?id=&quot;..id)      item_model = resp.body      set_to_cache(&quot;item_&quot;..id,item_model,1*60)endngx.say(item_model)</code></pre></li><li><p>修改nginx.conf</p><pre><code>location /luaitem/get {default_type &quot;application/json&quot;;content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/itemshareddic.lua;}</code></pre></li><li><p>实验</p><p>输入<a href="http://localhost/luaitem/get?id=6" target="_blank" rel="noopener">http://localhost/luaitem/get?id=6</a></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150906.jpg" alt="实验图"></p></li></ol><h5 id="OpenResty对redis的支持"><a href="#OpenResty对redis的支持" class="headerlink" title="OpenResty对redis的支持"></a>OpenResty对redis的支持</h5><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150907.jpg" alt="openresty对redis支持"></p><ol><li><p>在<code>/usr/local/Cellar/openresty/1.15.8.1/lua/</code>目录下创建itemredi.lua脚本</p><pre><code class="lua">local args=ngx.req.get_uri_args()local id=args[&quot;id&quot;]local redis= require &quot;resty.redis&quot;local cache=redis:new()local ok,err= cache:connect(&quot;localhost&quot;,6379)local item_model=cache:get(&quot;item_&quot;..id)if item_model==ngx.null or item_model==nil then    local resp=ngx.location.capture(&quot;/item/get?id=&quot;..id)    item_model=resp.bodyendngx.say(item_model)</code></pre></li><li><p>修改nginx.conf</p><pre><code>location /luaitem/get {default_type &quot;application/json&quot;;content_by_lua_file /usr/local/Cellar/openresty/1.15.8.1/lua/itemredis.lua;}</code></pre></li><li><p>实验</p><p>输入<a href="http://localhost/luaitem/get?id=6" target="_blank" rel="noopener">http://localhost/luaitem/get?id=6</a></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150906.jpg" alt="实验图"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第4章 分布式扩展</title>
      <link href="/2019/06/16/miaosha/di-4-zhang-fen-bu-shi-kuo-zhan/"/>
      <url>/2019/06/16/miaosha/di-4-zhang-fen-bu-shi-kuo-zhan/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ul><li>nginx反向代理负载均衡</li><li>分布式会话管理</li><li>使用redis实现分布式会话存储</li></ul><a id="more"></a><p>单机部署结构：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150840.png" alt="未命名文件"></p><p>#nginx反向代理负载均衡</p><h2 id="单机容量问题，水平扩展"><a href="#单机容量问题，水平扩展" class="headerlink" title="单机容量问题，水平扩展"></a>单机容量问题，水平扩展</h2><p>表象：单机cpu使用率增高，memory占用增加，网络带宽使用增加</p><p>cpu us：用户空间的cpu使用情况(用户层代码)</p><p>cpu sy：内核空间的cpu使用情况(系统调用)</p><p>load average：1,5,15分钟load平均值，跟着核数系数（比如2核cpu，这个数字在2以下就是正常的），0代表通常，1代表打满，1+代表等待阻塞</p><p>memory：free空闲内存，used使用内存</p><h3 id="水平扩展方案"><a href="#水平扩展方案" class="headerlink" title="水平扩展方案"></a>水平扩展方案</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150853.png" alt="未命名文件-2"></p><p>我们需要4台服务器来完成上述的水平扩展，1台用于nginx，1台用户mysql，2台用于部署miaosha.jar(java Application)</p><h3 id="mysql数据库开放远端连接"><a href="#mysql数据库开放远端连接" class="headerlink" title="mysql数据库开放远端连接"></a>mysql数据库开放远端连接</h3><p>默认情况下，mysql帐号不允许从远程登陆，只能在localhost登录。</p><h4 id="添加用户权限"><a href="#添加用户权限" class="headerlink" title="添加用户权限"></a>添加用户权限</h4><ol><li>如果你想root使用123456（密码）从任何主机连接到mysql服务器的话。</li></ol><pre><code class="mysql">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; WITH GRANT OPTION;</code></pre><p>*.*：所有的databases和所有的表</p><p><strong>‘root’@’%’</strong>：用户名为root的用户，%：所有的host</p><p><strong>IDENTIFIED BY ‘123456’</strong>：但是必须知道密码：123456</p><ol start="2"><li>使修改生效，就可以了</li></ol><pre><code class="mysql">mysql&gt;FLUSH PRIVILEGES;</code></pre><h3 id="服务端水平对称部署"><a href="#服务端水平对称部署" class="headerlink" title="服务端水平对称部署"></a>服务端水平对称部署</h3><p>在2台服务器上分别部署miaosha.jar</p><h3 id="验证访问"><a href="#验证访问" class="headerlink" title="验证访问"></a>验证访问</h3><p><a href="http://202.117.35.220:8080/item/get?id=6" target="_blank" rel="noopener">http://202.117.35.220:8080/item/get?id=6</a></p><p>和</p><p><a href="http://202.117.35.221:8080/item/get?id=6" target="_blank" rel="noopener">http://202.117.35.221:8080/item/get?id=6</a></p><p>是否访问正常</p><h2 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h2><p>部署图：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><p>nginx主要有3种功能：</p><p>使用nginx做为web服务器</p><p>使用nginx作为动静分离服务器</p><p>使用nginx作为反向代理服务器</p><h3 id="修改前端资源"><a href="#修改前端资源" class="headerlink" title="修改前端资源"></a>修改前端资源</h3><p>在<code>htmlStable</code>目录下添加<code>gethost.js</code></p><pre><code class="js">var g_host = &quot;localhost:8090&quot;;</code></pre><p>在对应的前端代码也改了</p><p>如<code>getotp.html</code>中的</p><p>head标签中添加<code>gethost.js</code></p><pre><code class="html">&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;link href=&quot;static/assets/global/plugins/bootstrap/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;link href=&quot;static/assets/global/css/components.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;link href=&quot;static/assets/admin/pages/css/login.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;/&gt;&lt;script src=&quot;static/assets/global/plugins/jquery-1.11.0.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./gethost.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;&lt;/head&gt;</code></pre><p>ajax请求：</p><pre><code class="js">$.ajax({                type:&quot;POST&quot;,                contentType:&quot;application/x-www-form-urlencoded&quot;,                url:&quot;http://&quot;+g_host+&quot;/user/getotp&quot;,                data:{                    &quot;telphone&quot;:$(&quot;#telphone&quot;).val(),                },</code></pre><h3 id="安装openResty"><a href="#安装openResty" class="headerlink" title="安装openResty"></a>安装openResty</h3><ol><li>解压：</li></ol><pre><code class="bash">tar -xvzf openresty-1.13.6.2.tar.gz</code></pre><ol start="2"><li>由于是源码下载的方式，进行配置编译</li></ol><pre><code class="bash">#编译bash脚本./configure</code></pre><p>直接进行步骤2，会直接报错</p><pre><code class="bash">ERROR: failed to run command: make install TARGET_STRIP=@: CCDEBUG=-g XCFLAGS=&#39;-DLUAJIT_ENABLE_LUA52COMPAT -msse4.2&#39; CC=cc PREFIX=/usr/local/openresty/luajit DESTDIR=/Users/xuxinghua/java/项目/秒杀/Java电商秒杀系统深度优化 从容应对亿级流量挑战/工具包/openresty-1.13.6.2/build/luajit-root/</code></pre><p>在第二步前，安装前准备</p><pre><code class="bash">apt-get install libpcre3-dev \    libssl-dev perl make build-essential curl</code></pre><p>然后</p><pre><code class="bash">cd openresty-1.13.6.2/./configure</code></pre><ol start="3"><li>安装openResty</li></ol><p><strong>使用下面的命令来编译</strong></p><pre><code class="bash">make</code></pre><p>如果您的电脑支持多核 <code>make</code> 工作的特性, 您可以这样编译:</p><pre><code class="bash">make -j2</code></pre><p>假设您是的机器是双核。</p><p><strong>make install</strong></p><p>如果前面的步骤都没有问题的话,您可以使用下面的命令安装 <a href="http://openresty.org/cn/openresty.html" target="_blank" rel="noopener">OpenResty</a> 到您的系统中：</p><pre><code class="bash">make install</code></pre><h2 id="使用nginx做为web服务器"><a href="#使用nginx做为web服务器" class="headerlink" title="使用nginx做为web服务器"></a>使用nginx做为web服务器</h2><ul><li>location节点path：指定url映射key</li><li>location节点内容：root指定location path后对应的根路径，index指定默认的访问页</li><li>==sbin/nginx -c conf/nginx.conf启动==</li><li>==修改配置后直接sbin/nginx -s reload无缝重启==</li></ul><h4 id="linux启动nginx"><a href="#linux启动nginx" class="headerlink" title="linux启动nginx"></a>linux启动nginx</h4><pre><code class="bash">sbin/nginx -c conf/nginx.conf</code></pre><p>查看nignx进程</p><pre><code class="bash">ps -ef|grep nginx</code></pre><p>查看80端口是否被占用</p><pre><code class="bash">netstat -an |grep 80</code></pre><h4 id="mac上启动nginx"><a href="#mac上启动nginx" class="headerlink" title="mac上启动nginx"></a>mac上启动nginx</h4><p>由于使用homebrew安装openResty</p><pre><code class="bash">xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin sudo ./nginx</code></pre><h3 id="前端资源的部署"><a href="#前端资源的部署" class="headerlink" title="前端资源的部署"></a>前端资源的部署</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><h4 id="更改文件读写权限"><a href="#更改文件读写权限" class="headerlink" title="更改文件读写权限"></a>更改文件读写权限</h4><pre><code class="bash">sudo chmod 777 需要写入的文件名</code></pre><p>例子：</p><p>需要将 <code>~/java/项目/秒杀/Java电商秒杀系统深度优化 从容应对亿级流量挑战/源码/第四章.分布式扩展/htmlStable</code>目录下的前端资源传输到<code>202.117.35.221</code>服务器上</p><pre><code class="bash">scp -r * hpms@202.117.35.221:/usr/local/openresty/nginx/html</code></pre><p>出现错误：</p><pre><code class="bash">scp 文件 : /目录: Permission denied </code></pre><p>解决方法：</p><p>进入<code>/usr/local/openresty/nginx</code>赋予<code>html</code>文件夹权限</p><pre><code class="bash">sudo chmod 777 html</code></pre><p><strong>将当前目录下的所有文件及子目录的文件拥有者权限设置为读、写、可执行，文件拥有者所在的用户组成员具备读、写、可执行权限，其它用户也具备读、写、可执行权限</strong></p><h4 id="nginx-config文件"><a href="#nginx-config文件" class="headerlink" title="nginx.config文件"></a>nginx.config文件</h4><pre><code class="bash">#user  nobody;worker_processes  1;#1个工作进程#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {    worker_connections  1024;#可以接受工作连接1024个}http {    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    #keepalive_timeout  0;    keepalive_timeout  65;#http请求的客户端和nginx服务端连接timeout    #gzip  on;    server {        listen       80;#服务端口        server_name  localhost;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location /         # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000        #        #location ~ \.php$ {        #    root           html;        #    fastcgi_pass   127.0.0.1:9000;        #    fastcgi_index  index.php;        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;        #    include        fastcgi_params;        #}        # deny access to .htaccess files, if Apache&#39;s document root        # concurs with nginx&#39;s one        #        #location ~ /\.ht {        #    deny  all;        #}    }    # another virtual host using mix of IP-, name-, and port-based configuration    #    #server {    #    listen       8000;    #    listen       somename:8080;    #    server_name  somename  alias  another.alias;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}    # HTTPS server    #    #server {    #    listen       443 ssl;    #    server_name  localhost;    #    ssl_certificate      cert.pem;    #    ssl_certificate_key  cert.key;    #    ssl_session_cache    shared:SSL:1m;    #    ssl_session_timeout  5m;    #    ssl_ciphers  HIGH:!aNULL:!MD5;    #    ssl_prefer_server_ciphers  on;    #    location / {    #        root   html;    #        index  index.html index.htm;    #    }    #}}</code></pre><h4 id="使用openresty登录前端"><a href="#使用openresty登录前端" class="headerlink" title="使用openresty登录前端"></a>使用openresty登录前端</h4><p>比如访问login.html页面</p><p>在浏览器上输入：</p><p><a href="http://202.117.35.221:80/login.html" target="_blank" rel="noopener">http://202.117.35.221:80/login.html</a></p><p><code>nginx.config</code>中设置的<code>root</code>是<code>html</code></p><p>所以在地址后面加上html目录下的html文件名，openresty会直接映射到服务端/usr/local/openresty/nginx/html目录下，找相应的html文件</p><h3 id="前端资源路由"><a href="#前端资源路由" class="headerlink" title="前端资源路由"></a>前端资源路由</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><h4 id="1-修改nginx-config"><a href="#1-修改nginx-config" class="headerlink" title="1 修改nginx.config"></a>1 修改nginx.config</h4><pre><code>location /resources/ {            alias /usr/local/openresty/nginx/html/resources/;            index  index.html index.htm;        }</code></pre><h4 id="2-转移前端资源到resources目录下"><a href="#2-转移前端资源到resources目录下" class="headerlink" title="2 转移前端资源到resources目录下"></a>2 转移前端资源到resources目录下</h4><p>将<code>/usr/local/openresty/nginx/html/</code>目录下的文件转移到<code>/usr/local/openresty/nginx/html/resources/</code>目录下:</p><p>转移前<code>html</code>目录下：</p><pre><code class="bash">-rw-r--r-- 1 root root  541  6月 17 10:13 50x.html-rwxr-xr-x 1 hpms hpms 3093  6月 18 11:17 createitem.html*-rwxr-xr-x 1 hpms hpms   36  6月 18 11:22 gethost.js*-rwxr-xr-x 1 hpms hpms 5185  6月 18 11:17 getitem.html*-rwxr-xr-x 1 hpms hpms 1880  6月 18 11:17 getotp.html*-rw-r--r-- 1 root root  649  6月 17 10:13 index.html-rwxr-xr-x 1 hpms hpms 1976  6月 18 11:17 listitem.html*-rwxr-xr-x 1 hpms hpms 2354  6月 18 11:17 login.html*-rwxr-xr-x 1 hpms hpms 3496  6月 18 11:17 register.html*drwxr-xr-x 8 hpms hpms 4096  6月 18 11:18 static/</code></pre><p>使用mv命令</p><pre><code class="bash">hpms@hpms-1:/usr/local/openresty/nginx$ mkdir resourceshpms@hpms-1:/usr/local/openresty/nginx$ mv *.html resources/hpms@hpms-1:/usr/local/openresty/nginx$ mv gethost.js resources/#转移static/目录hpms@hpms-1:/usr/local/openresty/nginx$ mv static resources/</code></pre><h4 id="3-无缝重启nginx"><a href="#3-无缝重启nginx" class="headerlink" title="3 无缝重启nginx"></a>3 无缝重启nginx</h4><pre><code class="bash">hpms@hpms-1:/usr/local/openresty/nginx$ sbin/nginx -s reload</code></pre><h2 id="使用nginx作为动静分离服务器"><a href="#使用nginx作为动静分离服务器" class="headerlink" title="使用nginx作为动静分离服务器"></a>使用nginx作为动静分离服务器</h2><p>location节点path热定resources：静态资源路径</p><p>location节点其他路径：动态资源用</p><p>修改<code>nginx.config</code>中</p><h3 id="静态请求"><a href="#静态请求" class="headerlink" title="静态请求"></a>静态请求</h3><p>设置了静态资源访问路径：</p><p>即当服务器发来的url:<code>nginx服务器的IP地址/resources/</code>，比如<code>115.154.255.245/resources/</code> ，nginx会访问.<code>/nginx/html/resources/</code>下的静态页面</p><pre><code class="bash">location /resources/ {            alias /usr/local/openresty/nginx/html/resources/;            index  index.html index.htm;        }</code></pre><h3 id="动态请求"><a href="#动态请求" class="headerlink" title="动态请求"></a>动态请求</h3><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host &amp;http_host:8090;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}</code></pre><p>当从用户浏览器传来的URL:<code>nginx服务器的IP地址/</code>，如<code>115.154.255.245/user/get?id=6</code>,会把请求分发到后端部署了<code>miaosha.jar</code>的服务器上处理</p><h2 id="使用nginx作为反向代理服务器"><a href="#使用nginx作为反向代理服务器" class="headerlink" title="使用nginx作为反向代理服务器"></a>使用nginx作为反向代理服务器</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><h3 id="设置upstream-server"><a href="#设置upstream-server" class="headerlink" title="设置upstream server"></a>设置upstream server</h3><p>视频上：</p><pre><code class="bash">upstream backend_server{server 202.117.35.220 weight=1;server 202.117.35.221 weight=1;}</code></pre><p>跟着视频上的步骤行不通，于是上网查了资料，很纳闷，逻辑都正确，弄了一下午的时间</p><p>最后终于正确了。</p><p>正确的：</p><pre><code class="bash">upstream backend_server{     server 202.117.35.220:8090 weight=1;     server 202.117.35.221:8090 weight=1;}</code></pre><h3 id="设置动态请求location为proxy-pass路径"><a href="#设置动态请求location为proxy-pass路径" class="headerlink" title="设置动态请求location为proxy pass路径"></a>设置动态请求location为proxy pass路径</h3><p>视频上：</p><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host $http_host:$proxy_port;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}</code></pre><p>正确的</p><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;}</code></pre><h3 id="血的教训"><a href="#血的教训" class="headerlink" title="血的教训"></a>血的教训</h3><p>以后配环境一定要看清楚符号</p><p>比如正确的应该是<code>$host</code>是<code>$</code>，而我打成了<code>&amp;host</code>，郁闷了，整了一个下午。</p><p>error.log里面显示的端口一直是默认的：80</p><h3 id="开启Tomcat-access-log-验证"><a href="#开启Tomcat-access-log-验证" class="headerlink" title="开启Tomcat access log 验证"></a>开启Tomcat access log 验证</h3><p><code>application.properties</code>中修改</p><pre><code class="bash">server.tomcat.accesslog.enabled=trueserver.tomcat.accesslog.directory=/home/hpms/xxh009/miaosha/tomcatserver.tomcat.accesslog.pattern=%h %l %u %t &quot;%r&quot; %s %b %D</code></pre><pre><code class="properties">%h:远端host，ip地址%l:--%u:remote user%t:处理时长&quot;%r&quot;:对应http请求的第一行%s:http返回状态码%b:请求response的大小%D:处理请求的时长</code></pre><p>创建好后，<code>/home/hpms/xxh009/miaosha/tomcat</code>目录下会产生log文件，比如<code>access_log.2019-06-18.log</code></p><p>当有请求来时，<code>/home/hpms/xxh009/miaosha/tomcat/access_log.2019-06-18.log</code>文件内会出现：</p><pre><code class="bash">115.154.255.245 - - [18/Jun/2019:21:35:22 +0800] &quot;GET /item/get?id=6 HTTP/1.0&quot; 200 316 732</code></pre><pre><code class="properties">115.154.255.245:host 其实就是反向代理发过来的%l:--&quot;%r&quot;:&quot;GET /item/get?id=6 HTTP/1.0&quot;状态码:200发送了316个字节使用了732ms</code></pre><h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><p>设置weight=1，nginx会轮询2个ip地址上的<code>miaosha.jar</code>服务</p><pre><code class="bash">upstream backend_server{     server 202.117.35.220:8090 weight=1;     server 202.117.35.221:8090 weight=1;}</code></pre><h2 id="分布式扩展后性能压测"><a href="#分布式扩展后性能压测" class="headerlink" title="分布式扩展后性能压测"></a>分布式扩展后性能压测</h2><p><code>nginx</code>和<code>miaosha.jar</code>服务器之间默认的是短连接，可以开启nginx的keepalive模式，进一步提升性能</p><h3 id="nginx和upstream后端服务器建立keep-alive长连接"><a href="#nginx和upstream后端服务器建立keep-alive长连接" class="headerlink" title="nginx和upstream后端服务器建立keep-alive长连接"></a>nginx和upstream后端服务器建立keep-alive长连接</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>使用长连接解决分布式扩展后nginx服务器和upstream后端服务器网络建联的消耗</p><h4 id="为什么nginx和后端服务器upstream默认是短连接呢？"><a href="#为什么nginx和后端服务器upstream默认是短连接呢？" class="headerlink" title="为什么nginx和后端服务器upstream默认是短连接呢？"></a>为什么nginx和后端服务器upstream默认是短连接呢？</h4><p>那是因为nginx和后端服务器默认使用的是<code>HTTP1.0</code>的协议，默认的<code>HTTP1.0</code>协议默认是不支持keepalive的，需要默认设置<code>connection:keep-alive</code>.</p><p>我们设置反向代理层往后端服务器发送使用<code>HTTP1.1</code>的协议</p><pre><code class="bash">location / {proxy_pass http://backend_server;proxy_set_header Host $host;proxy_set_header X-Real-IP $remote_addr;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;proxy_http_version 1.1;proxy_set_header Connection &quot;&quot;;}</code></pre><h3 id="后端服务器和数据库"><a href="#后端服务器和数据库" class="headerlink" title="后端服务器和数据库"></a>后端服务器和数据库</h3><p>使用miaoshaserver自带的Druid数据库的连接池解决了跟数据源之间的建联消耗</p><h1 id="nginx高性能原因"><a href="#nginx高性能原因" class="headerlink" title="nginx高性能原因"></a>nginx高性能原因</h1><h2 id="epoll多路复用"><a href="#epoll多路复用" class="headerlink" title="epoll多路复用"></a>epoll多路复用</h2><p>java BIO模型：阻塞进程式</p><p>linux select模型，变更触发轮询查找，有1024数量上限</p><p>epoll模型，变更触发回调直接读取，理论上没有上限</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150858.png" alt="未命名文件-4"></p><h2 id="master-worker进程模型"><a href="#master-worker进程模型" class="headerlink" title="master-worker进程模型"></a>master-worker进程模型</h2><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150859.png" alt="屏幕快照 2019-06-19 下午3.16.29"></p><h3 id="图形介绍"><a href="#图形介绍" class="headerlink" title="图形介绍"></a>图形介绍</h3><p>管理员：可以理解为root操作用户，用于启动和管理nginx进程</p><p>信号：启动nginx，<code>sbin/nginx -c conf/nginx.conf</code></p><p>master根据nignx.congif中的<code>worker_processes  1;</code>fork出worker进程，它们主子进程的关系</p><p>work进程才是真正处理和客户端连接的</p><h3 id="平滑重启"><a href="#平滑重启" class="headerlink" title="平滑重启"></a>平滑重启</h3><pre><code class="bash">sbin/nginx -s reload</code></pre><p>一般修改完配置文件，重启服务都会断开原本和socket的连接，也就是断开服务</p><h4 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h4><pre><code class="bash"> xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin ps -ef|grep nginx    0 22467     1   0  8:58PM ??         0:00.05 nginx: master process ./nginx   -2 23614 22467   0 12:48PM ??         0:21.92 nginx: worker process  501 24958 23250   0  4:08PM ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn nginx xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin sudo ./nginx -s reloadPassword: xuxinghua@xxhdemac/usr/local/Cellar/openresty/1.15.8.1/nginx/sbin ps -ef|grep nginx    0 22467     1   0  8:58PM ??         0:00.06 nginx: master process ./nginx   -2 24971 22467   0  4:08PM ??         0:00.00 nginx: worker process  501 24981 23250   0  4:08PM ttys001    0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn nginx</code></pre><p>可以看到，<code>master process</code>进程号2次都没变，都是<code>22467</code>，而<code>worker process</code>一次是<code>23614</code>，一次是<code>24971</code></p><p>补充：</p><p>每个<code>worker process</code>中都是单线程，执行没有阻塞的任务</p><h2 id="协程机制"><a href="#协程机制" class="headerlink" title="协程机制"></a>协程机制</h2><p>比线程更小的内存模型，一个线程可以有多个协程；没有线程CPU的切换开销，只有内存的切换开销</p><ul><li>依附于线程的内存模型，切换开销小</li><li>遇阻塞及归还执行权，代码同步</li><li>无需加锁</li></ul><h1 id="分布式会话管理"><a href="#分布式会话管理" class="headerlink" title="分布式会话管理"></a>分布式会话管理</h1><h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><p>基于cookie传输sessionid：java tomcat容器session实现</p><p>基于token传输类似sessionid：java代码session实现</p><h3 id="基于cookie传输sessionid"><a href="#基于cookie传输sessionid" class="headerlink" title="基于cookie传输sessionid"></a>基于cookie传输sessionid</h3><p>目前实现的秒杀是通过cookie传输sessionid的，springboot中的Tomcat帮我师兄了session</p><p>比如：在浏览器上输入 <a href="http://localhost/user/get?id=23" target="_blank" rel="noopener">http://localhost/user/get?id=23</a> 对应的请求头 <code>Request Header</code>中会有cookie</p><pre><code class="properties">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cache-Control: max-age=0Connection: keep-aliveCookie: Hm_lvt_512065947708a980c982b4401d14c2f5=1551084094; JSESSIONID=3C16C7B4DB293A1F56D3EB3C8A3FFACDHost: localhostUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36</code></pre><p>JSESSIONID其实就是Tomcat返回的内置cookie的标识，JSESSIONID对应到Tomcat内就是来获取对应用户的session的</p><h3 id="基于token传输类似sessionid"><a href="#基于token传输类似sessionid" class="headerlink" title="基于token传输类似sessionid"></a>基于token传输类似sessionid</h3><p>移动手机端常用</p><h2 id="分布式会话"><a href="#分布式会话" class="headerlink" title="分布式会话"></a>分布式会话</h2><h3 id="会话管理出现的问题分析"><a href="#会话管理出现的问题分析" class="headerlink" title="会话管理出现的问题分析"></a>会话管理出现的问题分析</h3><p>基于分布式会话，上面<code>基于cookie传输sessionid</code>和<code>基于token传输类似sessionid</code>都是不能生效的。</p><p>来看看部署结构图：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150854.png" alt="未命名文件-3"></p><p>因为上述两种策略都是在；单机的内存当中，</p><p>基于cookie传输sessionid：基于的是Springboot内嵌的Tomcat容器实现的，是居于内存，只在单机上起作用</p><p>基于token传输类似sessionid：基于java代码的，也是在内存里，只在单机上起作用</p><p>那么问题来了，如果一个用户登录请求通过<code>nginx</code>转发到了第一个<code>miaosha.jar</code>的服务器上，该服务器的sessionid存于内存中，当用户再发送一个其他请求，nginx把请求路由到第二个<code>miaosha.jar</code>的服务器上，由于2个服务器sessionid都在内存中，不能共享，所以会出现问题。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>1.用户登录</p><pre><code>http://localhost/resources/login.html</code></pre><p>2.到商品详情页下单</p><pre><code>http://localhost/resources/listitem.html</code></pre><p>3.下单</p><pre><code>提示:下单失败，原因为用户还未登陆，不能下单</code></pre><h1 id="使用redis解决分布式session管理"><a href="#使用redis解决分布式session管理" class="headerlink" title="使用redis解决分布式session管理"></a>使用redis解决分布式session管理</h1><ul><li>基于cookie传输sessionid：java Tomcat容器session实现迁移到redis</li><li>基于token传输类似sessionid：java代码session实现迁移到redis</li></ul><h2 id="1-基于cookie传输sessionid"><a href="#1-基于cookie传输sessionid" class="headerlink" title="1 基于cookie传输sessionid"></a>1 基于cookie传输sessionid</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><pre><code class="xml">&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;      &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;      &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;</code></pre><p>修改application.properties</p><pre><code class="properties">#配置Springboot对redis的依赖spring.redis.host=202.117.35.220spring.redis.port=6379#默认有16个database，可以用 select 10 来切换databasesspring.redis.database=10#设置jedis连接池spring.redis.jedis.pool.max-active=50spring.redis.jedis.pool.min-idle=20</code></pre><h3 id="序列化错误"><a href="#序列化错误" class="headerlink" title="序列化错误"></a>序列化错误</h3><pre><code>org.springframework.data.redis.serializer.SerializationException: Cannot serialize; nested exception is org.springframework.core.serializer.support.SerializationFailedException: Failed to serialize object using DefaultSerializer; nested exception is java.lang.IllegalArgumentException: DefaultSerializer requires a Serializable payload but received an object of type [com.imooc.miaoshaproject.service.model.UserModel]</code></pre><p>原因：UserModel类没有序列化</p><p>解决方法1：</p><pre><code class="java">public class UserModel implements Serializable</code></pre><p>解决方法2：更好的方案</p><p>修改redis默认的序列化方式，改成使用JSON的序列化方式，这是跨系统当中最最好的。</p><h3 id="登录验证"><a href="#登录验证" class="headerlink" title="登录验证"></a>登录验证</h3><p>登录成功后，<code>spring.redis.host=202.117.35.220</code>上的redis-server会存有session信息</p><pre><code class="bash">202.117.35.220:6379&gt; SELECT 10202.117.35.220:6379[10]&gt; KEYS *1) &quot;spring:session:sessions:expires:2b321bc8-141a-402b-8545-d6d034b58cca&quot;2) &quot;spring:session:sessions:2b321bc8-141a-402b-8545-d6d034b58cca&quot;3) &quot;spring:session:expirations:1560949920000&quot;</code></pre><p><strong>注意：</strong></p><p>这里有个小插曲，因为<code>application.properties</code>中<code>spring.redis.database=10</code></p><p>因为默认的<code>database=0</code>，所以要先select下</p><h2 id="2-基于token传输类似sessionid"><a href="#2-基于token传输类似sessionid" class="headerlink" title="2 基于token传输类似sessionid"></a>2 基于token传输类似sessionid</h2><p>更符合现代互联网，不光支持电脑，还支持手机等各种移动端。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>UserController：</p><pre><code class="java">//用户登陆接口    @RequestMapping(value = &quot;/login&quot;,method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})    @ResponseBody    public CommonReturnType login(@RequestParam(name=&quot;telphone&quot;)String telphone,                                  @RequestParam(name=&quot;password&quot;)String password) throws BusinessException, UnsupportedEncodingException, NoSuchAlgorithmException {        //入参校验        if(org.apache.commons.lang3.StringUtils.isEmpty(telphone)||                StringUtils.isEmpty(password)){            throw new BusinessException(EmBusinessError.PARAMETER_VALIDATION_ERROR);        }        //用户登陆服务,用来校验用户登陆是否合法        UserModel userModel = userService.validateLogin(telphone,this.EncodeByMd5(password));//传入的encrptPassword是MD5加密后的        //方法2：基于token传输类似sessionid        //修改成若用户登录验证成功，将对应的登录信息和登录凭证一起存入redis中        //生成登录凭证token，采用UUID，保证唯一性        String uuidToken=UUID.randomUUID().toString();        uuidToken=uuidToken.replace(&quot;-&quot;,&quot;&quot;);        //建立token和用户登录状态之间的联系        redisTemplate.opsForValue().set(uuidToken,userModel);        //设置超时时间,一小时        redisTemplate.expire(uuidToken,1, TimeUnit.HOURS);        //下发token        return CommonReturnType.create(uuidToken);    }</code></pre><p>OrderController：</p><pre><code class="java">//封装下单请求    @RequestMapping(value = &quot;/createorder&quot;,method = {RequestMethod.POST},consumes={CONTENT_TYPE_FORMED})    @ResponseBody    public CommonReturnType createOrder(@RequestParam(name=&quot;itemId&quot;)Integer itemId,                                        @RequestParam(name=&quot;amount&quot;)Integer amount,                                        @RequestParam(name=&quot;promoId&quot;,required = false)Integer promoId) throws BusinessException {        //Boolean isLogin = (Boolean) httpServletRequest.getSession().getAttribute(&quot;IS_LOGIN&quot;);        //为什么要getParameterMap()，因为前端getitem.html中传来的url:&quot;http://&quot;+g_host+&quot;/order/createorder?token=&quot;+token,        String token =httpServletRequest.getParameterMap().get(&quot;token&quot;)[0];        if (StringUtils.isEmpty(token)){            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,&quot;用户还未登陆，不能下单&quot;);        }        //获取用户的登陆信息        UserModel userModel= (UserModel) redisTemplate.opsForValue().get(token);        if (userModel==null){            throw new BusinessException(EmBusinessError.USER_NOT_LOGIN,&quot;token不存在&quot;);        }        OrderModel orderModel = orderService.createOrder(userModel.getId(),itemId,promoId,amount);        return CommonReturnType.create(null);    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第3章 云端部署 性能压测</title>
      <link href="/2019/06/14/miaosha/di-3-zhang-yun-duan-bu-shu-xing-neng-ya-ce/"/>
      <url>/2019/06/14/miaosha/di-3-zhang-yun-duan-bu-shu-xing-neng-ya-ce/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><a id="more"></a><h1 id="私有部署"><a href="#私有部署" class="headerlink" title="私有部署"></a>私有部署</h1><p>就是本地的私有化部署，在本机上调试程序，运行成功在本地打包部署云端。</p><h2 id="操作系统及运行环境"><a href="#操作系统及运行环境" class="headerlink" title="操作系统及运行环境"></a>操作系统及运行环境</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="应用程序"><a href="#应用程序" class="headerlink" title="应用程序"></a>应用程序</h2><h1 id="项目云端部署"><a href="#项目云端部署" class="headerlink" title="项目云端部署"></a>项目云端部署</h1><h2 id="操作系统及运行环境-1"><a href="#操作系统及运行环境-1" class="headerlink" title="操作系统及运行环境"></a>操作系统及运行环境</h2><p>阿里云centos虚拟机(ECS服务器)</p><h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><h3 id="本地备份"><a href="#本地备份" class="headerlink" title="本地备份"></a>本地备份</h3><pre><code class="bash">mysqldump -uroot -pxxh171015 --databases miaoshaproject &gt;~/Downloads/miaosha.sql</code></pre><p>会在 /Downloads 目录下生成 miaosha.sql </p><h3 id="上传到服务器上"><a href="#上传到服务器上" class="headerlink" title="上传到服务器上"></a>上传到服务器上</h3><pre><code class="bash">scp ~/Downloads/miaosha.sql hpms@202.117.35.221:/home/hpms/xxh009</code></pre><h3 id="在服务器端恢复"><a href="#在服务器端恢复" class="headerlink" title="在服务器端恢复"></a>在服务器端恢复</h3><pre><code class="bash">cd ~mysql -uroot -p123456 &lt;xxh009/miaosha.sql</code></pre><h2 id="应用程序-1"><a href="#应用程序-1" class="headerlink" title="应用程序"></a>应用程序</h2><h3 id="maven打包"><a href="#maven打包" class="headerlink" title="maven打包"></a>maven打包</h3><pre><code class="xml">&lt;plugin&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;&lt;/plugin&gt;</code></pre><pre><code class="bash">mvn clean package</code></pre><h3 id="应用程序的jar上传到服务器"><a href="#应用程序的jar上传到服务器" class="headerlink" title="应用程序的jar上传到服务器"></a>应用程序的jar上传到服务器</h3><pre><code class="bash">scp miaosha-1.0-SNAPSHOT.jar  hpms@202.117.35.221:/home/hpms/xxh009</code></pre><h2 id="外挂配置文件"><a href="#外挂配置文件" class="headerlink" title="外挂配置文件"></a>外挂配置文件</h2><p>加载项目外的application.properties</p><p>在项目目录下，新建application.properties文件</p><pre><code class="bash">vi application.properties</code></pre><p>项目目录下运行：</p><pre><code class="bash">java -jar miaosha-1.0-SNAPSHOT.jar --spring.config.addition-location=application.properties</code></pre><h2 id="编写deploy脚本启动"><a href="#编写deploy脚本启动" class="headerlink" title="编写deploy脚本启动"></a>编写deploy脚本启动</h2><pre><code class="bash">##编写脚本vi deploy.sh##运行脚本前赋权限chmod -R 777 *##运行脚本./deploy.sh &amp;</code></pre><h3 id="如何关闭"><a href="#如何关闭" class="headerlink" title="如何关闭"></a>如何关闭</h3><pre><code class="bash">##查看应用该端口的程序，显示的是这个端口号那个进程在使用lsof -i:$PORT##关掉对应的应用程序sudo kill -9 PID</code></pre><h1 id="jmeter性能压测"><a href="#jmeter性能压测" class="headerlink" title="jmeter性能压测"></a>jmeter性能压测</h1><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><h2 id="查看结果树"><a href="#查看结果树" class="headerlink" title="查看结果树"></a>查看结果树</h2><h2 id="聚合报告"><a href="#聚合报告" class="headerlink" title="聚合报告"></a>聚合报告</h2><h1 id="如何发现系统瓶颈问题"><a href="#如何发现系统瓶颈问题" class="headerlink" title="如何发现系统瓶颈问题"></a>如何发现系统瓶颈问题</h1><h2 id="发现容量问题"><a href="#发现容量问题" class="headerlink" title="发现容量问题"></a>发现容量问题</h2><h3 id="server端并发线程数上不去"><a href="#server端并发线程数上不去" class="headerlink" title="server端并发线程数上不去"></a>server端并发线程数上不去</h3><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ ps -ef | grep javahpms     17623 17622  4 20:59 pts/13   00:00:45 java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addition-location=~/xxh009/miaosha/application.propertieshpms     17914 15396  0 21:15 pts/13   00:00:00 grep --color=auto java##可以看17623这个进程上面对应有多少个线程hpms@hpms-1:~/xxh009/miaosha$ pstree -p 17623java(17623)─┬─{java}(17624)            ├─{java}(17625)            ├─{java}(17626)            ├─{java}(17627)            ├─{java}(17628)            ├─{java}(17629)            ├─{java}(17630)            ├─{java}(17631)            ├─{java}(17632)            ├─{java}(17633)            ├─{java}(17634)            ├─{java}(17635)            ├─{java}(17636)            ├─{java}(17637)            ├─{java}(17638)            ├─{java}(17639)            ├─{java}(17640)            ├─{java}(17641)            ├─{java}(17642)            ├─{java}(17643)            ├─{java}(17644)            ├─{java}(17645)            ├─{java}(17646)            ├─{java}(17647)            ├─{java}(17648)            ├─{java}(17649)            ├─{java}(17650)            ├─{java}(17651)            ├─{java}(17652)            ├─{java}(17653)            ├─{java}(17654)            ├─{java}(17655)            ├─{java}(17660)            ├─{java}(17661)            ├─{java}(17662)            ├─{java}(17663)            ├─{java}(17664)            ├─{java}(17665)            ├─{java}(17666)            ├─{java}(17667)            ├─{java}(17668)            ├─{java}(17669)            ├─{java}(17670)            ├─{java}(17671)            ├─{java}(17672)            ├─{java}(17673)            ├─{java}(17674)            ├─{java}(17675)            ├─{java}(17676)            ├─{java}(17682)            ├─{java}(17683)            └─{java}(17684)##tomcat服务器在没有丝毫压力的情况下内部维护了52个线程hpms@hpms-1:~/xxh009/miaosha$ pstree -p 17623 | wc -l52</code></pre><h4 id="查看SpringBoot配置"><a href="#查看SpringBoot配置" class="headerlink" title="查看SpringBoot配置"></a>查看SpringBoot配置</h4><p>spring-configuration-metadata.json文件下</p><pre><code class="json">{      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 100,      &quot;name&quot;: &quot;server.tomcat.accept-count&quot;,      &quot;description&quot;: &quot;Maximum queue length for incoming connection requests when all possible request processing threads are in use.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    },  {    &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 10000,      &quot;name&quot;: &quot;server.tomcat.max-connections&quot;,      &quot;description&quot;: &quot;Maximum number of connections that the server accepts and processes at any given time. Once the limit has been reached, the operating system may still accept connections based on the \&quot;acceptCount\&quot; property.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    },{      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 200,      &quot;name&quot;: &quot;server.tomcat.max-threads&quot;,      &quot;description&quot;: &quot;Maximum number of worker threads.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    },{      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties$Tomcat&quot;,      &quot;defaultValue&quot;: 10,      &quot;name&quot;: &quot;server.tomcat.min-spare-threads&quot;,      &quot;description&quot;: &quot;Minimum number of worker threads.&quot;,      &quot;type&quot;: &quot;java.lang.Integer&quot;    }</code></pre><p>查看各个节点的配置</p><pre><code class="properties">server.tomcat.accept-count:等待队列长度，默认100server.tomcat.max-connections:最大可被连接数，默认10000server.tomcat.max-threads:最大工作线程数，默认200server.tomcat.min-spare-threads:最小工作线程数，默认10默认配置下，连接超过 10000 后出现拒绝连接情况默认配置下，并发的请求数量超过 200（max-threads）+ 100（accept-count）后拒绝处理</code></pre><p>当对应的所有的工作线程全部用完后，tomcat会将之后的请求丢到 accept-count 这个等待队列中，当等待队列还被塞满，对应的请求会被拒绝</p><h4 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h4><p>4核8G内存tomcat的最大线程数是：800</p><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ cat application.propertiesserver.port=8080server.tomcat.accept-count=1000server.tomcat.max-threads=800server.tomcat.min-spare-threads=100</code></pre><p>再次查看java进程PID</p><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ ps -ef |grep javahpms     18945 18944 92 22:18 pts/13   00:00:39 java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addition-location=~/xxh009/miaosha/application.propertieshpms@hpms-1:~/xxh009/miaosha$ pstree -p 18945|wc -l139</code></pre><p>上面我们可以看到是52</p><p>当再次压测时</p><pre><code>线程数：2000Rame-up时间：10循环次数：100</code></pre><p>此时</p><p>服务端</p><pre><code class="bash">hpms@hpms-1:~/xxh009/miaosha$ pstree -p 18945|wc -l842</code></pre><h4 id="定制化内嵌Tomcat开发"><a href="#定制化内嵌Tomcat开发" class="headerlink" title="定制化内嵌Tomcat开发"></a>定制化内嵌Tomcat开发</h4><p>关注参数:</p><p>keepAliveTimeOut:多少毫秒后不响应断开keepalive</p><p>maxKeepAliveRequests:多少次请求后keepalive断开失效</p><p>使用WebServerFactoryCustomizer&lt; ConfigurableServletWebServer &gt;定制化内嵌tomc配置</p><h3 id="响应时间变长-TPS上不去"><a href="#响应时间变长-TPS上不去" class="headerlink" title="响应时间变长 TPS上不去"></a>响应时间变长 TPS上不去</h3><h4 id="单Web容器上限"><a href="#单Web容器上限" class="headerlink" title="单Web容器上限"></a>单Web容器上限</h4><p>线程数量： 4核CPU 8G内存单进程调度线程数800-1000以上，后即花费巨大的时间CPU调度上</p><p>等待队列的长度：队列做缓冲池，但也不能无限长，消耗内存，出入队也耗CPU</p><h4 id="MySql数据库QPS容量问题"><a href="#MySql数据库QPS容量问题" class="headerlink" title="MySql数据库QPS容量问题"></a>MySql数据库QPS容量问题</h4><p>主键查询：千万级别数据=1-10毫秒</p><p>唯一索引查询：千万级别数据=10-100毫秒</p><p>非唯一索引查询：千万级别数据=100-1000毫秒</p><p>无索引：百万级别数据=1000毫秒+    (全表扫描)</p><h4 id="MySql数据库TPS容量问题"><a href="#MySql数据库TPS容量问题" class="headerlink" title="MySql数据库TPS容量问题"></a>MySql数据库TPS容量问题</h4><p>非插入更新删除操作：同查询</p><p>插入操作：1W~10w tps</p>]]></content>
      
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 秒杀项目框架回顾</title>
      <link href="/2019/06/12/miaosha/di-2-zhang-miao-sha-xiang-mu-kuang-jia-hui-gu/"/>
      <url>/2019/06/12/miaosha/di-2-zhang-miao-sha-xiang-mu-kuang-jia-hui-gu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="秒杀系统的框架"><a href="#秒杀系统的框架" class="headerlink" title="秒杀系统的框架"></a>秒杀系统的框架</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150917.png" alt="屏幕快照 2019-06-13 下午8.23.37"></p><h1 id="层与层之间的交互方式"><a href="#层与层之间的交互方式" class="headerlink" title="层与层之间的交互方式"></a>层与层之间的交互方式</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150918.png" alt="屏幕快照 2019-06-13 下午11.57.01"></p><h2 id="Data-Obiect和Domain-Model"><a href="#Data-Obiect和Domain-Model" class="headerlink" title="Data Obiect和Domain Model"></a>Data Obiect和Domain Model</h2><p>比如我们需要刻画的用户，</p><h3 id="在业务层的Domain-Model中"><a href="#在业务层的Domain-Model中" class="headerlink" title="在业务层的Domain Model中"></a>在业务层的Domain Model中</h3><p>UserModel的属性</p><pre><code class="java">private Integer id;    @NotBlank(message = &quot;用户名不能为空&quot;)    private String name;    @NotNull(message = &quot;性别不能不填写&quot;)    private Byte gender;    @NotNull(message = &quot;年龄不能不填写&quot;)    @Min(value = 0,message = &quot;年龄必须大于0岁&quot;)    @Max(value = 150,message = &quot;年龄必须小于150岁&quot;)    private Integer age;    @NotBlank(message = &quot;手机号不能为空&quot;)    private String telphone;    private String registerMode;    private String thirdPartyId;    @NotBlank(message = &quot;密码不能为空&quot;)    private String encrptPassword;</code></pre><h3 id="在数据层UserDO和UserPasswordDO表中："><a href="#在数据层UserDO和UserPasswordDO表中：" class="headerlink" title="在数据层UserDO和UserPasswordDO表中："></a>在数据层UserDO和UserPasswordDO表中：</h3><p>在企业中，由于用户的密码属性会由其他，于是用户的密码生成另外的表，UserModel的属性由UserDO和UserPasswordDO的属性拼接而成。</p><p>UserDO：</p><pre><code class="java">    private Integer id;    private String name;    private Byte gender;    private Integer age;    private String telphone;    private String registerMode;    private String thirdPartyId;</code></pre><p>UserPasswordDO：</p><pre><code class="java">    private Integer id;    private String encrptPassword;    private Integer userId;</code></pre><h2 id="贫血模型"><a href="#贫血模型" class="headerlink" title="贫血模型"></a>贫血模型</h2><p>Domain Model使用的是贫血模型</p><p>对应的Domain Model 仅仅只有自己的属性，比如用户的基础属性和用户的密码属性，另外提供get个set方法，除此以外不提供注册、登录、注销这些服务，用户想使用这些服务，必须通过service服务输出能力。</p><h2 id="接入层模型"><a href="#接入层模型" class="headerlink" title="接入层模型"></a>接入层模型</h2><p>接入层 View Object 是对前端负责</p><h3 id="与springMVC"><a href="#与springMVC" class="headerlink" title="与springMVC"></a>与springMVC</h3><p>Controller管理的是 View Objec 接入层模型</p><p>Model对应的是 Domain Model 业务层模型</p><h3 id="项目VO、Model和DO图"><a href="#项目VO、Model和DO图" class="headerlink" title="项目VO、Model和DO图"></a>项目VO、Model和DO图</h3><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150919.png" alt="屏幕快照 2019-06-14 上午12.23.42"></p><h1 id="项目类图"><a href="#项目类图" class="headerlink" title="项目类图"></a>项目类图</h1><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150920.png" alt="屏幕快照 2019-06-14 上午12.35.58"></p><h1 id="答疑"><a href="#答疑" class="headerlink" title="答疑"></a>答疑</h1><p>跨域session共享问题(safari浏览器 )</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-07-03-150921.png" alt="屏幕快照 2019-06-14 上午2.02.17"></p><p>全局异常处理器404，405问题</p>]]></content>
      
      
      <categories>
          
          <category> 秒杀项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 秒杀项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个完整的HTTP请求过程</title>
      <link href="/2019/04/29/ji-suan-ji-wang-luo/yi-ge-wan-zheng-de-http-qing-qiu-guo-cheng/"/>
      <url>/2019/04/29/ji-suan-ji-wang-luo/yi-ge-wan-zheng-de-http-qing-qiu-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h1><p>域名解析 —&gt;与服务器建立连接 —&gt; 发起HTTP请求 —&gt; 服务器响应HTTP请求 —&gt;浏览器得到html代码 —&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片） —&gt; 浏览器对页面进行渲染呈现给用户</p><a id="more"></a><h1 id="1-域名解析"><a href="#1-域名解析" class="headerlink" title="1. 域名解析"></a>1. 域名解析</h1><p>以Chrome浏览器为例：</p><p>① Chrome浏览器会首先搜索<strong>浏览器自身的DNS缓存</strong>（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存），看自身的缓存中是否有<a href="https://www.cnblogs.com" target="_blank" rel="noopener">https://www.cnblogs.com</a> 对应的条目，而且没有过期，如果有且没有过期则解析到此结束。</p><p>② 如果浏览器自身的缓存里面没有找到对应的条目，那么Chrome会搜索<strong>操作系统自身的DNS缓存</strong>,如果找到且没有过期则停止搜索解析到此结束.</p><p>注：怎么查看操作系统自身的DNS缓存，以Windows系统为例，可以在命令行下使用 ipconfig /displaydns 来进行查看</p><p>③ 如果在Windows系统的DNS缓存也没有找到，那么尝试读取<strong>hosts文件</strong>（位于C:\Windows\System32\drivers\etc），看看这里面有没有该域名对应的IP地址，如果有则解析成功。</p><p>④ 如果在hosts文件中也没有找到对应的条目，浏览器就会发起一个DNS的系统调用，就会向<strong>本地配置的首选DNS服务器</strong>（一般是电信运营商提供的，也可以使用像Google提供的DNS服务器）发起==域名解析请求==（通过的是UDP协议向DNS的<strong>53</strong>端口发起请求，这个请求是递归的请求，也就是运营商的DNS服务器必须得提供给我们该域名的IP地址），运营商的DNS服务器首先查找自身的缓存，找到对应的条目，且没有过期，则解析成功。如果没有找到对应的条目，则有运营商的DNS代我们的浏览器发起迭代DNS解析请求，它首先是会找根域的DNS的IP地址（这个DNS服务器都内置13台根域的DNS的IP地址），找打根域的DNS地址，就会向其发起请求（请问<code>www.cnblogs.com</code>)这个域名的IP地址是多少啊？），根域发现这是一个<strong>顶级域com域</strong>的一个域名，于是就告诉运营商的DNS我不知道这个域名的IP地址，但是我知道com域的IP地址，你去找它去，于是运营商的DNS就得到了com域的IP地址，又向com域的IP地址发起了请求（请问<code>www.cnblogs.com</code>这个域名的IP地址是多少?）,com域这台服务器告诉运营商的DNS我不知道<code>www.cnblogs.com</code>这个域名的IP地址，但是我知道cnblogs.com这个域的DNS地址，你去找它去，于是运营商的DNS又向cnblogs.com这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问<code>www.cnblogs.com</code>这个域名的IP地址是多少？），这个时候cnblogs.com域的DNS服务器一查，诶，果真在我这里，于是就把找到的结果发送给运营商的DNS服务器，这个时候运营商的DNS服务器就拿到了<code>www.cnblogs.com</code>这个域名对应的IP地址，并返回给Windows系统内核，内核又把结果返回给浏览器，终于浏览器拿到了<code>www.cnblogs.com</code> 对应的IP地址，该进行一步的动作了。</p><h1 id="2-与服务器建立连接"><a href="#2-与服务器建立连接" class="headerlink" title="2. 与服务器建立连接"></a>2. 与服务器建立连接</h1><p>客户端的请求到达服务器，首先就是建立TCP连接</p><ol><li><p>Client首先发送一个连接试探，ACK=0 表示确认号无效，SYN = 1 表示这是一个连接请求或连接接受报文，同时表示这个数据报不能携带数据，seq = x 表示Client自己的初始序号（seq = 0 就代表这是第0号包），这时候Client进入syn_sent状态，表示客户端等待服务器的回复</p></li><li><p>Server监听到连接请求报文后，如同意建立连接，则向Client发送确认。TCP报文首部中的SYN 和 ACK都置1 ，ack = x + 1表示期望收到对方下一个报文段的第一个数据字节序号是x+1，同时表明x为止的所有数据都已正确收到（ack=1其实是ack=0+1,也就是期望客户端的第1个包），seq = y 表示Server 自己的初始序号（seq=0就代表这是服务器这边发出的第0号包）。这时服务器进入syn_rcvd，表示服务器已经收到Client的连接请求，等待client的确认。</p></li><li><p>Client收到确认后还需再次发送确认，同时携带要发送给Server的数据。ACK 置1 表示确认号ack= y + 1 有效（代表期望收到服务器的第1个包），Client自己的序号seq= x + 1（表示这就是我的第1个包，相对于第0个包来说的），一旦收到Client的确认之后，这个TCP连接就进入Established状态，就可以发起http请求了。</p></li></ol><h1 id="3-发起HTTP请求"><a href="#3-发起HTTP请求" class="headerlink" title="3. 发起HTTP请求"></a>3. 发起HTTP请求</h1><h2 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h2><p>一个HTTP请求报文由<strong>请求行</strong>（request line）、<strong>请求头部</strong>（header）、<strong>空行</strong>和<strong>请求数据</strong>4个部分组成</p><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>请求行分为三个部分：<strong>请求方法</strong>、<strong>请求地址</strong>和<strong>协议版本</strong></p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。</p><p>最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。</p><h4 id="请求地址"><a href="#请求地址" class="headerlink" title="请求地址"></a>请求地址</h4><p>URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。</p><p>组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 注：端口和路径有时可以省略（HTTP默认端口号是80）</p><p><a href="https://localhost:8080/index.html?key1=value1&amp;keys2=value2" target="_blank" rel="noopener">https://localhost:8080/index.html?key1=value1&amp;keys2=value2</a></p><h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><p>协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1</p><h3 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h3><p>请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。</p><h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><p>请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。</p><h3 id="请求数据"><a href="#请求数据" class="headerlink" title="请求数据"></a>请求数据</h3><p>可选部分，比如GET请求就没有请求数据。</p><p>###一个POST方法的请求报文：</p><pre><code>POST 　/index.php　HTTP/1.1 　　 请求行 Host: localhost User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2　　请求头 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8 Accept-Language: zh-cn,zh;q=0.5 Accept-Encoding: gzip, deflate Connection: keep-alive Referer: http://localhost/ Content-Length：25 Content-Type：application/x-www-form-urlencoded 　　空行 username=aa&amp;password=1234　　请求数据</code></pre><h1 id="4-服务器响应HTTP请求"><a href="#4-服务器响应HTTP请求" class="headerlink" title="4. 服务器响应HTTP请求"></a>4. 服务器响应HTTP请求</h1><h2 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h2><p>HTTP响应报文主要由<strong>==状态行==</strong>、<strong>==响应头部==</strong>、<strong>==空行==</strong>以及<strong>==响应数据==</strong>组成。</p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>由3部分组成，分别为：<strong>协议版本</strong>，<strong>状态码</strong>，<strong>状态码描述</strong>。</p><p>其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。</p><p>状态码</p><p>状态代码为3位数字。</p><ul><li>1xx：指示信息–表示请求已接收，继续处理。</li><li>2xx：成功–表示请求已被成功接收、理解、接受。</li><li>3xx：重定向–要完成请求必须进行更进一步的操作。</li><li>4xx：客户端错误–请求有语法错误或请求无法实现。</li><li>5xx：服务器端错误–服务器未能实现合法的请求。</li></ul><h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><p>与请求头部类似，为响应报文添加了一些附加信息</p><h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p>用于存放需要返回给客户端的数据信息。</p><h3 id="一个响应报文的实例："><a href="#一个响应报文的实例：" class="headerlink" title="一个响应报文的实例："></a>一个响应报文的实例：</h3><pre><code>HTTP/1.1 200 OK　　状态行 Date: Sun, 17 Mar 2013 08:12:54 GMT　　响应头部 Server: Apache/2.2.8 (Win32) PHP/5.2.5 X-Powered-By: PHP/5.2.5 Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Length: 4393 Keep-Alive: timeout=5, max=100 Connection: Keep-Alive Content-Type: text/html; charset=utf-8 　　空行 　　响应数据 HTTP响应示例 Hello HTTP! </code></pre><h1 id="5-浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源"><a href="#5-浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源" class="headerlink" title="5.浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源"></a>5.浏览器得到html代码，浏览器解析html代码，并请求html代码中的资源</h1><p>浏览器拿到index.html文件后，就开始<strong>解析</strong>其中的html代码，遇到js/css/image等<strong>静态资源</strong>时，就向服务器端去请求下载（会使用多线程下载，每个浏览器的线程数不一样），这个时候就用上keep-alive特性了，建立一次HTTP连接，可以请求多个资源，下载资源的顺序就是按照代码里的顺序，但是由于每个资源大小不一样，而浏览器又多线程请求请求资源，所以从下图看出，这里显示的顺序并不一定是代码里面的顺序。</p><p>浏览器在请求静态资源时（在未过期的情况下），向服务器端发起一个http请求（询问自从上一次修改时间到现在有没有对资源进行修改），如果服务器端返回304状态码（告诉浏览器服务器端没有修改），那么浏览器会直接读取本地的该资源的缓存文件。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151235.png" alt="20180529143316"></p><h1 id="6-浏览器对页面进行渲染呈现给用户"><a href="#6-浏览器对页面进行渲染呈现给用户" class="headerlink" title="6. 浏览器对页面进行渲染呈现给用户"></a>6. 浏览器对页面进行渲染呈现给用户</h1><p>最后，浏览器利用自己内部的工作机制，把请求到的静态资源和html代码进行渲染，渲染之后呈现给用户。</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。<img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151247.png" alt="3985563-1891c256487e9d85"></p><p>当目的主机收到一个以太网数据帧时，数据就开始从<strong>协议栈</strong>中由底向上升，<strong>同时去掉各层协议加上的报文首部</strong>。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议，这个过程称作<strong>分用</strong>（Demultiplexing）。<strong>协议是通过目的端口号、源IP地址和源端口号进行解包的</strong>。</p><p>通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151248.png" alt="3985563-ecf824604debcdf1"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2019/04/29/ji-suan-ji-wang-luo/http/"/>
      <url>/2019/04/29/ji-suan-ji-wang-luo/http/</url>
      
        <content type="html"><![CDATA[<p>#前言：</p><p>TCP协议实现了==数据流==的可靠传输。然而，人们更加习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档(hypertext document)。</p><p>==超文本文档==中包含有超链接，指向其他的资源。超文本文档是万维网(World Wide Web，即www)的基础。</p><p>HTTP协议==解决文件传输==的问题。HTTP是应用层协议，==主要建立在TCP协议之上==(偶尔也可以UDP为底层)。它随着万维网的发展而流行。HTTP协议目的是，如何在万维网的网络环境下，更好的利用TCP协议，以实现文件，特别是超文本文件的传输。</p><a id="more"></a><p>早期的HTTP协议主要传输静态文件，即真实存储在服务器上的文件。随着万维网的发展，HTTP协议被用于传输“动态文件”，服务器上的程序根据HTTP请求即时生成的动态文件。我们将HTTP的传输对象统称为==资源==(resource)。</p><p><strong>点单</strong></p><p>HTTP实现了资源的订购和传送。其工作方式类似于快餐点单。</p><p>1：==请求==(request): 顾客向服务员提出请求：“来个鸡腿汉堡”。</p><p>2：==回复==(response):服务员根据情况，回应顾客的请求</p><p>根据情况的不同，服务员的回应可能有很多，比如:</p><p>服务员准备鸡腿汉堡，将鸡腿汉堡交给顾客。（一切OK）</p><p>服务员发现自己只是个甜品站。他让顾客前往正式柜台点单。（重新定向）</p><p>服务员告诉顾客鸡腿汉堡没有了。(无法找到)</p><p>交易结束后，服务员就将刚才的交易抛到脑后，准备服务下一位顾客。</p><h1 id="HTTP具体实现"><a href="#HTTP具体实现" class="headerlink" title="HTTP具体实现"></a>HTTP具体实现</h1><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a><strong>格式</strong></h2><p>HTTP协议的通信是一次==request-responce==交流。客户端(guest)向服务器发出请求(request)，服务器(server)回复(response)客户端。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151158.png" alt="img"></p><p>HTTP协议规定了请求和回复的格式:</p><pre><code>起始行 (start line)头信息 (headers)主体(entity body)</code></pre><p>==起始行==只有一行。它包含了请求/回复最重要的信息。请求的起始行表示(顾客)“想要什么”。回复的起始行表示(后厨)“发生什么”。</p><p>==头信息==可以有多行。每一行是一对键值对(key-value pair)，比如:</p><pre><code>Content-type: text/plain </code></pre><p>它表示，包含有一个名为Content-type的参数，该参数的值为text/plain。头信息是对起始行的补充。请求的头信息对服务器有指导意义 (好像在菜单上注明: 鸡腿不要辣)。回复的头信息则是提示客户端（比如，在盒子上注明: 小心烫）</p><p>==主体部分==包含了具体的资源。上图的请求中并没有主体，因为我们只是在下单，而不用管后厨送什么东西 (请求是可以有主体内容的)。回复中包含的主体是一段文本文字(Hello World!)。这段文本文字正是顾客所期待的，鸡腿汉堡。</p><p>##请求（Request）</p><p>我们深入一些细节。先来看一下请求的第一行:</p><pre><code>GET /index.html HTTP/1.1Host: www.example.com</code></pre><p>在起始行中，有三段信息:</p><p>==GET== ：用于说明想要服务器执行的操作，此外还有<strong>PUT、POST等操作</strong></p><p>==/index.html== ：资源的路径。这里指向服务器上的index.html文件。</p><p>==HTTP/1.1==： 协议的版本。HTTP第一个广泛使用的版本是1.0，当前版本为1.1。</p><p>早期的HTTP协议只有GET方法。遵从HTTP协议，服务器接收到GET请求后，会将特定资源传送给客户。这类似于客户点单，并获得汉堡的过程。使用GET方法时，是客户向服务器索取资源，所以请求往往没有主体部分。</p><p>GET方法也可以用于传输一些不重要的数据。它是通过改写URL的方式实现的。GET的数据利用==URL?变量名＝变量值==的方法传输。比如向<a href="http://127.0.0.1发送一个变量“q”，它的值为“a”。那么，实际的URL为http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。" target="_blank" rel="noopener">http://127.0.0.1发送一个变量“q”，它的值为“a”。那么，实际的URL为http://127.0.0.1?q=a。服务器收到请求后，就可以知道&quot;q&quot;的值为&quot;a&quot;。</a></p><p>GET方法之外，最常用的是POST方法。它用于从客户端向服务器提交数据。使用POST方法时，URL不再被改写。数据位于http请求的主体。POST方法最用于提交HTML的form数据。服务器往往会对POST方法提交的数据进行一定的处理，比如存入服务器数据库。</p><p>样例请求中有一行头信息。该头信息的名字是Host。HTTP的请求必须有Host头信息，用于说明服务器的地址和端口。HTTP协议的默认端口是80，如果在HOST中没有说明端口，那么将默认采取该端口。在该例子中，服务器的域名为<a href="http://www.example.com，端口为80。域名将通过DNS服务器转换为IP地址，从而确定服务器在互联网上的地址。" target="_blank" rel="noopener">www.example.com，端口为80。域名将通过DNS服务器转换为IP地址，从而确定服务器在互联网上的地址。</a></p><p>牛客项目中<strong>Request Headers</strong>：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151159.png" alt="屏幕快照 2019-03-21 下午10.34.28"></p><p>##回复(Response)</p><p>服务器在接收到请求之后，会根据程序，生成对应于该请求的回复，比如:</p><pre><code>HTTP/1.1 200 OKContent-type: text/plainContent-length: 12Hello World!</code></pre><p>回复的起始行同样包含三段信息</p><pre><code>HTTP/1.1 协议版本200 状态码(status code)OK 状态描述</code></pre><p>OK是对状态码200的文字描述，它只是为了便于人类的阅读。电脑只关心三位的状态码(status code)，即这里的200。200表示一切OK，资源正常返回。状态码代表了服务器回应动作的类型。</p><p>其它常见的状态码还有:</p><p>302，重定向(redirect): 我这里没有你想要的资源，但我知道另一个地方xxx有，你可以去那里找。</p><p>404，无法找到(not found): 我找不到你想要的资源，无能为力。</p><p>Content-type说明了主体所包含的资源的类型。根据类型的不同，客户端可以启动不同的处理程序(比如显示图像文件，播放声音文件等等)。下面是一些常见的资源：</p><pre><code>text/plain 普通文本text/html HTML文本image/jpeg jpeg图片image/gif gif图片</code></pre><p>Content-length说明了主体部分的长度，以字节(byte)为单位。</p><p>回应的主体部分为一段普通文本，即Hello World!</p><p>牛客项目中<strong>Response Headers</strong></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151201.png" alt="屏幕快照 2019-03-21 下午10.37.03"></p><p>##常见的请求和相应头</p><h4 id="请求-客户端-gt-服务端-request"><a href="#请求-客户端-gt-服务端-request" class="headerlink" title="请求(客户端-&gt;服务端[request])"></a>请求(客户端-&gt;服务端[<strong>request</strong>])</h4><blockquote><p>GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号)<br>Accept: <em>/</em>(客户端能接收的资源类型)<br>Accept-Language: en-us(客户端接收的语言类型)<br>Connection: Keep-Alive(维护客户端和服务端的连接关系)<br>Host: localhost:8080(连接的目标主机和端口号)<br>Referer: <a href="https://link.jianshu.com/?t=http%3A%2F%2Flocalhost%2Flinks.jsp%28" target="_blank" rel="noopener">http://localhost/links.jsp(</a>告诉服务器我来自于哪里)<br>User-Agent: Mozilla/4.0(客户端版本号的名字)<br>Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型)<br>If-Modified-Since: Tue, 11 Jul 2017 18:23:51 GMT(缓存时间)<br>Cookie(客户端暂存服务端的信息)<br>Date: Tue, 18 Jul 12:15:02 GMT(客户端请求服务端的时间)</p></blockquote><h4 id="响应-服务端-gt-客户端-response"><a href="#响应-服务端-gt-客户端-response" class="headerlink" title="响应(服务端-&gt;客户端[response])"></a>响应(服务端-&gt;客户端[<strong>response</strong>])</h4><blockquote><p>HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息)<br>Location: <a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.baidu.com%28" target="_blank" rel="noopener">http://www.baidu.com(</a>服务端需要客户端访问的页面路径)<br>Server:apache tomcat(服务端的Web服务端名)<br>Content-Encoding: gzip(服务端能够发送压缩编码类型)<br>Content-Length: 80(服务端发送的压缩数据的长度)<br>Content-Language: zh-cn(服务端发送的语言类型)<br>Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式)<br>Last-Modified: Tue, 18 Jul 2017 12:15:02 GMT(服务端对该资源最后修改的时间)<br>Refresh: 1;url=<a href="https://link.jianshu.com/?t=http%3A%2F%2Fwww.helloyoucan.com.%28" target="_blank" rel="noopener">http://www.helloyoucan.com.(</a>服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径)<br>Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件)<br>Transfer-Encoding: chunked(分块传递数据到客户端）<br>Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据)<br>Expires: -1//3种(服务端禁止客户端缓存页面数据)<br>Cache-Control: no-cache(服务端禁止客户端缓存页面数据)<br>Pragma: no-cache(服务端禁止客户端缓存页面数据)<br>Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系)<br>Date: Tue, 18 Jul 2017 12:18:03 GMT(服务端响应客户端的时间)</p></blockquote><p>##无状态</p><p>根据早期的HTTP协议，每次request-reponse时，都要重新建立TCP连接。TCP连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，HTTP通信是无状态(stateless)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。</p><p>想象高级餐厅和快餐店。高级餐厅会知道客人所在的位置，如果新增点单，那么服务员知道这和上一单同一桌。而在快餐店中，不好意思，服务员并不记录客人的特征。想再次点单？请重新排队……</p><p>随着HTTP协议的发展，HTTP协议允许TCP连接复用，以节省建立连接所耗费的时间。但HTTP协议依然保持无状态的特性。</p><p>#两种 HTTP 方法：GET 和 POST</p><table><thead><tr><th></th><th align="left"><strong>GET</strong></th><th><strong>POST</strong></th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td align="left">无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td align="left">可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td align="left">能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td align="left">application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或   multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td align="left">参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td align="left">是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td align="left">只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td align="left">与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。   在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td align="left">数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>###什么是HTTPS?</p><p>HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 http 协议安全。  </p><p>###<strong>https</strong> 与 <strong>http</strong> 区别 ?</p><p>1)https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。 </p><p>2)http 是超文本传输协议，==信息是明文传输==，https 则是具有安全性的 ssl 加密传输协议。 </p><p>3)http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 ==80==，后者是 ==443==。 </p><p>4)http 的连接很简单，==是无状态的==;HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151202.gif" alt="page242image3818784"></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151203.gif" alt="page242image3851264"></p><p>文字简述:客户端 A 和服务器 B 之间的交互 </p><ol><li><p>A与B通过TCP建立链接，初始化SSL层。 </p></li><li><p>进行 SSL 握手，A 发送 https 请求，传送客户端 SSL 协议版本号、支持的加密算法、 随机数等。 </p></li><li><p>服务器 B 把 CA 证书(包含 B 的公钥)，把自己支持的加密算法、随机数等回传给 A。 </p></li><li><p>A 接收到 CA 证书，验证证书有效性。 </p></li><li><p>校验通过，客户端随机产生一个字符串作为与 B 通信的对称密钥，通过 CA 证书解出服务器 B 的公钥，对其加密，发送给服务器。</p></li><li><p>B 用私钥解开信息，得到随机的字符串(对称密钥)，利用这个密钥作为之后的通信密钥。 </p></li><li><p>客户端向服务器发出信息，指明后面的数据使用该对称密钥进行加密，同时通知服 务器 SSL 握手结束。 </p></li><li><p>服务器接收到信息，使用对称密钥通信，通知握手接收。 </p></li><li><p>SSL 握手结束，使用对称密钥加密数据。 </p></li></ol><p>###安全加密</p><p>1.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151203.png" alt="bg2011080901"></p><p>鲍勃有两把钥匙，一把是公钥，另一把是私钥。</p><p>2.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151204.png" alt="bg2011080902"></p><p>鲍勃把公钥送给他的朋友们—-帕蒂、道格、苏珊—-每人一把。</p><p>3.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151205.png" alt="bg2011080903"></p><p>苏珊要给鲍勃写一封保密的信。她写完后用鲍勃的公钥加密，就可以达到保密的效果。</p><p>4.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151206.png" alt="bg2011080904"></p><p>鲍勃收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要鲍勃的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。</p><p>5.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151207.png" alt="bg2011080905"></p><p>鲍勃给苏珊回信，决定采用”数字签名”。他写完后先用Hash函数，生成信件的摘要（digest）。</p><blockquote><p>这里主要解释一下签名，签名就是在信息的后面再加上一段内容，==可以证明信息没有被修改过==，怎么样可以达到这个效果呢？一般是对信息做一个hash计算得到一个hash值，注意，这个过程是不可逆的，也就是说无法通过hash值得出原来的信息内容。在把信息发送出去时，把这个hash值加密后做为一个签名和信息一起发出去。<br>接收方在收到信息后，会重新计算信息的hash值，并和信息所附带的hash值(解密后)进行对比，如果一致，就说明信息的内容没有被修改过，因为这里hash计算可以保证不同的内容一定会得到不同的hash值，所以只要内容一被修改，根据信息内容计算的hash值就会变化。当然，不怀好意的人也可以修改信息内容的同时也修改hash值，从而让它们可以相匹配，为了防止这种情况，hash值一般都会加密后(也就是签名)再和信息一起发送，以保证这个hash值不被修改。</p></blockquote><p><strong>补充知识点</strong>：</p><p>那么问题来了，==是将发送的全部内容hash嘛==？</p><p>这里用到的hash算法其实就是==将一段非常长的数据通过hash变换为一个固定长度相对较短的数据==，简称“<strong>摘要</strong>”，你可以理解成把一本书通过hash变成一段很短的话，算法最关键的要点是，哪怕你改动了这本书里面的一个标点符号，hash后的摘要都会改变。</p><p>以MD5这种hash算法为例，他可以将任意长度的数据变成128位的散列值，所谓任意长度的意思就是你的数据可以是一篇文章，一部电影，或者只是一个字母，哪怕是个空字符串。</p><p>6.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151208.png" alt="bg2011080906"></p><p>然后，鲍勃使用私钥，对这个摘要加密，生成”==数字签名==”（signature）。</p><p>7.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151209.png" alt="bg2011080907"></p><p>鲍勃将这个签名，附在信件下面，一起发给苏珊。</p><p>8.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151210.png" alt="bg2011080908"></p><p>苏珊收信后，取下数字签名，用鲍勃的公钥解密，得到信件的摘要。由此证明，这封信确实是鲍勃发出的。</p><p>9.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151211.png" alt="bg2011080909"></p><p>苏珊再对信件本身使用Hash函数，将得到的结果，与上一步得到的摘要进行对比。如果两者一致，就证明这封信未被修改过。</p><p>10.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151212.png" alt="bg2011080910"></p><p>复杂的情况出现了。道格想欺骗苏珊，他偷偷使用了苏珊的电脑，用自己的公钥换走了鲍勃的公钥。此时，苏珊实际拥有的是道格的公钥，但是还以为这是鲍勃的公钥。因此，道格就可以冒充鲍勃，用自己的私钥做成”数字签名”，写信给苏珊，让苏珊用假的鲍勃公钥进行解密。</p><p>11.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151213.png" alt="bg2011080911"></p><p>后来，苏珊感觉不对劲，发现自己无法确定公钥是否真的属于鲍勃。她想到了一个办法，要求鲍勃去找”证书中心”（certificate authority，简称CA），为公钥做认证。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。</p><p><strong>知识点补充</strong>：</p><blockquote><p>介绍下数字证书：</p><p>数字证书则是由证书认证机构(CA, Certificate Authority)对证书申请者真实身份验证之后，用CA的根证书对申请人的一些基本信息以及申请人的公钥进行签名(相当于加盖发证书机构的公章)后形成的一个数字文件。</p><p><strong>数字证书验证过程</strong>:CA 机构的公钥已经是==在浏览器发布前提前嵌入到浏览器内部了==， 所以 CA 的公钥是真实可靠的(如果 CA 机构被黑客攻陷，那么也可能是不可靠的)，然后服务器发送自己的公钥给 CA(用 CA 的公钥进行加密)，CA 对服务器的发来的内容解密得到服务器的公钥，然后 CA 对服务器的公钥进行颁发数字证书(就是数字签名)，发给服务器，服务器收到以后，将==数字证书，公开密钥发送给客户端==，客户端用 CA 的公开密钥验证得到服务器的公开密钥，然后这样客户端就得到了真正可靠的服务器的公开密钥。 </p></blockquote><p>12.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151214.png" alt="bg2011080912"></p><p>鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。</p><p>13.</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151215.png" alt="bg2011080913"></p><p>苏珊收信后，用CA的公钥解开数字证书，就可以拿到鲍勃真实的公钥了，然后就能证明”数字签名”是否真的是鲍勃签的。</p><p>##HTTPS的实际应用</p><p>下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151213.jpg" alt="bg2011080914"></p><p>1.首先，客户端向服务器发出加密请求。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151216.png" alt="bg2011080915"></p><p>2.服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151217.png" alt="bg2011080916"></p><p>3.客户端（浏览器）的”==证书管理器==”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151218.png" alt="bg2011080917"></p><p>4.如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151219.png" alt="bg2011080918"></p><p>5.如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151218.jpg" alt="bg2011080919"></p><p>6.如果数字证书是可靠的，==客户端就可以使用证书中的服务器公钥==，对信息进行加密，然后与服务器交换加密信息。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151220.png" alt="bg2011080920"></p><p>##总结：</p><p>HTTPS为了兼顾安全与效率，同时使用了==对称加密==和==非对称加密==。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，==对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输==。</p><p>也就是说客户端使用对称加密加密数据，服务端通过非对称加密得到对称加密的秘钥。</p><p>为什么用对称秘钥加密数据呢？</p><p>可能是为了传输效率。因为私钥只有服务端自己有，足够安全，再加上对称加密的效率更高</p><p><strong>知识点补充：</strong></p><p><strong>对称加密</strong>：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。<br>其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文<br>解密过程如下：密文 + 解密算法 + 私钥 =&gt; 明文<br>对称加密中用到的密钥叫做私钥，私钥表示个人私有的密钥，即该密钥不能被泄露。<br>其加密过程中的私钥与解密过程中用到的私钥是同一个密钥，这也是称加密之所以称之为“对称”的原因。由于对称加密的算法是公开的，所以一旦私钥被泄露，那么密文就很容易被破解，所以对称加密的缺点是密钥安全管理困难。</p><p><strong>非对称加密</strong>：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。<br>被公钥加密过的密文只能被私钥解密，过程如下：<br>明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文<br>被私钥加密过的密文只能被公钥解密，过程如下：<br>明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文<br>由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。<br>==非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。==<br>在非对称加密中使用的主要算法有：RSA、Elgamal、Rabin、D-H、ECC（椭圆曲线加密算法）等。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP</title>
      <link href="/2019/04/29/ji-suan-ji-wang-luo/tcp/"/>
      <url>/2019/04/29/ji-suan-ji-wang-luo/tcp/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP三次握手四次挥手"><a href="#TCP三次握手四次挥手" class="headerlink" title="TCP三次握手四次挥手"></a>TCP三次握手四次挥手</h1><p>三次握手需要的信息:</p><p>==ACK== : TCP 协议规定，只有 ACK=1 时有效，也规定连接建立后所有发送的报文的 ACK 必须为 1。 </p><p>==SYN==(SYNchronization) : 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1. 因此, SYN 置 1 就表示这是一个连接请求或连接接受报文。 </p><p>==FIN== (finish)即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段 的发送方的数据已经发送完毕，并要求释放连接 。</p><p>==seq==(序号):</p><a id="more"></a><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151220.jpg" alt="1350984685_4221"></p><p>三次握手：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151221.jpg" alt="1350985085_3123"></p><ol><li>首先由Client发出请求连接即 SYN=1，ACK=0， TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x；</li><li>然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1；</li><li>再然后 Client 再进行一次确认，但不用SYN了，这时即为 ACK=1, seq=x+1, ack=y+1.然后连接建立。</li></ol><p>四次挥手：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151222.jpg" alt="1350990937_5362"></p><p>【注意】中断连接端可以是Client端，也可以是Server端。</p><p>假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了==2MSL==（<em>Maximum Segment Lifetime</em>，中文可以译为“==报文最大生存时间==”）后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p>整个过程Client端所经历的状态如下：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151222.gif" alt="0_1312719804oSkK"></p><p>而Server端所经历的过程如下：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151223.gif" alt="0_1312719833030b"></p><h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p>###1.为什么要进行三次握手呢（两次确认）？</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151223.jpg" alt="1350985432_2318"></p><p>###2.为什么连接的时候是三次握手，关闭的时候却是四次握手？</p><p>答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>###3.为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p><p>答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><h1 id="TCP如何保证可靠性传输"><a href="#TCP如何保证可靠性传输" class="headerlink" title="TCP如何保证可靠性传输"></a>TCP如何保证可靠性传输</h1><p><strong>确保传输可靠性的方式：</strong></p><p>TCP协议保证数据传输可靠性的方式主要有：</p><ol><li>连接管理</li><li>序列号</li><li>确认应答</li><li>超时重传</li><li>流量控制</li><li>拥塞控制</li><li>校验和</li></ol><p>##1.连接管理</p><p>连接管理就是三次握手与四次挥手的过程，在前面详细讲过这个过程，这里不再赘述。保证可靠的连接，是保证可靠性的前提。</p><h2 id="2-amp-3-确认应答与序列号"><a href="#2-amp-3-确认应答与序列号" class="headerlink" title="2&amp;3. 确认应答与序列号"></a>2&amp;3. <strong>确认应答与序列号</strong></h2><p><strong>序列号</strong>：TCP传输时将每个字节的数据都进行了编号，这就是序列号。 </p><p><strong>确认应答</strong>：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，==接收到了哪些数据，下一次的数据从哪里发==。</p><h2 id="4-超时重传"><a href="#4-超时重传" class="headerlink" title="4. 超时重传"></a>4. 超时重传</h2><p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的ACK报文，并解析ACK报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的ACK报文，这该怎么办呢？而没有收到ACK报文的原因可能是什么呢？</p><p>首先，发送方没有介绍到响应的ACK报文原因可能有两点：</p><p>1.数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。</p><p>2.接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</p><p>TCP在解决这个问题的时候引入了一个新的机制，叫做==超时重传机制==。<strong>简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送</strong>。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。</p><p>###补充知识点： </p><p>==那么发送方发送完毕后等待的时间是多少呢？==如果这个等待的时间过长，那么会影响TCP传输的整体效率，如果等待时间过短，又会导致频繁的发送重复的包。如何权衡？</p><p>由于TCP传输时保证能够在任何环境下都有一个高性能的通信，因此这个最大超时时间（也就是等待的时间）是动态计算的。</p><p>   在Linux中（BSD Unix和Windows下也是这样）超时以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。重发一次后，仍未响应，那么等待2*500ms的时间后，再次重传。等待4*500ms的时间继续重传。以一个指数的形式增长。累计到一定的重传次数，TCP就认为网络或者对端出现异常，强制关闭连接。   </p><h2 id="5-流量控制"><a href="#5-流量控制" class="headerlink" title="5.  流量控制"></a>5.  <strong>流量控制</strong></h2><p>接收端在接收到数据后，对其进行处理。如果发送端的发送速度太快，导致接收端的结束缓冲区很快的填充满了。此时如果发送端仍旧发送数据，那么接下来发送的数据都会丢包，继而导致丢包的一系列连锁反应，超时重传呀什么的。而==TCP根据接收端对数据的处理能力，决定发送端的发送速度，这个机制就是流量控制==。</p><p>在TCP协议的报头信息当中，有一个<strong>16位字段的窗口大小</strong>。在介绍这个窗口大小时我们知道，窗口大小的内容实际上是接收端接收数据缓冲区的剩余大小。这个数字越大，证明接收端接收缓冲区的剩余空间越大，网络的吞吐量越大。接收端会在确认应答发送ACK报文时，将自己的即时窗口大小填入，并跟随ACK报文一起发送过去。而发送方根据ACK报文里的窗口大小的值的改变进而改变自己的发送速度。如果接收到窗口大小的值为0，那么发送方将停止发送数据。并定期的向接收端发送窗口探测数据段，让接收端把窗口大小告诉发送端。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151224.gif" alt="70"></p><p><strong>注</strong>：16位的窗口大小最大能表示65535个字节（64K），但是TCP的窗口大小最大并不是64K。在TCP首部中40个字节的选项中还包含了一个窗口扩大因子M，实际的窗口大小就是16为窗口字段的值左移M位。每移一位，扩大两倍。</p><h3 id="滑动窗口协议（连续ARQ协议）"><a href="#滑动窗口协议（连续ARQ协议）" class="headerlink" title="滑动窗口协议（连续ARQ协议）"></a>滑动窗口协议（连续ARQ协议）</h3><p><strong>连续ARQ协议</strong></p><p>在ARQ协议发送者每次只能发送一个分组，在应答到来前必须等待。而连续ARQ协议的发送者拥有一个发送窗口，发送者可以在没有得到应答的情况下连续发送窗口中的分组。这样降低了等待时间，提高了传输效率。 </p><p><strong>累计确认</strong></p><p>在连续ARQ协议中，接收者也有个接收窗口，接收者并不需要每收到一个分组就返回一个应答，可以连续收到分组之后统一返回一个应答。这样能节省流量。TCP头部的ack字段就是用来累计确认，它表示已经确认的字节序号+1，也表示期望发送者发送的下一个分组的起始字节号。</p><p>==发送窗口==</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151225.gif" alt="1"></p><p>发送窗口的大小由接收窗口的剩余大小决定。接收者会把当前接收窗口的剩余大小写入应答TCP报文段的头部，发送者收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小。发送窗口的大小是不断变化的。发送窗口由三个指针构成：</p><p>发送者每收到一个应答，后沿就可以向前移动指定的字节。此时若窗口大小仍然没变，前沿也可以向前移动指定字节。当p2和前沿重合时，发送者必须等待确认应答。</p><p><strong>p1</strong></p><p>p1指向发送窗口的后沿，它后面的字节表示已经发送且已收到应答。 </p><p><strong>p2</strong></p><p>p2指向尚未发送的第一个字节。p1-p2间的字节表示已经发送，但还没收到确认应答。这部分的字节仍需保留，因为可能还要超时重发。p2-p3间的字节表示可以发送，但还没有发送的字节。</p><p><strong>p3</strong></p><p>p3指向发送窗口的前沿，它前面的字节尚未发送，且不允许发送。</p><p>==接收窗口==</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151226.gif" alt="2"></p><p>接收者收到的字节会存入接收窗口，接收者会对已经正确接收的有序字节进行累计确认，发送完确认应答后，接收窗口就可以向前移动指定字节。<br> 如果某些字节并未按序收到，接收者只会确认最后一个有序的字节，从而乱序的字节就会被重新发送。</p><p><strong>连续ARQ的注意点</strong></p><p>同一时刻发送窗口的大小并不一定和接收窗口一样大。虽然发送窗口的大小是根据接收窗口的大小来设定的，但应答在网络中传输是有时间的，有可能t1时间接收窗口大小为m，但当确认应答抵达发送者时，接收窗口的大小已经发生了变化。此外发送窗口的大小还随网络拥塞情况影响。当网络出现拥塞时，发送窗口将被调小。</p><p>TCP标准并未规定未按序到达的字节的处理方式。但TCP一般都会缓存这些字节，等缺少的字节到达后再交给应用层处理。这比直接丢弃乱序的字节要节约带宽。 </p><p>TCP标准规定接收方必须要有累计确认功能。接收方可以对多个TCP报文段同时确认，但不能拖太长时间，一般是0.5S以内。此外，TCP允许接收者在有数据要发送的时候捎带上确认应答。但这种情况一般较少，因为一般很少有两个方向都要发送数据的情况。</p><h2 id="6-拥塞控制"><a href="#6-拥塞控制" class="headerlink" title="6. 拥塞控制"></a>6. 拥塞控制</h2><p>TCP传输的过程中，发送端开始发送数据的时候，如果刚开始就发送大量的数据，那么就可能造成一些问题。网络可能在开始的时候就很拥堵，如果给网络中在扔出大量数据，那么这个拥堵就会加剧。拥堵的加剧就会产生大量的丢包，就对大量的超时重传，严重影响传输。</p><p>所以TCP引入了==慢启动的机制==，在开始发送数据时，先发送少量的数据探路。探清当前的网络状态如何，再决定多大的速度进行传输。这时候就引入一个叫做拥塞窗口的概念。发送刚开始定义拥塞窗口为 1，每次收到ACK应答，拥塞窗口加 1。在发送数据之前，首先将拥塞窗口与接收端反馈的窗口大小比对，取较小的值作为实际发送的窗口。 </p><p>拥塞窗口的增长是指数级别的。慢启动的机制只是说明在开始的时候发送的少，发送的慢，但是增长的速度是非常快的。为了控制拥塞窗口的增长，不能使拥塞窗口单纯的加倍，设置一个拥塞窗口的阈值，当拥塞窗口大小超过阈值时，不能再按照指数来增长，而是线性的增长。在慢启动开始的时候，慢启动的阈值等于窗口的最大值，一旦造成网络拥塞，发生超时重传时，慢启动的阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。 </p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151233.gif" alt="70"></p><p>拥塞控制是TCP在传输时尽可能快的将数据传输，并且避免拥塞造成的一系列问题。是可靠性的保证，同时也是维护了传输的高效性。</p><p>##7. 校验和<strong>（</strong>用于接收端检验整个数据包在传输过程中是否出错<strong>）</strong></p><p>计算方式：在数据传输的过程中，将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃，补在后面，最后取反，得到校验和。 </p><p>发送方：在发送数据之前计算检验和，并进行校验和的填充。 </p><p>接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方的进行比对。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151234.gif" alt="71"></p><p>注意：如果接收方比对校验和与发送方不一致，那么数据一定传输有误。但是如果接收方比对校验和与发送方一致，数据不一定传输成功。</p><h1 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a><strong>TCP与UDP的区别</strong></h1><p>1.基于连接与无连接；</p><p>2.对系统资源的要求（TCP较多，UDP少）；</p><p>3.UDP程序结构较简单；</p><p>4.流模式与数据报模式 ；</p><p>5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151235.gif" alt="page218image3854176"></p><p><strong>对应的协议不同</strong> </p><p><strong>TCP</strong> 对应的协议: </p><p>(1) <strong>FTP</strong>:定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传 输服务。下载文件，上传主页，都要用到 FTP 服务。 </p><p>2)<strong>Telnet</strong> :它是一种用于远程登录的端口，用户可以以自己的身份远程连接到计算机上，种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服 务器将 23 端口打开，对外提供服务。 </p><p>(3) <strong>SMTP</strong>:定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。 如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。 </p><p>(4) <strong>POP3</strong>:它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端 口。也是说，只要你有相应的使用 POP3 协议的程序(例如 Fo-xmail 或 Outlook)，就可以不以 We b 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件(如是 163 邮箱就没有必要先进入网易网站， 再进入自己的邮-箱来收信)。 </p><p>(5)<strong>HTTP 协议</strong>:是从 Web 服务器传输超文本到本地浏览器的传送协议。 </p><p><strong>UDP</strong> 对应的协议: </p><p>(1) <strong>DNS</strong>:用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。 </p><p>(2) <strong>SNMP</strong>:简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多， 无连接的服务就体现出其优势。 </p><p>(3)<strong>TFTP</strong>(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP 服务。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>互联网协议入门</title>
      <link href="/2019/04/28/ji-suan-ji-wang-luo/hu-lian-wang-xie-yi-ru-men/"/>
      <url>/2019/04/28/ji-suan-ji-wang-luo/hu-lian-wang-xie-yi-ru-men/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a><strong>五层模型</strong></h2><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。</p><p>用户接触到的，只是最上面的一层，根本没有感觉到下面的层。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p><a id="more"></a><p>如何分层有不同的模型，有的模型分七层，有的分四层。我觉得，把互联网分成五层，比较容易解释。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151252.jpg" alt="img"></p><p>如上图所示，最底下的一层叫做”物理层”（Physical Layer），最上面的一层叫做”应用层”（Application Layer），中间的三层（自下而上）分别是”链接层”（Link Layer）、”网络层”（Network Layer）和”传输层”（Transport Layer）。越下面的层，越靠近硬件；越上面的层，越靠近用户。</p><p>###补充：网络分层的优点</p><p>1）各层之间是独立的。某一层并不需要知道它下一层是如何实现的，而仅仅需要知道该层通过层间的接口所提供的服务。由于每一层只实现一种相对独立的功能，因而可以将一个难以处理的复杂问题分解为若干个较容易处理的更小问题，这样，整个问题的复杂度就下降了。</p><p>2）灵活性好。当任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响，此外，对某一层提供的服务还可以进行修改。当某层提供的服务不再需要时，甚至可以将这层取消。</p><p>3）结构上可分割开。各层都可以采用最合适的技术来实现。</p><p>4）易于实现和维护。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个系统已被分解为若干个相对独立的子系统。</p><p>5）能促进标准化工作。因为每一层的功能及其所提供的服务都已有了精确的说明。</p><h2 id="层与协议"><a href="#层与协议" class="headerlink" title="层与协议"></a><strong>层与协议</strong></h2><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则，大家都遵守的规则，就叫做”协议”（protocol）。</p><p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p><p>#实体层</p><p>我们从最底下的一层开始。电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用<strong>光缆、电缆、双绞线、无线电波</strong>等方式。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151253.jpg" alt="img"></p><p>这就叫做”==实体层==”，也叫物理层，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是==负责传送0和1的电信号==。</p><p>#链路层</p><p>##<strong>以太网协议</strong></p><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？这就是”链接层”的功能，它在”实体层”的上方，==确定了0和1的分组方式==。</p><p>早期的时候，每家公司都有自己的==电信号分组方式==。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p><p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：首部（Head）和数据（Data）。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151252.png" alt="img"></p><p>“首部”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p><p>“==首部==”的长度，固定为<strong>18</strong>字节。”数据”的长度，<strong>最短为46字节，最长为1500字节</strong>。因此，==整个”帧”最短为64字节，最长为1518字节==。如果数据很长，就必须分割成多个帧进行发送。</p><h2 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h2><p>上面提到，以太网数据包的”首部”，包含了发送者和接受者的信息。那么，==发送者和接受者是如何标识呢？==</p><p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。==数据包必须是从一块网卡，传送到另一块网卡==。网卡的地址，就是数据包的发送地址和接收地址，这叫做==MAC地址==。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151255.jpg" alt="640"></p><p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是==48个二进制位==，通常用12个十六进制数表示。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151259.jpg" alt="640-3"></p><p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p><h2 id="广播"><a href="#广播" class="headerlink" title="广播"></a><strong>广播</strong></h2><p>定义地址只是第一步，后面还有更多的步骤。首先，<strong>一块网卡怎么会知道另一块网卡的MAC地址</strong>？回答是有一种==ARP协议==，可以解决这个问题。这个留到后面介绍，这里只需要知道，<strong>以太网数据包必须知道接收方的MAC地址，然后才能发送</strong>。</p><p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151260.jpg" alt="640-4"></p><p>上图中，1号计算机向2号计算机发送一个数据包，同一个<strong>子网络</strong>的3号、4号、5号计算机都会收到这个包。它们读取这个包的”首部”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”==广播==”（broadcasting）。</p><p><strong>有了数据包的定义（以太网协议规定的）、网卡的MAC地址（根据ARP协议知道）、广播的发送方式，”链接层”就可以在多台计算机之间传送数据了。</strong></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层的由来"><a href="#网络层的由来" class="headerlink" title="网络层的由来"></a><strong>网络层的由来</strong></h2><p><strong>以太网协议，依靠MAC地址发送数据</strong>。理论上，单单依靠MAC地址，上海的网卡就可以找到洛杉矶的网卡了，技术上是可以实现的。</p><p>但是，这样做有一个重大的缺点。<strong>以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络</strong>。也就是说，如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151261.jpg" alt="640-5"></p><p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。==如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送==。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p><p>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，<strong>使得我们能够区分不同的计算机是否属于同一个子网络</strong>。这套地址就叫做”网络地址”，简称”网址”。</p><p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，<strong>MAC地址是绑定在网卡上的，网络地址则是管理员分配的</strong>，它们只是随机组合在一起。</p><p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p><h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a><strong>IP协议</strong></h2><p><strong>规定网络地址的协议</strong>，叫做IP协议。它所定义的地址，就被称为==IP地址==。目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151262.jpg" alt="640-6"></p><p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p><p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p><p>但是，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p><p>那么，==怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？==这就要用到另一个参数”子网掩码”（subnet mask）。</p><p>所谓”==子网掩码==”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是</p><p>11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p><p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行==AND运算==（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p><p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p><p>总结一下，I==P协议的作用主要有两个==，一个是<strong>为每一台计算机分配IP地址</strong>，另一个是<strong>确定哪些地址在同一个子网络</strong>。</p><h2 id="IP数据包"><a href="#IP数据包" class="headerlink" title="IP数据包"></a><strong>IP数据包</strong></h2><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？</p><p>回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。==这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构==。</p><p>具体来说，==IP数据包==也分为”首部”和”数据”两个部分。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151300.png" alt="640"></p><p>“首部”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151301.png" alt="640-2"></p><h2 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a><strong>ARP协议</strong></h2><p>关于”网络层”，还有最后一点需要说明。因为IP数据包是放在以太网数据包里发送的，所以我们<strong>必须同时知道两个地址</strong>，一个是==对方的MAC地址==，另一个是==对方的IP地址==。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p><p>所以，==我们需要一种机制，能够从IP地址得到MAC地址==。</p><p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用==ARP协议==，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。<strong>如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包</strong>。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层的由来"><a href="#传输层的由来" class="headerlink" title="传输层的由来"></a><strong>传输层的由来</strong></h2><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p><p>也就是说，<strong>我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用</strong>。这个参数就叫做”==端口==”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p><p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p><p>==”传输层”的功能，就是建立”端口到端口”的通信==。相比之下，==”网络层”的功能是建立”主机到主机”的通信==。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把<strong>主机+端口，叫做”套接字”（socket</strong>）。有了它，就可以进行网络应用程序开发了。</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a><strong>UDP协议</strong></h2><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p><p>UDP数据包，也是由”首部”和”数据”两部分组成。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151302.png" alt="img"></p><p>“==首部==”部分主要定义了<strong>发出端口</strong>和<strong>接收端口</strong>，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151302.jpg" alt="img"></p><p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a><strong>TCP协议</strong></h2><p><strong>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到</strong>。</p><p>为了解决这个问题，==提高网络可靠性==，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它==就是有确认机制的UDP协议==，<strong>每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了</strong>。因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p><p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p><h1 id="一个小结"><a href="#一个小结" class="headerlink" title="一个小结"></a>一个小结</h1><p>我们已经知道，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：<img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151306.jpg" alt="img"></p><p><strong>==发送这个包，需要知道两个地址==：</strong></p><p><strong>1</strong>：对方的MAC地址</p><p><strong>2</strong>：对方的IP地址</p><p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过==网关（gateway）==转发。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151307.jpg" alt="img"></p><p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过==路由协议==，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p><p><strong>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</strong></p><table><thead><tr><th>场景</th><th>数据包地址</th></tr></thead><tbody><tr><td>同一个子网络</td><td>对方的MAC地址，对方的IP地址</td></tr><tr><td>非同一个子网络</td><td>网关的MAC地址，对方的IP地址</td></tr></tbody></table><p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p><h1 id="用户的上网设置"><a href="#用户的上网设置" class="headerlink" title="用户的上网设置"></a>用户的上网设置</h1><h2 id="静态IP地址"><a href="#静态IP地址" class="headerlink" title="静态IP地址"></a><strong>静态IP地址</strong></h2><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p><p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p><table><thead><tr><th><strong>1：本机的IP地址</strong></th></tr></thead><tbody><tr><td><strong>2：子网掩码</strong></td></tr><tr><td><strong>3：网关的IP地址</strong></td></tr><tr><td><strong>4：DNS的IP地址</strong></td></tr></tbody></table><p>下图是==Windows系统==的设置窗口:</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151308.png" alt="img"></p><p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”==静态IP地址上网==”。</p><p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p><p>##动态IP地址</p><p>所谓”==动态IP地址==”，<strong>指计算机开机后，会自动分配到一个IP地址，不用人为设定</strong>。它使用的协议叫做==DHCP协议==。</p><p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p><p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p><p>DHCP协议做了一些巧妙的规定。</p><p>###<strong>DHCP协议</strong></p><p>首先，它是一种==应用层协议==，建立在UDP协议之上，所以整个数据包是这样的：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151309.jpg" alt="img"></p><blockquote><p><strong>1</strong>：最前面的”以太网标头（也就是14字节首部）”，<strong>设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址</strong>。前者就是==本机网卡的MAC地址==，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p><p><strong>2</strong>：后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p><p><strong>3</strong>：最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是==68端口==，接收方是==67端口==。</p></blockquote><p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p><p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”==DHCP响应==”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p><p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p><p>#上网设置：小结</p><p>这个部分，需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p><blockquote><p><strong>1</strong>：本机的IP地址</p><p><strong>2</strong>：子网掩码</p><p><strong>3</strong>：网关的IP地址</p><p><strong>4</strong>：DNS的IP地址</p></blockquote><p>有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p><p>#一个实例：访问网页</p><p>##<strong>本机参数</strong></p><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数，在继续往下看之前，大家可以先记在自己的草稿纸上：</p><p><strong>==本机的IP地址==</strong>：192.168.1.100</p><p><strong>==子网掩码==</strong>：255.255.255.0</p><p><strong>==网关的IP地址==</strong>：192.168.1.1</p><p><strong>==DNS的IP地址==</strong>：8.8.8.8</p><p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com。" target="_blank" rel="noopener">www.google.com。</a></p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151310.jpg" alt="img"></p><p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p><p>##<strong>DNS协议</strong></p><p><strong>Domain Name System</strong></p><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a href="http://www.google.com，不知道它的IP地址。" target="_blank" rel="noopener">www.google.com，不知道它的IP地址。</a></p><p>DNS协议可以帮助我们，==将这个网址转换成IP地址==。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个<strong>DNS数据包</strong>（==53端口==）。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151311.jpg" alt="img"></p><p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p><p>##<strong>子网掩码</strong></p><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到==子网掩码==。</p><p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的==AND运算==（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p><p>因此，我们要向Google发送数据包，必须==通过网关192.168.1.1转发==，也就是说，接收方的MAC地址将是网关的MAC地址。</p><p>#应用层协议</p><p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151312.jpg" alt="img"></p><p>HTTP部分的内容，类似于下面这样：</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151313.png" alt="img"></p><p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p><p>##<strong>TCP协议</strong></p><p>TCP数据包需要设置端口，接收方（Google）的==HTTP端口==默认是80，发送方（本机）的端口是一个==随机生成==的1024-65535之间的整数，假定为51775。</p><p>TCP数据包的标头长度为==20字节==，加上嵌入HTTP的数据包，总长度变为4980字节。</p><h2 id="IP协议-1"><a href="#IP协议-1" class="headerlink" title="IP协议"></a><strong>IP协议</strong></h2><p>然后，TCP数据包再嵌入IP数据包。==IP数据包需要设置双方的IP地址==，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p><p>IP数据包的标头长度为==20字节==，加上嵌入的TCP数据包，总长度变为5000字节。</p><p>##<strong>以太网协议</strong></p><p>最后，IP数据包嵌入以太网数据包。<strong>以太网数据包需要设置双方的MAC地址</strong>，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p><p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151314.jpg" alt="img"></p><h2 id="服务器端响应"><a href="#服务器端响应" class="headerlink" title="服务器端响应"></a><strong>服务器端响应</strong></h2><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p><p>==根据IP标头的序号，Google将四个包拼起来==，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p><p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p><p><img src="http://xxh-blog.oss-cn-beijing.aliyuncs.com/2019-06-29-151317.jpg" alt="img"></p><p>这个例子就到此为止，虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互联网入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之赞踩功能</title>
      <link href="/2019/04/24/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-yong-redis-shi-xian-zan-cai-gong-neng/"/>
      <url>/2019/04/24/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-yong-redis-shi-xian-zan-cai-gong-neng/</url>
      
        <content type="html"><![CDATA[<p>#赞踩功能的实现</p><p>##1.LikeController</p><pre><code class="java">@Controllerpublic class LikeController {    @Autowired    HostHolder hostHolder;    @Autowired    LikeService likeService;    @Autowired    NewsService newsService;    @Autowired    EventProducer eventProducer;    @RequestMapping(path = {&quot;/like&quot;}, method = {RequestMethod.GET, RequestMethod.POST})    @ResponseBody    public String like(@Param(&quot;newId&quot;) int newsId) {       //在likeService中进行点赞具体操作        long likeCount = likeService.like(hostHolder.getUser().getId(), EntityType.ENTITY_NEWS, newsId);        // 更新new的被点赞数，其实就是调用DAO层更新数据库里的likeCount        newsService.updateLikeCount(newsId, (int) likeCount);        return ToutiaoUtil.getJSONString(0, String.valueOf(likeCount));    }    @RequestMapping(value = &quot;/dislike&quot;,method = {RequestMethod.POST,RequestMethod.GET})    @ResponseBody    public String dislike(@RequestParam(&quot;newsId&quot;) int newsId){        int userId=hostHolder.getUser().getId();        long likeCount=likeService.disLike(userId, EntityType.ENTITY_NEWS,newsId);        //更新数据库里的likecount值        newsService.updateLikeCount(newsId,(int)likeCount);        return ToutiaoUtil.getJSONString(0,String.valueOf(likeCount));    }}</code></pre><p>##2.前端：</p><p>###home.html </p><pre><code class="html">&lt;div class=&quot;post&quot;&gt;    &lt;div class=&quot;votebar&quot;&gt;     有关点赞的操作        #if ($vo.like &gt; 0)        &lt;button class=&quot;click-like up pressed&quot; data-id=&quot;$!{vo.news.id}&quot; title=&quot;赞同&quot;&gt;&lt;i class=&quot;vote-arrow&quot;&gt;&lt;/i&gt;&lt;span class=&quot;count&quot;&gt;$!{vo.news.likeCount}&lt;/span&gt;&lt;/button&gt;        #else        &lt;button class=&quot;click-like up&quot; data-id=&quot;$!{vo.news.id}&quot; title=&quot;赞同&quot;&gt;&lt;i class=&quot;vote-arrow&quot;&gt;&lt;/i&gt;&lt;span class=&quot;count&quot;&gt;$!{vo.news.likeCount}&lt;/span&gt;&lt;/button&gt;        #end      #有关灭赞的操作        #if($vo.like &lt; 0)        &lt;button class=&quot;click-dislike down pressed&quot; data-id=&quot;$!{vo.news.id}&quot; title=&quot;反对&quot;&gt;&lt;i class=&quot;vote-arrow&quot;&gt;&lt;/i&gt;&lt;/button&gt;        #else        &lt;button class=&quot;click-dislike down&quot; data-id=&quot;$!{vo.news.id}&quot; title=&quot;反对&quot;&gt;&lt;i class=&quot;vote-arrow&quot;&gt;&lt;/i&gt;&lt;/button&gt;        #end</code></pre><p>可以看到点赞和撤赞操作都有对应的<strong>button</strong></p><p>###static/scripts/main/site/home.js</p><pre><code class="javascript">(function (window, undefined) {    var PopupLogin = Base.getClass(&#39;main.component.PopupLogin&#39;);    var PopupUpload = Base.getClass(&#39;main.component.PopupUpload&#39;);    var ActionUtil = Base.getClass(&#39;main.util.Action&#39;);    Base.ready({        initialize: fInitialize,        binds: {            //.表示class #表示id            &#39;click .js-login&#39;: fClickLogin,            &#39;click .js-share&#39;: fClickShare        },        events: {          //一个点赞操作，一个撤赞操作            &#39;click button.click-like&#39;: fClickLike,            &#39;click button.click-dislike&#39;: fClickDisLike        }    });  //其他方法略过    function fClickLike(oEvent) {        var that = this;        var oEl = $(oEvent.currentTarget);        var sId = $.trim(oEl.attr(&#39;data-id&#39;));        // 已经操作过 || 不存在Id || 正在提交 ，则忽略        if (oEl.hasClass(&#39;pressed&#39;) || !sId || that.actioning) {            return;        }        that.actioning = true;        ActionUtil.like({            newsId: sId,            call: function (oResult) {                oEl.find(&#39;span.count&#39;).html(oResult.msg);                oEl.addClass(&#39;pressed&#39;);                oEl.parent().find(&#39;.click-dislike&#39;).removeClass(&#39;pressed&#39;);            },            error: function () {                alert(&#39;出现错误，请重试&#39;);            },            always: function () {                that.actioning = false;            }        });    }    function fClickDisLike(oEvent) {        var that = this;        var oEl = $(oEvent.currentTarget);        var sId = $.trim(oEl.attr(&#39;data-id&#39;));        // 已经操作过 || 不存在Id || 正在提交 ，则忽略        if (oEl.hasClass(&#39;pressed&#39;) || !sId || that.actioning) {            return;        }        that.actioning = true;        ActionUtil.dislike({            newsId: sId,            call: function (oResult) {                oEl.addClass(&#39;pressed&#39;);                var oLikeBtn = oEl.parent().find(&#39;.click-like&#39;);                oLikeBtn.removeClass(&#39;pressed&#39;);                oLikeBtn.find(&#39;span.count&#39;).html(oResult.msg);            },            error: function () {                alert(&#39;出现错误，请重试&#39;);            },            always: function () {                that.actioning = false;            }        });    }})(window);</code></pre><p>###static/scripts/main/util/action.js中</p><pre><code class="javascript">/** * 喜欢 * @param   {Object} oConf *  @param  {String} oConf.newsId 对象id *  @param  {Function} oConf.call 成功回调 *  @param  {Function} oConf.error 失败回调 *  @param  {Function} oConf.always 操作的回调 */function fLike(oConf) {    var that = this;    that.post({        url: &#39;/like&#39;,        data: {newsId: oConf.newsId},        call: oConf.call,        error: oConf.error,        always: oConf.always    });}/** * 不喜欢 * @param   {Object} oConf *  @param  {String} oConf.newsId 对象id *  @param  {Function} oConf.call 成功回调 *  @param  {Function} oConf.error 失败回调 *  @param  {Function} oConf.always 操作的回调 */function fDislike(oConf) {    var that = this;    that.post({        url: &#39;/dislike&#39;,        data: {newsId: oConf.newsId},        call: oConf.call,        error: oConf.error,        always: oConf.always    });}</code></pre><p>简单的说就是当我们点赞时，会激发<strong>url：”/like”</strong>也就是会调用<strong>LikeController</strong>中与<strong>/like</strong>绑定的方法</p><p>##3.LikeService</p><p>###com.nowcoder.service.LikeService</p><pre><code class="java">@Servicepublic class LikeService {    @Autowired    JedisAdapter jedisAdapter;    //判断某个用户对某一项元素是否喜欢,思路就是在redis中找likeKey对应的set里是否有这个点赞人的userid    public int getLikeStatus(int userId,int entityType,int entityId){        String likeKey= RedisKeyUtil.getLikeKey(entityType,entityId);        if (jedisAdapter.sismember(likeKey,String.valueOf(userId))){            return 1;        }        String dislikeKey= RedisKeyUtil.getDisLikeKey(entityType,entityId);        return jedisAdapter.sismember(dislikeKey,String.valueOf(userId))?-1:0;    }    /**     * 喜欢点赞操作     * 返回 喜欢的数量     */    public long like(int userId,int entityType,int entityId){        String likeKey=RedisKeyUtil.getLikeKey(entityType,entityId);        //把用户加到喜欢的likeKey的KV中,就是说这条咨询有多少人喜欢        //也就是说redis里面不同的likeKey作为k，每个likeKey代表的是不同类型(entityType)的特定ID的新闻有多少人喜欢        //V是一个set集合，里面就是为这条新闻点赞的userID们        jedisAdapter.sadd(likeKey,String.valueOf(userId));        //删除不喜欢中的userId        String disLikeKey=RedisKeyUtil.getDisLikeKey(entityType,entityId);        jedisAdapter.srem(disLikeKey,String.valueOf(userId));        //在返回有多少人喜欢        return jedisAdapter.scard(likeKey);    }    /**     * 不喜欢点赞操作     * 返回 喜欢的数量     */    public long disLike(int userId,int entityType,int entityId){        String disLikeKey=RedisKeyUtil.getDisLikeKey(entityType,entityId);        //把用户加到不喜欢的disLikeKey的KV中        jedisAdapter.sadd(disLikeKey,String.valueOf(userId));        //删除喜欢中的userId        String likeKey=RedisKeyUtil.getLikeKey(entityType,entityId);        jedisAdapter.srem(likeKey,String.valueOf(userId));        //在返回有多少人喜欢        return jedisAdapter.scard(likeKey);    }}</code></pre><p>###com.nowcoder.util.ToutiaoUtil</p><pre><code class="java">public class RedisKeyUtil {    public static String SPILT=&quot;:&quot;;    public  static String BIZ_LIKE=&quot;LIKE&quot;;    public  static String BIZ_DISLIKE=&quot;DISLIKE&quot;;    private static String BIZ_EVENT = &quot;EVENT&quot;;    public static String getEventQueueKey() {        return BIZ_EVENT;    }    public static String getLikeKey(int entityId,int entityType){        return BIZ_LIKE+SPILT+String.valueOf(entityType)+SPILT+String.valueOf(entityId);    }    public static String getDisLikeKey(int entityId,int entityType){        return BIZ_DISLIKE+SPILT+String.valueOf(entityType)+SPILT+String.valueOf(entityId);    }}</code></pre><p>在redis中点赞事件存储的kv键值对的名：</p><blockquote><p>点赞：LIKE：int( entityType):int(entityId)</p><p>撤赞：DISLIKE：int( entityType):int(entityId)</p></blockquote><h1 id="redis-常见数据结构以及使用场景分析"><a href="#redis-常见数据结构以及使用场景分析" class="headerlink" title="redis 常见数据结构以及使用场景分析"></a>redis 常见数据结构以及使用场景分析</h1><p>##1.String </p><p>常用命令: set,get,decr,incr,mget 等。 String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。 常规key-value缓存应用; </p><p>常规计数:微博数，粉丝数等。</p><p>###举例：</p><pre><code class="java">        jedis.set(&quot;hello&quot;, &quot;world&quot;);//设置指定 key 的值        print(1, jedis.get(&quot;hello&quot;));//world        jedis.rename(&quot;hello&quot;, &quot;newhello&quot;);//重命名        print(1, jedis.get(&quot;newhello&quot;));//world        jedis.setex(&quot;hello2&quot;, 15, &quot;world&quot;);//为指定的 key 设置值及其过期时间        // 数值操作        jedis.set(&quot;pv&quot;, &quot;100&quot;);        jedis.incr(&quot;pv&quot;);//默认加1        print(2, jedis.get(&quot;pv&quot;));//101        jedis.decrBy(&quot;pv&quot;, 5);//减5        print(2, jedis.get(&quot;pv&quot;));//96        print(3, jedis.keys(&quot;*&quot;));//[newhello, hello2, pv]</code></pre><p>##2.Hash </p><p>常用命令: hget,hset,hgetall 等。 </p><p>Hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅 仅修改这个对象中的某个字段的值。 比如我们可以Hash数据结构来存储用户信息，商品信息等等。</p><p>###举例：</p><pre><code class="java">        // hash, 可变字段        String userKey = &quot;userxx&quot;;        jedis.hset(userKey, &quot;name&quot;, &quot;jim&quot;);//hash中添键值对        jedis.hset(userKey, &quot;age&quot;, &quot;12&quot;);        jedis.hset(userKey, &quot;phone&quot;, &quot;18666666666&quot;);        print(12, jedis.hget(userKey, &quot;name&quot;));//jim        print(13, jedis.hgetAll(userKey));//{phone=18666666666, name=jim, age=12}        jedis.hdel(userKey, &quot;phone&quot;);        print(14, jedis.hgetAll(userKey));//{name=jim, age=12},删除了个phone        print(15, jedis.hexists(userKey, &quot;email&quot;));//false        print(16, jedis.hexists(userKey, &quot;age&quot;));//true        print(17, jedis.hkeys(userKey));//[name, age]        print(18, jedis.hvals(userKey));//[jim, 12]        jedis.hsetnx(userKey, &quot;school&quot;, &quot;zju&quot;);//不存在就添加         jedis.hsetnx(userKey, &quot;name&quot;, &quot;yxy&quot;);//存在就不添加        print(19, jedis.hgetAll(userKey));//{school=zju, name=jim, age=12}</code></pre><p>##3.List </p><p>常用命令: lpush,rpush,lpop,rpop,lrange等 </p><p>list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表， 消息列表等功能都可以用Redis的 list 结构来实现。 </p><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西(一页一页的往下走)，性能高。 </p><p>###举例：</p><pre><code class="java">        String listName = &quot;list&quot;;        jedis.del(listName);        for (int i = 0; i &lt; 10; ++i) {            jedis.lpush(listName, &quot;a&quot; + String.valueOf(i));        }        print(4, jedis.lrange(listName, 0, 12)); // 最近来访10个id:[a9, a8, a7, a6, a5, a4, a3, a2, a1, a0]        print(5, jedis.llen(listName));//10        print(6, jedis.lpop(listName));//a9        print(7, jedis.llen(listName));//9,出去了个a9        print(8, jedis.lrange(listName, 2, 6)); //[a6, a5, a4, a3, a2]        print(9, jedis.lindex(listName, 3));//a5</code></pre><p>##4.Set </p><p>常用命令: sadd,spop,smembers,sunion 等<br> set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。 </p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在 一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。 </p><p>比如:在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常 方便的实现如共同关注、共同粉丝、共同喜好等功能。 </p><p>###项目中用到的：</p><pre><code class="java">/** * 喜欢点赞操作 * 返回 喜欢的数量 */public long like(int userId,int entityType,int entityId){    String likeKey=RedisKeyUtil.getLikeKey(entityType,entityId);    //把用户加到喜欢的likeKey的KV中,就是说这条咨询有多少人喜欢    jedisAdapter.sadd(likeKey,String.valueOf(userId));    //删除不喜欢中的userId    String disLikeKey=RedisKeyUtil.getDisLikeKey(entityType,entityId);    jedisAdapter.srem(disLikeKey,String.valueOf(userId));    //在返回有多少人喜欢    return jedisAdapter.scard(likeKey);}</code></pre><p>补充：redis中的sadd对应redis中的sadd</p><pre><code class="java">SADD KEY_NAME VALUE1..VALUEN</code></pre><blockquote><p>Redis Sadd 命令将一个或多个成员元素加入到集合中，==已经存在于集合的成员元素将被忽略==。</p><p>假如集合 key 不存在，则创建一个只包含添加的元素作成员的集合。</p><p>当集合 key 不是集合类型时，返回一个错误。</p></blockquote><p>实例:</p><pre><code>redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;foo&quot;(integer) 1redis 127.0.0.1:6379&gt; SADD myset &quot;hello&quot;(integer) 0redis 127.0.0.1:6379&gt; SMEMBERS myset1) &quot;hello&quot;2) &quot;foo&quot;</code></pre><pre><code>SISMEMBER KEY VALUE </code></pre><p>==返回值==：</p><p>如果成员元素是集合的成员，返回 1 。 如果成员元素不是集合的成员，或 key 不存在，返回 0 。</p><p>实例:</p><pre><code>redis 127.0.0.1:6379&gt; SADD myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SISMEMBER myset1 &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; SISMEMBER myset1 &quot;world&quot;(integer) 0</code></pre><p>###举例：</p><pre><code class="java">        // 集合，点赞用户群, 共同好友        String likeKey1 = &quot;newsLike1&quot;;        String likeKey2 = &quot;newsLike2&quot;;        for (int i = 0; i &lt; 10; ++i) {            jedis.sadd(likeKey1, String.valueOf(i));            jedis.sadd(likeKey2, String.valueOf(i * 2));        }        print(20, jedis.smembers(likeKey1));//[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]        print(21, jedis.smembers(likeKey2));//[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]        print(22, jedis.sunion(likeKey1, likeKey2));//取俩个set并集 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 16, 18]        print(23, jedis.sdiff(likeKey1, likeKey2));//求不同 [1, 9, 3, 5, 7]        print(24, jedis.sinter(likeKey1, likeKey2));//求交集 [0, 2, 4, 6, 8]        print(25, jedis.sismember(likeKey1, &quot;12&quot;));//false        print(26, jedis.sismember(likeKey2, &quot;12&quot;));//true        jedis.srem(likeKey1, &quot;5&quot;);//删除操作        print(27, jedis.smembers(likeKey1));//[0, 1, 2, 3, 4, 6, 7, 8, 9]        // 从1移动到2        jedis.smove(likeKey2, likeKey1, &quot;14&quot;);//将前一个集合中的指定元素移到后一个集合中        print(28, jedis.smembers(likeKey1));//[0, 1, 2, 3, 4, 6, 7, 8, 9, 14]        print(29, jedis.scard(likeKey1));//求集合中元素的总个数 10</code></pre><p>##5.Sorted Set </p><p>常用命令: zadd,zrange,zrem,zcard等<br> 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 </p><p>举例: 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息(可以理解为按消息维 度的消息排行榜)等信息，适合使用 Redis 中的 SortedSet 结构进行存储。 </p><p>###举例：</p><pre><code class="java">        // 排序集合，有限队列，排行榜        String rankKey = &quot;rankKey&quot;;        jedis.zadd(rankKey, 15, &quot;Jim&quot;);        jedis.zadd(rankKey, 60, &quot;Ben&quot;);        jedis.zadd(rankKey, 90, &quot;Lee&quot;);        jedis.zadd(rankKey, 75, &quot;Lucy&quot;);        jedis.zadd(rankKey, 80, &quot;Mei&quot;);        print(30, jedis.zcard(rankKey));//集合中元素的总个数 5        print(31, jedis.zcount(rankKey, 61, 100));//指定范围内元素的个数 3        // 改错卷了        print(32, jedis.zscore(rankKey, &quot;Lucy&quot;));//75.0        jedis.zincrby(rankKey, 2, &quot;Lucy&quot;);//增加指定数字        print(33, jedis.zscore(rankKey, &quot;Lucy&quot;));//77.0        jedis.zincrby(rankKey, 2, &quot;Luc&quot;);//增加指定数字，没有就创建        print(34, jedis.zscore(rankKey, &quot;Luc&quot;));//2.0        print(35, jedis.zcount(rankKey, 0, 100));//指定范围内元素的个数 5        // 1-4 名 Luc        print(36, jedis.zrange(rankKey, 0, 10));//在指定范围内根据value排key，默认升序 [Luc, Jim, Ben, Lucy, Mei, Lee]        print(36, jedis.zrange(rankKey, 1, 3));//[Jim, Ben, Lucy],默认从头到尾数        print(36, jedis.zrevrange(rankKey, 1, 3));//[Mei, Lucy, Ben] 从尾到头数        for (Tuple tuple : jedis.zrangeByScoreWithScores(rankKey, &quot;60&quot;, &quot;100&quot;)) {            print(37, tuple.getElement() + &quot;:&quot; + String.valueOf(tuple.getScore()));        }        print(38, jedis.zrank(rankKey, &quot;Ben&quot;));//从头到尾排第几 2        print(39, jedis.zrevrank(rankKey, &quot;Ben&quot;));//从尾到头排第几 3</code></pre><h1 id="点赞流程分析："><a href="#点赞流程分析：" class="headerlink" title="点赞流程分析："></a>点赞流程分析：</h1><pre><code class="java">@Controllerpublic class HomeController {    @Autowired    NewsService newsService;    @Autowired    UserService userService;    @Autowired    HostHolder hostHolder;    @Autowired    LikeService likeService;    private List&lt;ViewObject&gt; getNews(int userId, int offset, int limit) {        List&lt;News&gt; newsList = newsService.getLatestNews(userId, offset, limit);        int localUserId = hostHolder.getUser() != null ? hostHolder.getUser().getId() : 0;        List&lt;ViewObject&gt; vos = new ArrayList&lt;&gt;();        for (News news : newsList) {            ViewObject vo = new ViewObject();            vo.set(&quot;news&quot;, news);            vo.set(&quot;user&quot;, userService.getUser(news.getUserId()));            if(localUserId!=0){                //从这在redis中取值                vo.set(&quot;like&quot;, likeService.getLikeStatus(localUserId, EntityType.ENTITY_NEWS, news.getId()));            }else{                vo.set(&quot;like&quot;,0);            }            vos.add(vo);        }        return vos;    }    @RequestMapping(path = {&quot;/&quot;, &quot;/index&quot;}, method = {RequestMethod.GET, RequestMethod.POST})    public String index(Model model,@RequestParam(value = &quot;pop&quot;, defaultValue = &quot;0&quot;) int pop) {        model.addAttribute(&quot;vos&quot;, getNews(0, 0, 10));        if (hostHolder.getUser() != null) {            pop = 0;        }        model.addAttribute(&quot;pop&quot;, pop);        return &quot;home&quot;;    }}</code></pre><p>从上述代码我们能知道：</p><p>项目首页，也就是home.html，通过Model对象接受到从后端传来的vos链表对象。取到的key对应的value是从redis中去的，这就是真正使用redis的原因，存储在内存中，取值速度快。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之异步队列</title>
      <link href="/2019/04/18/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-yi-bu-dui-lie/"/>
      <url>/2019/04/18/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-yi-bu-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><p>点赞，回复评论的时候，表面上是赞数增加了，其实还有很多其他的工作要做。比如，被赞的人收到消息提醒，成就值增加等。一些行为会引起一系列连锁反应。如果在执行点赞功能时立马处理，会影响程序运行效率。而且会造成代码冗余，比如发布新闻，和回复评论都可以使得成就值增加，如果都跟着写在后面的代码里会把成就值增加这段代码写两遍，所以大型服务需要<strong>服务化</strong>和<strong>异步化</strong>。 </p><p><strong>服务化</strong>：某一个单独的业务独立成一个工程，提供接口。不只是service层的一个类。 暴露一些接口，比如数据库服务，如果一个部门要去数据库查询，小公司可能写个SQL语句。对于大公司，需要一个组单独做数据库服务，暴露接口给别的部门用。好处是防止别的部门有数据库权限，数据库单独有一个组维护，出问题找他们运维就好。<br><strong>异步化</strong>：用户点赞，用户首先要知道的是这个赞已经点上了。用户提交Oj，用户要立马知道的是代码有没有通过。而后面应该的东西，比如积分增加了，用户不会有立马想知道的需求，如果间隔几秒钟再更新，用户也不会有很大的意见。<br><strong>异步化的好处：</strong><br>一、能够分开紧急动作和非紧急动作。能够先执行对用户最重要的事务，反馈给用户。其他的相应该事务的动作可以在后台延迟执行， </p><p>二、增加程序的鲁棒性。举提交在线OJ为例，如果用户提交程序代码后，服务器进行判题，判题通过后执行增加积分，成就值这些动作，如果程序在判题后运行失败，服务器不能立刻返回给用户结果。如果是异步化分开后，起码能保证主业务，即判题结果能及时反馈给用户。积分挂了，只会造成用户看不到最新的积分，这个对用户的影响比较小。如下图所示： </p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034022.png" alt="屏幕快照 2019-03-16 下午9.49.31-2825469"></p><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h4 id="在项目中异步架构实现结构："><a href="#在项目中异步架构实现结构：" class="headerlink" title="在项目中异步架构实现结构："></a>在项目中异步架构实现结构：</h4><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034023.png" alt="屏幕快照 2019-03-16 下午9.53.13"></p><h4 id="1-利用JSON进行对象序列化和反序列化"><a href="#1-利用JSON进行对象序列化和反序列化" class="headerlink" title="1.利用JSON进行对象序列化和反序列化"></a>1.利用JSON进行对象序列化和反序列化</h4><p>JSON存到Redis中，后面可以知道是以String形式存储的</p><p><strong>操作封装在JedisAdapter中</strong>：</p><pre><code class="java">    public String get(String key) {        Jedis jedis = null;        try {            jedis = pool.getResource();            return getJedis().get(key);        } catch (Exception e) {            logger.error(&quot;发生异常&quot; + e.getMessage());            return null;        } finally {            if (jedis != null) {                jedis.close();            }        }    }    public void set(String key, String value) {        Jedis jedis = null;        try {            jedis = pool.getResource();            jedis.set(key, value);        } catch (Exception e) {            logger.error(&quot;发生异常&quot; + e.getMessage());        } finally {            if (jedis != null) {                jedis.close();            }        }    }    public void setObject(String key, Object obj) {        set(key, JSON.toJSONString(obj));    }    public &lt;T&gt; T getObject(String key, Class&lt;T&gt; clazz) {        String value = get(key);        if (value != null) {            return JSON.parseObject(value, clazz);        }        return null;    }</code></pre><p>其中将对象序列化过程中：是使用<strong>JSON.toJSONString(Object obj)</strong>的方法将对象序列化为<strong>JSON串</strong></p><p>代码如下：</p><pre><code class="java">/** * 重点：This method serializes the specified object into its equivalent Json representation. Note that this method works fine if the any of the object fields are of generic type, * just the object itself should not be of a generic type. If you want to write out the object to a * {@link Writer}, use {@link #writeJSONString(Writer, Object, SerializerFeature[])} instead. * * @param object the object for which json representation is to be created setting for fastjson * @return Json representation of {@code object}. */public static String toJSONString(Object object) {    return toJSONString(object, emptyFilters);}</code></pre><p><strong>知识点补充</strong></p><p>==测试中序列化和反序列化过程中用到了redis中<strong>String</strong>的操作==：</p><p>例子：</p><pre><code>redis&gt; SET mykey &quot;Hello&quot;OKredis&gt; GET mykey&quot;Hello&quot;redis&gt; </code></pre><hr><h4 id="2-构建事件模型EventModel"><a href="#2-构建事件模型EventModel" class="headerlink" title="2.构建事件模型EventModel"></a>2.构建事件模型EventModel</h4><p>EventModel：代表进入队列的具体活动</p><pre><code class="java">public class EventModel {    //这个触发事件是什么类型    private EventType type;    //触发对象的原目标，谁触发的    private int actorId;    //触发的对象是什么。是新闻还是点赞类型的事件，是哪个事件    private int entityId;    private int entityType;    //触发对象的拥有者(如果是点赞新闻事件，那就是发这条新闻的UserId)    private int entityOwnerId;    //在触发的现场有哪些数据需要保存下来    private Map&lt;String,String&gt; exts=new HashMap&lt;&gt;();    public EventModel() {    }    public EventModel(EventType type) {        this.type = type;    }    public String getExt(String name) {        return exts.get(name);    }    public EventModel setExt(String name, String value) {        exts.put(name, value);        return this;    }    public EventType getType() {        return type;    }    public EventModel setType(EventType type) {        this.type = type;        return this;    }    public int getActorId() {        return actorId;    }    public EventModel setActorId(int actorId) {        this.actorId = actorId;        return this;    }    public int getEntityId() {        return entityId;    }    public EventModel setEntityId(int entityId) {        this.entityId = entityId;        return this;    }    public int getEntityType() {        return entityType;    }    public EventModel setEntityType(int entityType) {        this.entityType = entityType;        return this;    }    public int getEntityOwnerId() {        return entityOwnerId;    }    public EventModel setEntityOwnerId(int entityOwnerId) {        this.entityOwnerId = entityOwnerId;        return this;    }}</code></pre><p>事件的类型：有点赞、评论、登录、发邮件等类型</p><pre><code class="java">public enum EventType {    LIKE(0),    COMMENT(1),    LOGIN(2),    MAIL(3);    private int value;    EventType(int value) {        this.value = value;    }    public int getValue() {        return value;    }}</code></pre><h4 id="3-活动的生产者和消费者"><a href="#3-活动的生产者和消费者" class="headerlink" title="3.活动的生产者和消费者"></a>3.活动的生产者和消费者</h4><h5 id="生产者（EventProducer）"><a href="#生产者（EventProducer）" class="headerlink" title="生产者（EventProducer）"></a>生产者（EventProducer）</h5><p>这个类的功能其实就是把事件模型(代表着一次事件)存储到redis的列表（List）中，其中key是规定标记需要异步化处理的事件的统一名称(在该项目中是”EVENT”)，value是EventModel被序列化后的JSON串。</p><p>简单的说，这个List存放EventModel，以后消费者就在这个List中去event去执行。</p><pre><code class="java">@Servicepublic class EventProducer {    @Autowired    JedisAdapter jedisAdapter;    public boolean fireEvent(EventModel eventModel) {        try {            String json = JSONObject.toJSONString(eventModel);            String key = RedisKeyUtil.getEventQueueKey();            jedisAdapter.lpush(key, json);            return true;        } catch (Exception e) {            return false;        }    }}</code></pre><hr><p><strong>知识点补充</strong>：</p><p>List的Lpush操作：</p><p><strong>将所有指定的值插入到存于 key 的列表的头部</strong>。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。</p><p>可以使用一个命令把多个元素 push 进入列表，只需在命令末尾加上多个指定的参数。元素是从最左端的到最右端的、一个接一个被插入到 list 的头部。 所以对于这个命令例子 <code>LPUSH mylist a b c</code>，返回的列表是 c 为第一个元素， b 为第二个元素， a 为第三个元素。</p><hr><h5 id="消费者-EventConsumer"><a href="#消费者-EventConsumer" class="headerlink" title="消费者(EventConsumer)"></a>消费者(EventConsumer)</h5><p>为了拓展性，首先定义一个EventHandler接口：</p><p>接口中</p><pre><code class="java">public interface EventHandler {    //执行事件    void doHandle(EventModel eventModel);    //handler执行哪些EventModel(如点赞呀，评论呀，登录异常这些。。。)    List&lt;EventType&gt; getSupportEventTypes();}</code></pre><p>具体的执行类：</p><p>目前写了2中执行类：<strong>LikeHandler</strong>和<strong>LoginExceptionHandler</strong></p><p><strong>LikeHandler</strong>：执行点赞的异步操作</p><pre><code class="java">@Componentpublic class LikeHandler implements EventHandler {    @Autowired    MessageService messageService;    @Autowired    UserService userService;    @Override    public void doHandle(EventModel model) {        Message message = new Message();        User user = userService.getUser(model.getActorId());        message.setToId(model.getEntityOwnerId());        message.setContent(&quot;用户&quot; + user.getName() +                &quot; 赞了你的资讯,http://127.0.0.1:8080/news/&quot;                + String.valueOf(model.getEntityId()));        // SYSTEM ACCOUNT        message.setFromId(3);        message.setCreatedDate(new Date());        messageService.addMessage(message);    }    @Override    public List&lt;EventType&gt; getSupportEventTypes() {        return Arrays.asList(EventType.LIKE);    }}</code></pre><p>点赞的异步操作实际就是谁给你点赞了，系统会通知你新闻被点赞了</p><p><strong>LoginExceptionHandler</strong>：</p><pre><code class="java">@Componentpublic class LoginExceptionHandler implements EventHandler {    @Autowired    MessageService messageService;    @Autowired    MailSender mailSender;    @Override    public void doHandle(EventModel eventModel) {        Message message=new Message();        message.setCreatedDate(new Date());        //加入系统默认ID是3        message.setFromId(3);        message.setToId(eventModel.getActorId());        message.setContent(&quot;你上次的登陆IP异常&quot;);        messageService.addMessage(message);        Map&lt;String, Object&gt; map = new HashMap();        map.put(&quot;username&quot;, eventModel.getExt(&quot;username&quot;));        mailSender.sendWithHTMLTemplate(eventModel.getExt(&quot;email&quot;),&quot;登录异常&quot;,                &quot;mails/welcome.html&quot;,map);    }    @Override    public List&lt;EventType&gt; getSupportEventTypes() {        return Arrays.asList(EventType.LOGIN);    }}</code></pre><p>登录异常的异步操作就是给你发个说明异常的email</p><p><strong>Consumer</strong></p><pre><code class="java">@Servicepublic class EventConsumer implements InitializingBean, ApplicationContextAware {    private static final Logger logger = LoggerFactory.getLogger(EventConsumer.class);    private Map&lt;EventType, List&lt;EventHandler&gt;&gt; config = new HashMap&lt;&gt;();    private ApplicationContext applicationContext;    @Autowired    private JedisAdapter jedisAdapter;    @Override    public void afterPropertiesSet() throws Exception {      //这个很关键：根据传入的上下文（applicationContext），查找EventHandler.class类        Map&lt;String, EventHandler&gt; beans = applicationContext.getBeansOfType(EventHandler.class);        if (beans != null) {            for (Map.Entry&lt;String, EventHandler&gt; entry : beans.entrySet()) {              //得到每个EventHandler实现类支持的事件类型                List&lt;EventType&gt; eventTypes = entry.getValue().getSupportEventTypes();                for (EventType type : eventTypes) {                  //每种事件类型对应一个执行该类型事件的执行者列表                    if (!config.containsKey(type)) {                        config.put(type, new ArrayList&lt;EventHandler&gt;());                    }                    // 注册每个事件的处理函数                    config.get(type).add(entry.getValue());                }            }        }        // 启动线程去消费事件        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                // 从队列一直消费                while (true) {                    String key = RedisKeyUtil.getEventQueueKey();                    //brpop返回的是key和value                    List&lt;String&gt; messages = jedisAdapter.brpop(0, key);                    // 第一个元素是队列名字                    for (String message : messages) {                      //因为brpop操作返回一个双元素，第一个是key，第二个是value                        if (message.equals(key)) {                            continue;                        }                        EventModel eventModel = JSON.parseObject(message, EventModel.class);                        if (!config.containsKey(eventModel.getType())) {                            logger.error(&quot;不能识别的事件&quot;);                            continue;                        }                      // 找到这个事件的处理handler列表                        for (EventHandler handler : config.get(eventModel.getType())) {                            handler.doHandle(eventModel);                        }                    }                }            }        });        thread.start();    }    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {        this.applicationContext = applicationContext;    }}</code></pre><hr><p><strong>知识补充</strong>:</p><p>1.补充2个接口：<strong>InitializingBean</strong>和<strong>ApplicationContextAware</strong></p><p>InitializingBean接口：为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候会执行该方法。</p><p>ApplicationContextAware的最本质的应用就是：对当前bean传入对应的Spring上下文。</p><p>appContext.getBeansOfType()方法：</p><pre><code class="java">&lt;T&gt; Map&lt;String, T&gt; getBeansOfType(Class&lt;T&gt; var1) throws BeansException;</code></pre><p> 1.该方法返回一个map类型的实例，map中的key为bean的名字，key对应的内容bean的实例。</p><p> 2.该方法有两种类型的重载：<br>getBeansOfType(Class),获取某一类的所有的bean。</p><p>2.<strong>BRPOP</strong></p><p>是一个阻塞的列表弹出原语。 它是 <a href="http://www.redis.cn/commands/commands/rpop.html" target="_blank" rel="noopener">RPOP</a> 的阻塞版本，因为这个命令会在给定list无法弹出任何元素的时候阻塞连接。 该命令会按照给出的 key 顺序查看 list，并在找到的第一个非空 list 的尾部弹出一个元素。</p><p>​       返回值：</p><p>​         当没有元素可以被弹出时返回一个 <code>nil</code> 的多批量值，并且 timeout 过期。</p><p>​         当有元素弹出时会<strong>返回一个双元素的多批量值</strong>，其中第一个元素是弹出元素的 <code>key</code>，第二个元素是 <code>value</code>。</p><p>​       例子：</p><pre><code>redis&gt; DEL list1 list2(integer) 0redis&gt; RPUSH list1 a b c(integer) 3redis&gt; BRPOP list1 list2 01) &quot;list1&quot;2) &quot;c</code></pre><pre><code>redis 127.0.0.1:6379&gt; BRPOP list1 100</code></pre><p>在以上实例中，操作会被阻塞，如果指定的列表 key list1 存在数据则会返回第一个元素，否则在等待100秒后会返回 nil 。</p><h2 id="开启异步操作"><a href="#开启异步操作" class="headerlink" title="开启异步操作"></a>开启异步操作</h2><p>拿点赞操作举例：</p><pre><code class="java">@RequestMapping(path = {&quot;/like&quot;}, method = {RequestMethod.GET, RequestMethod.POST})@ResponseBodypublic String like(@Param(&quot;newId&quot;) int newsId) {    long likeCount = likeService.like(hostHolder.getUser().getId(), EntityType.ENTITY_NEWS, newsId);    // 更新喜欢数    News news = newsService.getById(newsId);    newsService.updateLikeCount(newsId, (int) likeCount);    //这行    eventProducer.fireEvent(new EventModel(EventType.LIKE)            .setEntityOwnerId(news.getUserId())            .setActorId(hostHolder.getUser().getId()).setEntityId(newsId));    return ToutiaoUtil.getJSONString(0, String.valueOf(likeCount));}</code></pre><p>上述代码，我们调用<strong>eventProducer.fireEvent()</strong>方法，将点赞操作封装成一个EventModel对象，并序列化保存到redis的列表（EVENT）中，然后服务端会调用<strong>EventConsumer</strong>对象，”消费”事件列表中EVENT。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异步消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之解决sql注入攻击</title>
      <link href="/2019/04/03/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-jie-jue-sql-zhu-ru-gong-ji/"/>
      <url>/2019/04/03/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-jie-jue-sql-zhu-ru-gong-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是sql注入攻击"><a href="#什么是sql注入攻击" class="headerlink" title="什么是sql注入攻击"></a>什么是sql注入攻击</h1><p>所谓SQL注入，就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令，比如先前的很多影视网站泄露VIP会员密码大多就是通过WEB表单递交查询字符暴出的，这类表单特别容易受到<a href="http://baike.baidu.com/view/195362.htm" target="_blank" rel="noopener">SQL注入式攻击</a>．</p><h1 id="什么时候最易受到sql注入攻击"><a href="#什么时候最易受到sql注入攻击" class="headerlink" title="什么时候最易受到sql注入攻击"></a>什么时候最易受到sql注入攻击</h1><p>当应用程序使用输入内容来构造动态sql语句以访问数据库时，会发生sql注入攻击。如果代码使用存储过程，而这些存储过程作为包含未筛选的用户输入的 字符串来传递，也会发生sql注入。sql注入可能导致攻击者使用应用程序登陆在数据库中执行命令。如果应用程序使用特权过高的帐户连接到数据库，这种问题会变得很严重。在某些表单中，用户输入的内容直接用来构造动态sql命令，或者作为存储过程的输入参数，这些表单特别容易受到sql注入的攻击。而许多 网站程序在编写时，没有对用户输入的合法性进行判断或者程序中本身的变量处理不当，使应用程序存在安全隐患。这样，用户就可以提交一段数据库查询的代码， 根据程序返回的结果，获得一些敏感的信息或者控制整个服务器，于是sql注入就发生了。</p><h1 id="如何防止SQL注入"><a href="#如何防止SQL注入" class="headerlink" title="如何防止SQL注入"></a>如何防止SQL注入</h1><p>1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双”-“进行转换等。(这可能是前端做的)</p><p>2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。</p><p>3.永远不要使用<a href="http://baike.baidu.com/view/315045.htm" target="_blank" rel="noopener">管理员</a>权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。</p><p>==4.==不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</p><p>5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装</p><p>6.sql注入的检测方法一般采取辅助<a href="http://baike.baidu.com/view/37.htm" target="_blank" rel="noopener">软件</a>或网站平台来检测，软件一般采用sql注入检测工具jsky,网站平台就有亿思网站安全平台检测工具。</p><p>其中4是项目中采用的方法。</p><h1 id="SQL注入实例详解"><a href="#SQL注入实例详解" class="headerlink" title="SQL注入实例详解"></a><strong>SQL注入实例详解</strong></h1><p>比如牛客网，需要输入用户名和密码，当后台核实之后，都输入正确才能登陆网站。</p><p>填好正确的用户名(x)和密码(111111)后，点击提交，将会返回给我们咨询页面。</p><p>对应的sql语句：</p><pre><code class="sql">select * from users where username=&#39;x&#39; and password=&#39;111111&#39;</code></pre><p>很明显，肯定能够成功登陆。但是，如果我们输入一个错误的用户名或密码呢?很明显，肯定登入不了吧。恩，正常情况下是如此，但是对于有SQL注入漏洞的网站来说，只要构造个特殊的“字符串”，照样能够成功登录。</p><p>比如：在用户名输入框中输入:<strong>’ or 1=1#</strong>,密码随便输入，这时候的合成后的SQL查询语句为：</p><pre><code class="sql">select * from users where username=&#39;&#39; or 1=1#&#39; and password=(&#39;&#39;)</code></pre><p>语义分析：“#”在mysql中是注释符，这样#号后面的内容将被mysql视为注释内容，这样就不会去执行了，换句话说，上面的sql语句等价：</p><pre><code class="sql">select * from users where username=&#39;&#39; or 1=1</code></pre><p>因为1=1永远是都是成立的，即where子句总是为真，将该sql进一步简化之后，等价于如下select语句：</p><pre><code class="sql">select * from users </code></pre><p>没错，该sql语句的作用是检索users表中的所有字段。</p><p>这样以来，表中全部用户都会输出，造成大量的用户信息泄漏。</p><h1 id="项目中解决方法"><a href="#项目中解决方法" class="headerlink" title="项目中解决方法"></a>项目中解决方法</h1><p>采用的是第四种方法：不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。</p><h2 id="注册操作"><a href="#注册操作" class="headerlink" title="注册操作"></a>注册操作</h2><pre><code class="java">    public Map&lt;String, Object&gt; register(String username, String password){        Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();        if (StringUtils.isBlank(username)){            map.put(&quot;msgname&quot;,&quot;用户名不能为空&quot;);            return map;        }        if (StringUtils.isBlank(password)){            map.put(&quot;msgpwd&quot;,&quot;密码不能为空&quot;);            return map;        }        User user=userDAO.selectByName(username);        if(user!=null){            map.put(&quot;msgname&quot;,&quot;用户名已被注册&quot;);            return map;        }        //密码强度        user=new User();        user.setName(username);        //用UUID，随机产生5个数字        user.setSalt(UUID.randomUUID().toString().substring(0,5));        /**         * 这种是完全不行的，直接在数据库里传的是明文，信息可能泄露。         */        String head = String.format(&quot;http://images.nowcoder.com/head/%dt.png&quot;, new Random().nextInt(1000));        user.setHeadUrl(head);        //user.setPassword(password);        user.setPassword(ToutiaoUtil.MD5(password+user.getSalt()));        //写入数据库了        userDAO.addUser(user);        //登录        String loginTicket=addLoginTicket(user.getId());        map.put(&quot;ticket&quot;,loginTicket);        return map;    }</code></pre><p>源码可以看到：</p><p>没有直接对输入的密码直接做MD5的加密操作（因为有的工具可以解密通过MD5加密的信息），而是通过UUID产生随机salt（截取了5位），通过ToutiaoUtil.MD5(<strong>password</strong>+<strong>user.getSalt()</strong>)的形式对用户密码加密。这样的方法有2个好处：第一，通过对用户输入的包装，能防止sql注入攻击；第二，在数据库存储的密码不是明文的。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入攻击 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal实现原理</title>
      <link href="/2019/04/02/java/java-duo-xian-cheng/threadlocal-shi-xian-yuan-li/"/>
      <url>/2019/04/02/java/java-duo-xian-cheng/threadlocal-shi-xian-yuan-li/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal是什么、有什么、能做什么？"><a href="#ThreadLocal是什么、有什么、能做什么？" class="headerlink" title="ThreadLocal是什么、有什么、能做什么？"></a>ThreadLocal是什么、有什么、能做什么？</h1><blockquote><p><strong>ThreadLocal提供一个线程（Thread）局部变量，访问到某个变量的每一个线程都拥有自己的局部变量。说白了，ThreadLocal就是想在多线程环境下去保证成员变量的安全。</strong></p></blockquote><p><strong>ThreadLocal提供的方法</strong></p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024223-1.png" alt="4943997-27579dffea7a65b1"></p><blockquote><p><strong>对于ThreadLocal而言，常用的方法，就是get/set/initialValue方法。</strong></p></blockquote><p><strong>我们先来看一个例子</strong></p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024224.png" alt="4943997-1ac9e79efbf24de4"></p><p><strong>运行结果</strong></p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024226.png" alt="4943997-b77b24498ed0a445"></p><blockquote><p><strong>很显然，在这里，并没有通过ThreadLocal达到线程隔离的机制，可是ThreadLocal不是保证线程安全的么？这是什么鬼？</strong></p><p><strong>虽然，ThreadLocal让访问某个变量的线程都拥有自己的局部变量，但是如果这个局部变量都指向同一个对象呢？这个时候ThreadLocal就失效了。仔细观察下图中的代码，你会发现，threadLocal在初始化时返回的都是同一个对象a！</strong></p></blockquote><p><strong>再看个例子：</strong></p><pre><code class="java">public class TestThreadLocal {        public static Integer num = 10;    public static Integer num2 = 11;    public static String num3 = &quot;哈哈哈&quot;;    public static final ThreadLocal threadLocal = new ThreadLocal();    public static final ThreadLocal threadLocal1 = new ThreadLocal();    public static void main(String[] args) {        Thread[] threads = new Thread[5];        for (int i = 0; i &lt; threads.length; i++) {            threads[i] = new Thread(new Runnable() {                @Override                public void run() {                    threadLocal.set(num );                    threadLocal.set(num2);                    threadLocal1.set(num3);                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+threadLocal.get()+&quot;---&quot;+threadLocal1.get());                }            }, &quot;Thread-&quot; + i);        }        for (Thread t:threads) {            t.start();        }    }}</code></pre><p><strong>输出：</strong></p><pre><code>Thread-0:11---哈哈哈Thread-1:11---哈哈哈Thread-2:11---哈哈哈Thread-3:11---哈哈哈Thread-4:11---哈哈哈</code></pre><h1 id="ThreadLocal源码"><a href="#ThreadLocal源码" class="headerlink" title="ThreadLocal源码"></a>ThreadLocal源码</h1><p>##<strong>set操作：</strong></p><pre><code class="java">    /**     * Sets the current thread&#39;s copy of this thread-local variable     * to the specified value.  Most subclasses will have no need to     * override this method, relying solely on the {@link #initialValue}     * method to set the values of thread-locals.     *     * @param value the value to be stored in the current thread&#39;s copy of     *        this thread-local.     */    public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)          //在ThreadLocalMap中设置key为threadlocal对象，value为自己设置的值的键值对            map.set(this, value);        else            createMap(t, value);    }</code></pre><pre><code class="java">    /**     * Get the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param  t the current thread     * @return the map     */    ThreadLocalMap getMap(Thread t) {        return t.threadLocals;//线程的局部变量    }</code></pre><pre><code class="java">    /**     * Create the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param t the current thread     * @param firstValue value for the initial entry of the map     */    void createMap(Thread t, T firstValue) {        t.threadLocals = new ThreadLocalMap(this, firstValue);    }</code></pre><blockquote><p><strong>你会看到，set需要首先获得当前线程对象Thread；</strong></p><p><strong>然后取出当前线程对象的成员变量ThreadLocalMap；</strong></p><p><strong>如果ThreadLocalMap存在，那么进行KEY/VALUE设置，KEY就是ThreadLocal；</strong></p><p><strong>如果ThreadLocalMap没有，那么创建一个；</strong></p><p><strong>说白了，当前线程中存在一个Map变量，KEY是ThreadLocal，VALUE是你设置的值。</strong></p></blockquote><h2 id="get操作："><a href="#get操作：" class="headerlink" title="get操作："></a><strong>get操作：</strong></h2><pre><code class="java">    /**     * Returns the value in the current thread&#39;s copy of this     * thread-local variable.  If the variable has no value for the     * current thread, it is first initialized to the value returned     * by an invocation of the {@link #initialValue} method.     *     * @return the current thread&#39;s value of this thread-local     */    public T get() {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);            if (e != null) {                @SuppressWarnings(&quot;unchecked&quot;)                T result = (T)e.value;                return result;            }        }        return setInitialValue();    }</code></pre><blockquote><p><strong>这里其实揭示了ThreadLocalMap里面的数据存储结构，从上面的代码来看，ThreadLocalMap中存放的就是Entry，Entry的KEY就是ThreadLocal，VALUE就是值。</strong></p></blockquote><p><strong>ThreadLocalMap.Entry：</strong></p><pre><code class="java">        /**         * The entries in this hash map extend WeakReference, using         * its main ref field as the key (which is always a         * ThreadLocal object).  Note that null keys (i.e. entry.get()         * ** null) mean that the key is no longer referenced, so the         * entry can be expunged from table.  Such entries are referred to         * as &quot;stale entries&quot; in the code that follows.         */        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {            /** The value associated with this ThreadLocal. */            Object value;            Entry(ThreadLocal&lt;?&gt; k, Object v) {                super(k);                value = v;            }        }</code></pre><p>可以看到<strong>Entry继承了弱应用</strong>。</p><blockquote><p><strong>在JAVA里面，存在强引用、弱引用、软引用、虚引用。这里主要谈一下强引用和弱引用。</strong></p><p>强引用，就不必说了，类似于：</p><p>A a = new A();</p><p>B b = new B();</p><p>考虑这样的情况：</p><p><strong>C c = new C(b);</strong></p><p><strong>b = null;</strong></p><p>考虑下GC的情况。要知道b被置为null，那么是否意味着一段时间后GC工作可以回收b所分配的内存空间呢？答案是否定的，因为即便b被置为null，但是c仍然持有对b的引用，而且还是强引用，所以GC不会回收b原先所分配的空间！既不能回收利用，又不能使用，这就造成了<strong>内存泄露</strong>。</p><p>那么如何处理呢？</p><p><strong>可以c = null;也可以使用弱引用！（WeakReference w = new WeakReference(b);）</strong></p></blockquote><p>分析到这里，我们可以得到：</p><p>假设方法执行完毕，栈中的ThreadLocal ref出栈，如果Entry中的ThreadLocal的变量对堆中ThreadLocal是强引用的话，GC不会收集使用完毕的ThreadLocal类，这就造成了内存泄漏。但是如果采用的是弱引用，当ref使用完毕，不存在指向ThreadLocal类的引用，这时GC在下次收集时就会收集使用完毕的ThreadLocal类。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024227.png" alt="4943997-cac8c7ca612012f7"></p><p><strong>这里我们思考一个问题：ThreadLocal使用到了弱引用，是否意味着不会存在内存泄露呢？</strong></p><blockquote><p><strong>首先来说，如果把ThreadLocal置为null，那么意味着Heap中的ThreadLocal实例不在有强引用指向，只有弱引用存在，因此GC是可以回收这部分空间的，也就是key是可以回收的。但是value却存在一条从Current Thread过来的强引用链。因此只有当Current Thread销毁时，value才能得到释放。</strong></p><p><strong>因此，只要这个线程对象被gc回收，就不会出现内存泄露，但在threadLocal设为null和线程结束这段时间内不会被回收的，就发生了我们认为的内存泄露。最要命的是线程对象不被回收的情况，比如使用线程池的时候，线程结束是不会销毁的，再次使用的，就可能出现内存泄露。</strong></p><p><strong>那么如何有效的避免呢？</strong></p><p><strong>事实上，在ThreadLocalMap中的set/getEntry方法中，会对key为null（也即是ThreadLocal为null）进行判断，如果为null的话，那么是会对value置为null的。我们也可以通过调用ThreadLocal的remove方法进行释放！</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java-thread-pool</title>
      <link href="/2019/04/02/java/java-duo-xian-cheng/shen-du-jie-du-java-xian-cheng-chi-she-ji-si-xiang-ji-yuan-ma-shi-xian/"/>
      <url>/2019/04/02/java/java-duo-xian-cheng/shen-du-jie-du-java-xian-cheng-chi-she-ji-si-xiang-ji-yuan-ma-shi-xian/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>这篇文章是引用大佬<a href="https://javadoop.com/post/java-thread-pool" target="_blank" rel="noopener">javadoop</a>的文章</p></blockquote><p>我相信大家都看过很多的关于线程池的文章，基本上也是面试必问的，好像我写这篇文章其实是没有什么意义的，不过，我相信你也和我一样，看了很多文章还是一知半解，甚至可能看了很多瞎说的文章。希望大家看过这篇文章以后，就可以完全掌握 Java 线程池了。</p><blockquote><p>我发现好些人都是因为这篇文章来到本站的，希望这篇让人留下第一眼印象的文章能给你带来收获。</p></blockquote><p>本文一大重点是源码解析，不过线程池设计思想以及作者实现过程中的一些巧妙用法是我想传达给读者的。本文还是会一行行关键代码进行分析，目的是为了让那些自己看源码不是很理解的同学可以得到参考。</p><p>线程池是非常重要的工具，如果你要成为一个好的工程师，还是得比较好地掌握这个知识。即使你为了谋生，也要知道，这基本上是面试必问的题目，而且面试官很容易从被面试者的回答中捕捉到被面试者的技术水平。</p><p>本文略长，建议在 pc 上阅读，边看文章边翻源码（Java7 和 Java8 都一样），建议想好好看的读者抽出至少 15 至 30 分钟的整块时间来阅读。当然，如果读者仅为面试准备，可以直接滑到最后的<strong>总结</strong>部分。</p><a id="more"></a><p><strong>目录</strong></p><!-- toc --><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>开篇来一些废话。下图是 java 线程池几个相关类的继承结构：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024221.jpg" alt="1"></p><p>先简单说说这个继承结构，Executor 位于最顶层，也是最简单的，就一个 execute(Runnable runnable) 接口方法定义。</p><p>ExecutorService 也是接口，在 Executor 接口的基础上添加了很多的接口方法，所以<strong>一般来说我们会使用这个接口</strong>。</p><p>然后再下来一层是 AbstractExecutorService，从名字我们就知道，这是抽象类，这里实现了非常有用的一些方法供子类直接使用，之后我们再细说。</p><p>然后才到我们的重点部分 ThreadPoolExecutor 类，这个类提供了关于线程池所需的非常丰富的功能。</p><p>另外，我们还涉及到下图中的这些类：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024222.png" alt="others"></p><p>同在并发包中的 Executors 类，类名中带字母 s，我们猜到这个是工具类，里面的方法都是静态方法，如以下我们最常用的用于生成 ThreadPoolExecutor 的实例的一些方法：</p><pre><code class="java">public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}</code></pre><p>另外，由于线程池支持<strong>获取线程执行的结果</strong>，所以，引入了 Future 接口，RunnableFuture 继承自此接口，然后我们最需要关心的就是它的实现类 FutureTask。到这里，记住这个概念，在线程池的使用过程中，我们是往线程池提交任务（task），<strong>使用过线程池的都知道，我们提交的每个任务是实现了 Runnable 接口的，其实就是先将 Runnable 的任务包装成 FutureTask，然后再提交到线程池</strong>。这样，读者才能比较容易记住 FutureTask 这个类名：它首先是一个任务（Task），然后具有 Future 接口的语义，即可以在将来（Future）得到执行的结果。</p><p>当然，线程池中的 BlockingQueue 也是非常重要的概念，<strong>如果线程数达到 corePoolSize，我们的每个任务会提交到等待队列中，等待线程池中的线程来取任务并执行</strong>。这里的 <strong>BlockingQueue</strong> 通常我们使用其实现类 <strong>LinkedBlockingQueue</strong>、<strong>ArrayBlockingQueue</strong> 和 <strong>SynchronousQueue</strong>，每个实现类都有不同的特征，使用场景之后会慢慢分析。想要详细了解各个 BlockingQueue 的读者，可以参考我的前面的一篇对 BlockingQueue 的各个实现类进行详细分析的文章。</p><blockquote><p>把事情说完整：除了上面说的这些类外，还有一个很重要的类，就是定时任务实现类 ScheduledThreadPoolExecutor，它继承自本文要重点讲解的 ThreadPoolExecutor，用于实现定时执行。不过本文不会介绍它的实现，我相信读者看完本文后可以比较容易地看懂它的源码。</p></blockquote><p>以上就是本文要介绍的知识，废话不多说，开始进入正文。</p><h2 id="Executor-接口"><a href="#Executor-接口" class="headerlink" title="Executor 接口"></a>Executor 接口</h2><pre><code class="java">/*  * @since 1.5 * @author Doug Lea */public interface Executor {    void execute(Runnable command);}</code></pre><p>我们可以看到 Executor 接口非常简单，就一个 <code>void execute(Runnable command)</code> 方法，代表提交一个任务。为了让大家理解 java 线程池的整个设计方案，我会按照 Doug Lea 的设计思路来多说一些相关的东西。</p><p>我们经常这样启动一个线程：</p><pre><code class="java">new Thread(new Runnable(){  // do something}).start();</code></pre><p>用了线程池 Executor 后就可以像下面这么使用：</p><pre><code class="java">Executor executor = anExecutor;executor.execute(new RunnableTask1());executor.execute(new RunnableTask2());</code></pre><p>如果我们希望线程池同步执行每一个任务，我们可以这么实现这个接口：</p><pre><code class="java">class DirectExecutor implements Executor {    public void execute(Runnable r) {        r.run();// 这里不是用的new Thread(r).start()，也就是说没有启动任何一个新的线程。    }}</code></pre><p>我们希望每个任务提交进来后，直接启动一个新的线程来执行这个任务，我们可以这么实现：</p><pre><code class="java">class ThreadPerTaskExecutor implements Executor {    public void execute(Runnable r) {        new Thread(r).start();  // 每个任务都用一个新的线程来执行    }}</code></pre><p>我们再来看下怎么组合两个 Executor 来使用，下面这个实现是将所有的任务都加到一个 queue 中，然后从 queue 中取任务，交给真正的执行器执行，这里采用 synchronized 进行并发控制：</p><pre><code class="java">class SerialExecutor implements Executor {    // 任务队列    final Queue&lt;Runnable&gt; tasks = new ArrayDeque&lt;Runnable&gt;();    // 这个才是真正的执行器    final Executor executor;    // 当前正在执行的任务    Runnable active;    // 初始化的时候，指定执行器    SerialExecutor(Executor executor) {        this.executor = executor;    }    // 添加任务到线程池: 将任务添加到任务队列，scheduleNext 触发执行器去任务队列取任务    public synchronized void execute(final Runnable r) {        tasks.offer(new Runnable() {            public void run() {                try {                    r.run();                } finally {                    scheduleNext();                }            }        });        if (active == null) {            scheduleNext();        }    }    protected synchronized void scheduleNext() {        if ((active = tasks.poll()) != null) {            // 具体的执行转给真正的执行器 executor            executor.execute(active);        }    }}</code></pre><p>当然了，Executor 这个接口只有提交任务的功能，太简单了，我们想要更丰富的功能，比如我们想知道执行结果、我们想知道当前线程池有多少个线程活着、已经完成了多少任务等等，这些都是这个接口的不足的地方。接下来我们要介绍的是继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口，这个接口提供了比较丰富的功能，也是我们最常使用到的接口。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>一般我们定义一个线程池的时候，往往都是使用这个接口：</p><pre><code class="java">ExecutorService executor = Executors.newFixedThreadPool(args...);ExecutorService executor = Executors.newCachedThreadPool(args...);</code></pre><p>因为这个接口中定义的一系列方法大部分情况下已经可以满足我们的需要了。</p><p>那么我们简单初略地来看一下这个接口中都有哪些方法：</p><pre><code class="java">public interface ExecutorService extends Executor {    // 关闭线程池，已提交的任务继续执行，不接受继续提交新任务    void shutdown();    // 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务    // 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务    List&lt;Runnable&gt; shutdownNow();    // 线程池是否已关闭    boolean isShutdown();    // 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回true    // 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true    boolean isTerminated();    // 等待所有任务完成，并设置超时时间    // 我们这么理解，实际应用中是，先调用 shutdown 或 shutdownNow，    // 然后再调这个方法等待所有的线程真正地完成，返回值意味着有没有超时    boolean awaitTermination(long timeout, TimeUnit unit)            throws InterruptedException;    // 提交一个 Callable 任务    &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);    // 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值，    // 因为 Runnable 的 run 方法本身并不返回任何东西    &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);    // 提交一个 Runnable 任务    Future&lt;?&gt; submit(Runnable task);    // 执行所有任务，返回 Future 类型的一个 list    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)            throws InterruptedException;    // 也是执行所有任务，但是这里设置了超时时间    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                  long timeout, TimeUnit unit)            throws InterruptedException;    // 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)            throws InterruptedException, ExecutionException;    // 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，    // 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常    &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                    long timeout, TimeUnit unit)            throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><p>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。</p><div id="FutureTask"></div>## FutureTask<p>在继续往下层介绍 ExecutorService 的实现类之前，我们先来说说相关的类 FutureTask。</p><pre><code class="java">Future   -&gt; RunnableFuture -&gt; FutureTaskRunnable -&gt; RunnableFutureFutureTask 通过 RunnableFuture 间接实现了 Runnable 接口，所以每个 Runnable 通常都先包装成 FutureTask，然后调用 executor.execute(Runnable command) 将其提交给线程池</code></pre><p>我们知道，Runnable 的 void run() 方法是没有返回值的，所以，通常，如果我们需要的话，会在 submit 中指定第二个参数作为返回值：</p><pre><code class="java">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</code></pre><p>其实到时候会通过这两个参数，将其包装成 Callable。</p><p>Callable 也是因为线程池的需要，所以才有了这个接口。它和 Runnable 的区别在于 run() 没有返回值，而 Callable 的 call() 方法有返回值，同时，如果运行出现异常，call() 方法会抛出异常。</p><pre><code class="java">public interface Callable&lt;V&gt; {    V call() throws Exception;}</code></pre><p>在这里，就不展开说 FutureTask 类了，因为本文篇幅本来就够大了，这里我们需要知道怎么用就行了。</p><p>下面，我们来看看 <code>ExecutorService</code> 的抽象实现 <code>AbstractExecutorService</code> 。</p><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。</p><p>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的 <code>void execute(Runnable command)</code> 由于不需要获取结果，不会进行 FutureTask 的包装。</p><blockquote><p>需要获取结果（FutureTask），用 submit 方法，不需要获取结果，可以用 execute 方法。</p></blockquote><p>下面，我将一行一行源码地来分析这个类，跟着源码来看看其实现吧：</p><blockquote><p>Tips: invokeAny 和 invokeAll 方法占了这整个类的绝大多数篇幅，读者可以选择适当跳过，因为它们可能在你的实践中使用的频次比较低，而且它们不带有承前启后的作用，不用担心会漏掉什么导致看不懂后面的代码。</p></blockquote><pre><code class="java">public abstract class AbstractExecutorService implements ExecutorService {    // RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask    // 下面两个 newTaskFor 方法用于将我们的任务包装成 FutureTask 提交到线程池中执行    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {        return new FutureTask&lt;T&gt;(runnable, value);    }    protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {        return new FutureTask&lt;T&gt;(callable);    }    // 提交任务    public Future&lt;?&gt; submit(Runnable task) {        if (task == null) throw new NullPointerException();        // 1. 将任务包装成 FutureTask        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);        // 2. 交给执行器执行，execute 方法由具体的子类来实现        // 前面也说了，FutureTask 间接实现了Runnable 接口。        execute(ftask);        return ftask;    }    public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {        if (task == null) throw new NullPointerException();        // 1. 将任务包装成 FutureTask        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);        // 2. 交给执行器执行        execute(ftask);        return ftask;    }    public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {        if (task == null) throw new NullPointerException();        // 1. 将任务包装成 FutureTask        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);        // 2. 交给执行器执行        execute(ftask);        return ftask;    }    // 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了    // 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，    // 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常    private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                            boolean timed, long nanos)        throws InterruptedException, ExecutionException, TimeoutException {        if (tasks == null)            throw new NullPointerException();        // 任务数        int ntasks = tasks.size();        if (ntasks == 0)            throw new IllegalArgumentException();        //         List&lt;Future&lt;T&gt;&gt; futures= new ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);        // ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器        // 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中        // 这也是为什么这个类的名字里面有个 Completion 的原因吧。        ExecutorCompletionService&lt;T&gt; ecs =            new ExecutorCompletionService&lt;T&gt;(this);        try {            // 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常            ExecutionException ee = null;            long lastTime = timed ? System.nanoTime() : 0;            Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();            // 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交            futures.add(ecs.submit(it.next()));            // 提交了一个任务，所以任务数量减 1            --ntasks;            // 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)            int active = 1;            for (;;) {                // ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果                // BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空                Future&lt;T&gt; f = ecs.poll();                // 为 null，说明刚刚提交的第一个线程还没有执行完成                // 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能                if (f == null) {                    if (ntasks &gt; 0) {                        --ntasks;                        futures.add(ecs.submit(it.next()));                        ++active;                    }                    // 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明                    // 任务都执行完成了。其实我也没理解为什么这里做一次 break？                    // 因为我认为 active 为 0 的情况，必然从下面的 f.get() 返回了                    // 2018-02-23 感谢读者 newmicro 的 comment，                    //  这里的 active == 0，说明所有的任务都执行失败，那么这里是 for 循环出口                    else if (active == 0)                        break;                    // 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时                    else if (timed) {                        // 带等待的 poll 方法                        f = ecs.poll(nanos, TimeUnit.NANOSECONDS);                        // 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了                        if (f == null)                            throw new TimeoutException();                        long now = System.nanoTime();                        nanos -= now - lastTime;                        lastTime = now;                    }                    // 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)                    // take() 方法会阻塞，直到有元素返回，说明有任务结束了                    else                        f = ecs.take();                }                /*                 * 我感觉上面这一段并不是很好理解，这里简单说下。                 * 1. 首先，这在一个 for 循环中，我们设想每一个任务都没那么快结束，                 *     那么，每一次都会进到第一个分支，进行提交任务，直到将所有的任务都提交了                 * 2. 任务都提交完成后，如果设置了超时，那么 for 循环其实进入了“一直检测是否超时”                       这件事情上                 * 3. 如果没有设置超时机制，那么不必要检测超时，那就会阻塞在 ecs.take() 方法上，                       等待获取第一个执行结果                 * 4. 如果所有的任务都执行失败，也就是说 future 都返回了，                       但是 f.get() 抛出异常，那么从 active == 0 分支出去(感谢 newmicro 提出)                         // 当然，这个需要看下面的 if 分支。                 */                // 有任务结束了                if (f != null) {                    --active;                    try {                        // 返回执行结果，如果有异常，都包装成 ExecutionException                        return f.get();                    } catch (ExecutionException eex) {                        ee = eex;                    } catch (RuntimeException rex) {                        ee = new ExecutionException(rex);                    }                }            }// 注意看 for 循环的范围，一直到这里            if (ee == null)                ee = new ExecutionException();            throw ee;        } finally {            // 方法退出之前，取消其他的任务            for (Future&lt;T&gt; f : futures)                f.cancel(true);        }    }    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException, ExecutionException {        try {            return doInvokeAny(tasks, false, 0);        } catch (TimeoutException cannotHappen) {            assert false;            return null;        }    }    public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                           long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException {        return doInvokeAny(tasks, true, unit.toNanos(timeout));    }    // 执行所有的任务，返回任务结果。    // 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务    // 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)        throws InterruptedException {        if (tasks == null)            throw new NullPointerException();        List&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());        boolean done = false;        try {            // 这个很简单            for (Callable&lt;T&gt; t : tasks) {                // 包装成 FutureTask                RunnableFuture&lt;T&gt; f = newTaskFor(t);                futures.add(f);                // 提交任务                execute(f);            }            for (Future&lt;T&gt; f : futures) {                if (!f.isDone()) {                    try {                        // 这是一个阻塞方法，直到获取到值，或抛出了异常                        // 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的                        // 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了                        f.get();                    } catch (CancellationException ignore) {                    } catch (ExecutionException ignore) {                    }                }            }            done = true;            // 这个方法返回，不像其他的场景，返回 List&lt;Future&gt;，其实执行结果还没出来            // 这个方法返回是真正的返回，任务都结束了            return futures;        } finally {            // 为什么要这个？就是上面说的有异常的情况            if (!done)                for (Future&lt;T&gt; f : futures)                    f.cancel(true);        }    }    // 带超时的 invokeAll，我们找不同吧    public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,                                         long timeout, TimeUnit unit)        throws InterruptedException {        if (tasks == null || unit == null)            throw new NullPointerException();        long nanos = unit.toNanos(timeout);        List&lt;Future&lt;T&gt;&gt; futures = new ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());        boolean done = false;        try {            for (Callable&lt;T&gt; t : tasks)                futures.add(newTaskFor(t));            long lastTime = System.nanoTime();            Iterator&lt;Future&lt;T&gt;&gt; it = futures.iterator();            // 提交一个任务，检测一次是否超时            while (it.hasNext()) {                execute((Runnable)(it.next()));                long now = System.nanoTime();                nanos -= now - lastTime;                lastTime = now;                // 超时                if (nanos &lt;= 0)                    return futures;            }            for (Future&lt;T&gt; f : futures) {                if (!f.isDone()) {                    if (nanos &lt;= 0)                        return futures;                    try {                        // 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，                        // 因为上面其实已经用掉了一些时间了                        f.get(nanos, TimeUnit.NANOSECONDS);                    } catch (CancellationException ignore) {                    } catch (ExecutionException ignore) {                    } catch (TimeoutException toe) {                        return futures;                    }                    long now = System.nanoTime();                    nanos -= now - lastTime;                    lastTime = now;                }            }            done = true;            return futures;        } finally {            if (!done)                for (Future&lt;T&gt; f : futures)                    f.cancel(true);        }    }}</code></pre><p>到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法，所以最重要的 execute(Runnable runnable) 方法还没出现，需要等具体执行器来实现这个最重要的部分，这里我们要说的就是 ThreadPoolExecutor 类了。</p><blockquote><p>鉴于本文的篇幅，我觉得看到这里的读者应该已经不多了，快餐文化使然啊！我写的每篇文章都力求让读者可以通过我的一篇文章而记住所有的相关知识点，所以篇幅不免长了些。其实，工作了很多年的话，会有一个感觉，比如说线程池，即使看了 20 篇各种总结，也不如一篇长文实实在在讲解清楚每一个知识点，有点<strong>少即是多，多即是少</strong>的意味了。</p></blockquote><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><strong>ThreadPoolExecutor 是 JDK 中的线程池实现</strong>，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p><p>我们可以基于它来进行业务上的扩展，以实现我们需要的其他功能，比如实现定时任务的类 ScheduledThreadPoolExecutor 就继承自 ThreadPoolExecutor。当然，这不是本文关注的重点，下面，还是赶紧进行源码分析吧。</p><p>首先，我们来看看线程池实现中的几个概念和处理流程。</p><p>我们先回顾下提交任务的几个方法：</p><pre><code class="java">public Future&lt;?&gt; submit(Runnable task) {    if (task == null) throw new NullPointerException();    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);    execute(ftask);    return ftask;}public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {    if (task == null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);    execute(ftask);    return ftask;}public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {    if (task == null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);    execute(ftask);    return ftask;}</code></pre><p>一个最基本的概念是，submit 方法中，参数是 Runnable 类型（也有Callable 类型），这个参数不是用于 new Thread(<strong>runnable</strong>).start() 中的，此处的这个参数不是用于启动线程的，这里指的是<strong>任务</strong>，任务要做的事情是 run() 方法里面定义的或 Callable 中的 call() 方法里面定义的。</p><p>初学者往往会搞混这个，因为 Runnable 总是在各个地方出现，经常把一个 Runnable 包到另一个 Runnable 中。请把它想象成有个 Task 接口，这个接口里面有一个 run() 方法（我想作者只是不想因为这个再定义一个完全可以用 Runnable 来代替的接口，Callable 的出现，完全是因为 Runnable 不能满足需要）。</p><p>我们回过神来继续往下看，我画了一个简单的示意图来描述线程池中的一些主要的构件：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024223.png" alt="pool-1"></p><p>当然，上图没有考虑队列是否有界，<strong>提交任务时队列满了怎么办</strong>？<strong>什么情况下会创建新的线程</strong>？<strong>提交任务时线程池满了怎么办</strong>？<strong>空闲线程怎么关掉</strong>？这些问题下面我们会一一解决。</p><p>我们经常会使用 <code>Executors</code> 这个工具类来快速构造一个线程池，对于初学者而言，这种工具类是很有用的，开发者不需要关注太多的细节，只要知道自己需要一个线程池，仅仅提供必需的参数就可以了，其他参数都采用作者提供的默认值。</p><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}</code></pre><p>这里先不说有什么区别，它们最终都会导向这个构造方法：</p><pre><code class="java">    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) {        if (corePoolSize &lt; 0 ||            maximumPoolSize &lt;= 0 ||            maximumPoolSize &lt; corePoolSize ||            keepAliveTime &lt; 0)            throw new IllegalArgumentException();        // 这几个参数都是必须要有的        if (workQueue == null || threadFactory == null || handler == null)            throw new NullPointerException();        this.corePoolSize = corePoolSize;        this.maximumPoolSize = maximumPoolSize;        this.workQueue = workQueue;        this.keepAliveTime = unit.toNanos(keepAliveTime);        this.threadFactory = threadFactory;        this.handler = handler;    }</code></pre><h3 id="构造函数的6个属性"><a href="#构造函数的6个属性" class="headerlink" title="构造函数的6个属性"></a>构造函数的6个属性</h3><p>基本上，上面的构造方法中列出了我们最需要关心的几个属性了，下面逐个介绍下构造方法中出现的这几个属性：</p><ul><li><p>==corePoolSize==</p><blockquote><p>核心线程数，不要抠字眼，反正先记着有这么个属性就可以了。</p></blockquote></li><li><p>==maximumPoolSize==</p><blockquote><p>最大线程数，线程池允许创建的最大线程数。</p></blockquote></li><li><p>==workQueue==</p><blockquote><p>任务队列，BlockingQueue 接口的某个实现（常使用 ArrayBlockingQueue 和 LinkedBlockingQueue）。</p></blockquote></li><li><p>==keepAliveTime==</p><blockquote><p><strong>空闲线程的保活时间，如果某线程的空闲时间超过这个值都没有任务给它做，那么可以被关闭了</strong>。注意这个值并不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数 corePoolSize，那么这些线程不会因为空闲太长时间而被关闭，当然，也可以通过调用 <code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</p></blockquote></li><li><p>==threadFactory==</p><blockquote><p>用于生成线程，一般我们可以用默认的就可以了。通常，我们可以通过它将我们的线程的名字设置得比较可读一些，如 Message-Thread-1， Message-Thread-2 类似这样。</p></blockquote></li><li><p>==handler==</p><blockquote><p>当线程池已经满了，但是又有新的任务提交的时候，该采取什么策略由这个来指定。有几种方式可供选择，像抛出异常、直接拒绝然后返回等，也可以自己实现相应的接口实现自己的逻辑，这个之后再说。</p></blockquote></li></ul><p>除了上面几个属性外，我们再看看其他重要的属性。</p><p>Doug Lea 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 5 亿多，现在还没有哪个机器能起这么多线程的吧）。我们知道，java 语言在整数编码上是统一的，都是采用补码的形式，下面是简单的移位操作和布尔操作，都是挺简单的。</p><pre><code class="java">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数// 很多初学者很喜欢在自己的代码中写很多 29 这种数字，或者某个特殊的字符串，然后分布在各个地方，这是非常糟糕的private static final int COUNT_BITS = Integer.SIZE - 3;// 000 11111111111111111111111111111// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536870911// 以我们现在计算机的实际情况，这个数量还是够用的private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;// 我们说了，线程池的状态存放在高 3 位中// 运算结果为 111跟29个0：111 00000000000000000000000000000private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;// 000 00000000000000000000000000000private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;// 001 00000000000000000000000000000private static final int STOP       =  1 &lt;&lt; COUNT_BITS;// 010 00000000000000000000000000000private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;// 011 00000000000000000000000000000private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态private static int runStateOf(int c)     { return c &amp; ~CAPACITY; }// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数private static int workerCountOf(int c)  { return c &amp; CAPACITY; }private static int ctlOf(int rs, int wc) { return rs | wc; }/* * Bit field accessors that don&#39;t require unpacking ctl. * These depend on the bit layout and on workerCount being never negative. */private static boolean runStateLessThan(int c, int s) {    return c &lt; s;}private static boolean runStateAtLeast(int c, int s) {    return c &gt;= s;}private static boolean isRunning(int c) {    return c &lt; SHUTDOWN;}</code></pre><p>上面就是对一个整数的简单的位操作，几个操作方法将会在后面的源码中一直出现，所以读者最好把方法名字和其代表的功能记住，看源码的时候也就不需要来来回回翻了。</p><p>在这里，介绍下线程池中的各个状态和状态变化的转换过程：</p><ul><li>==RUNNING==：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务</li><li>==SHUTDOWN==：不接受新的任务提交，但是会继续处理等待队列中的任务</li><li>==STOP==：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程</li><li>==TIDYING==：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()</li><li>==TERMINATED==：terminated() 方法结束后，线程池的状态就会变成这个</li></ul><blockquote><p>RUNNING 定义为 -1，SHUTDOWN 定义为 0，其他的都比 0 大，所以等于 0 的时候不能提交任务，大于 0 的话，连正在执行的任务也需要中断。</p></blockquote><p>看了这几种状态的介绍，读者大体也可以猜到十之八九的状态转换了，各个状态的转换过程有以下几种：</p><ul><li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li><li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li><li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li><li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li><li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li></ul><p>上面的几个记住核心的就可以了，尤其第一个和第二个。</p><p>另外，我们还要看看一个内部类 Worker，因为 Doug Lea 把线程池中的线程包装成了一个个 Worker，翻译成工人，就是线程池中做任务的线程。所以到这里，我们知道<strong>任务是 Runnable（内部叫 task 或 command），线程是 Worker</strong>。</p><p>Worker 这里又用到了抽象类 AbstractQueuedSynchronizer。题外话，AQS 在并发中真的是到处出现，而且非常容易使用，写少量的代码就能实现自己需要的同步方式（对 AQS 源码感兴趣的读者请参看我之前写的几篇文章）。</p><pre><code class="java">private final class Worker    extends AbstractQueuedSynchronizer    implements Runnable{    private static final long serialVersionUID = 6138294804551838833L;    // 这个是真正的线程，任务靠你啦    final Thread thread;    // 前面说了，这里的 Runnable 是任务。为什么叫 firstTask？因为在创建线程的时候，如果同时指定了    // 这个线程起来以后需要执行的第一个任务，那么第一个任务就是存放在这里的(线程可不止执行这一个任务)    // 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了    Runnable firstTask;    // 用于存放此线程完全的任务数，注意了，这里用了 volatile，保证可见性    volatile long completedTasks;    // Worker 只有这一个构造方法，传入 firstTask，也可以传 null    Worker(Runnable firstTask) {        setState(-1); // inhibit interrupts until runWorker        this.firstTask = firstTask;        // 调用 ThreadFactory 来创建一个新的线程        this.thread = getThreadFactory().newThread(this);    }    // 这里调用了外部类的 runWorker 方法    public void run() {        runWorker(this);    }    ...// 其他几个方法没什么好看的，就是用 AQS 操作，来获取这个线程的执行权，用了独占锁}</code></pre><p>前面虽然啰嗦，但是简单。有了上面的这些基础后，我们终于可以看看 ThreadPoolExecutor 的 execute 方法了，前面源码分析的时候也说了，各种方法都最终依赖于 execute 方法：</p><pre><code class="java">public void execute(Runnable command) {    if (command == null)        throw new NullPointerException();    // 前面说的那个表示 “线程池状态” 和 “线程数” 的整数    int c = ctl.get();    // 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，    // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)    if (workerCountOf(c) &lt; corePoolSize) {        // 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了        // 至于执行的结果，到时候会包装到 FutureTask 中。        // 返回 false 代表线程池不允许提交任务        if (addWorker(command, true))            return;        c = ctl.get();    }    // 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {        /* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里         */        int recheck = ctl.get();        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程        // 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    }    // 如果 workQueue 队列满了，那么进入到这个分支    // 以 maximumPoolSize 为界创建新的 worker，    // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略    else if (!addWorker(command, false))        reject(command);}</code></pre><blockquote><p>对创建线程的错误理解：如果线程数少于 corePoolSize，创建一个线程，如果线程数在 [corePoolSize, maximumPoolSize] 之间那么可以创建线程或复用空闲线程，keepAliveTime 对这个区间的线程有效。</p><p>从上面的几个分支，我们就可以看出，上面的这段话是错误的。</p></blockquote><p>上面这些一时半会也不可能全部消化搞定，我们先继续往下吧，到时候再回头看几遍。</p><p>这个方法非常重要 addWorker(Runnable firstTask, boolean core) 方法，我们看看它是怎么创建新的线程的：</p><pre><code class="java">// 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null// 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界线，也就说创建这个线程的时候，//         如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求//         如果是 false，代表使用最大线程数 maximumPoolSize 作为界线private boolean addWorker(Runnable firstTask, boolean core) {    retry:    for (;;) {        int c = ctl.get();        int rs = runStateOf(c);        // 这个非常不好理解        // 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：        // 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED        // 2. firstTask != null        // 3. workQueue.isEmpty()        // 简单分析下：        // 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行        // 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务        // 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的        if (rs &gt;= SHUTDOWN &amp;&amp;            ! (rs == SHUTDOWN &amp;&amp;               firstTask == null &amp;&amp;               ! workQueue.isEmpty()))            return false;        for (;;) {            int wc = workerCountOf(c);            if (wc &gt;= CAPACITY ||                wc &gt;= (core ? corePoolSize : maximumPoolSize))                return false;            // 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了            // 这里失败的话，说明有其他线程也在尝试往线程池中创建线程            if (compareAndIncrementWorkerCount(c))                break retry;            // 由于有并发，重新再读取一下 ctl            c = ctl.get();            // 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了            // 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池            // 那么需要回到外层的for循环            if (runStateOf(c) != rs)                continue retry;            // else CAS failed due to workerCount change; retry inner loop        }    }    /*      * 到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了，     * 因为该校验的都校验了，至于以后会发生什么，那是以后的事，至少当前是满足条件的     */    // worker 是否已经启动    boolean workerStarted = false;    // 是否已将这个 worker 添加到 workers 这个 HashSet 中    boolean workerAdded = false;    Worker w = null;    try {        final ReentrantLock mainLock = this.mainLock;        // 把 firstTask 传给 worker 的构造方法        w = new Worker(firstTask);        // 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程        final Thread t = w.thread;        if (t != null) {            // 这个是整个类的全局锁，持有这个锁才能让下面的操作“顺理成章”，            // 因为关闭一个线程池需要这个锁，至少我持有锁的期间，线程池不会被关闭            mainLock.lock();            try {                int c = ctl.get();                int rs = runStateOf(c);                // 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况                // 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务                if (rs &lt; SHUTDOWN ||                    (rs == SHUTDOWN &amp;&amp; firstTask == null)) {                    // worker 里面的 thread 可不能是已经启动的                    if (t.isAlive())                        throw new IllegalThreadStateException();                    // 加到 workers 这个 HashSet 中                    workers.add(w);                    int s = workers.size();                    // largestPoolSize 用于记录 workers 中的个数的最大值                    // 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值                    if (s &gt; largestPoolSize)                        largestPoolSize = s;                    workerAdded = true;                }            } finally {                mainLock.unlock();            }            // 添加成功的话，启动这个线程            if (workerAdded) {                // 启动线程                t.start();                workerStarted = true;            }        }    } finally {        // 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉        if (! workerStarted)            addWorkerFailed(w);    }    // 返回线程是否启动成功    return workerStarted;}</code></pre><p>简单看下 addWorkFailed 的处理：</p><pre><code class="java">// workers 中删除掉相应的 worker// workCount 减 1private void addWorkerFailed(Worker w) {    final ReentrantLock mainLock = this.mainLock;    mainLock.lock();    try {        if (w != null)            workers.remove(w);        decrementWorkerCount();        // rechecks for termination, in case the existence of this worker was holding up termination        tryTerminate();    } finally {        mainLock.unlock();    }}</code></pre><p>回过头来，继续往下走。我们知道，worker 中的线程 start 后，其 run 方法会调用 runWorker 方法：</p><pre><code class="java">// Worker 类的 run() 方法public void run() {    runWorker(this);}</code></pre><p>继续往下看 runWorker 方法：</p><pre><code class="java">// 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行// 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取final void runWorker(Worker w) {    //     Thread wt = Thread.currentThread();    // 该线程的第一个任务(如果有的话)    Runnable task = w.firstTask;    w.firstTask = null;    w.unlock(); // allow interrupts    boolean completedAbruptly = true;    try {        // 循环调用 getTask 获取任务        while (task != null || (task = getTask()) != null) {            w.lock();                      // 如果线程池状态大于等于 STOP，那么意味着该线程也要中断            if ((runStateAtLeast(ctl.get(), STOP) ||                 (Thread.interrupted() &amp;&amp;                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;                !wt.isInterrupted())                wt.interrupt();            try {                // 这是一个钩子方法，留给需要的子类实现                beforeExecute(wt, task);                Throwable thrown = null;                try {                    // 到这里终于可以执行任务了                    task.run();                } catch (RuntimeException x) {                    thrown = x; throw x;                } catch (Error x) {                    thrown = x; throw x;                } catch (Throwable x) {                    // 这里不允许抛出 Throwable，所以转换为 Error                    thrown = x; throw new Error(x);                } finally {                    // 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现                    afterExecute(task, thrown);                }            } finally {                // 置空 task，准备 getTask 获取下一个任务                task = null;                // 累加完成的任务数                w.completedTasks++;                // 释放掉 worker 的独占锁                w.unlock();            }        }        completedAbruptly = false;    } finally {        // 如果到这里，需要执行线程关闭：        // 1. 说明 getTask 返回 null，也就是说，这个 worker 的使命结束了，执行关闭        // 2. 任务执行过程中发生了异常        // 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说        // 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理        // 限于篇幅，我不准备分析这个方法了，感兴趣的读者请自行分析源码        processWorkerExit(w, completedAbruptly);    }}</code></pre><p>我们看看 getTask() 是怎么获取任务的，这个方法写得真的很好，每一行都很简单，组合起来却所有的情况都想好了：</p><pre><code class="java">// 此方法有三种可能：// 1. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，//      它们会一直等待任务// 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭// 3. 如果发生了以下条件，此方法必须返回 null://    - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)//    - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务//    - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行private Runnable getTask() {    boolean timedOut = false; // Did the last poll() time out?    retry:    for (;;) {        int c = ctl.get();        int rs = runStateOf(c);        // 两种可能        // 1. rs == SHUTDOWN &amp;&amp; workQueue.isEmpty()        // 2. rs &gt;= STOP        if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {            // CAS 操作，减少工作线程数            decrementWorkerCount();            return null;        }        boolean timed;      // Are workers subject to culling?        for (;;) {            int wc = workerCountOf(c);            // 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭            timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;            // 这里 break，是为了不往下执行后一个 if (compareAndDecrementWorkerCount(c))            // 两个 if 一起看：如果当前线程数 wc &gt; maximumPoolSize，或者超时，都返回 null            // 那这里的问题来了，wc &gt; maximumPoolSize 的情况，为什么要返回 null？            //    换句话说，返回 null 意味着关闭线程。            // 那是因为有可能开发者调用了 setMaximumPoolSize 将线程池的 maximumPoolSize 调小了            if (wc &lt;= maximumPoolSize &amp;&amp; ! (timedOut &amp;&amp; timed))                break;            if (compareAndDecrementWorkerCount(c))                return null;            c = ctl.get();  // Re-read ctl            // compareAndDecrementWorkerCount(c) 失败，线程池中的线程数发生了改变            if (runStateOf(c) != rs)                continue retry;            // else CAS failed due to workerCount change; retry inner loop        }        // wc &lt;= maximumPoolSize 同时没有超时        try {            // 到 workQueue 中获取任务            Runnable r = timed ?                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :                workQueue.take();            if (r != null)                return r;            timedOut = true;        } catch (InterruptedException retry) {            // 如果此 worker 发生了中断，采取的方案是重试            // 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法，            // 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，            // 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null            timedOut = false;        }    }}</code></pre><p>到这里，基本上也说完了整个流程，读者这个时候应该回到 execute(Runnable command) 方法，看看各个分支，我把代码贴过来一下：</p><pre><code class="java">public void execute(Runnable command) {    if (command == null)        throw new NullPointerException();    // 前面说的那个表示 “线程池状态” 和 “线程数” 的整数    int c = ctl.get();    // 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，    // 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)    if (workerCountOf(c) &lt; corePoolSize) {        // 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了        // 至于执行的结果，到时候会包装到 FutureTask 中。        // 返回 false 代表线程池不允许提交任务        if (addWorker(command, true))            return;        c = ctl.get();    }    // 到这里说明，要么当前线程数大于等于核心线程数，要么刚刚 addWorker 失败了    // 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中    if (isRunning(c) &amp;&amp; workQueue.offer(command)) {        /* 这里面说的是，如果任务进入了 workQueue，我们是否需要开启新的线程         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里         */        int recheck = ctl.get();        // 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略        if (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        // 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程        // 到这里，我们知道了，这块代码的真正意图是：担心任务提交到队列中了，但是线程都关闭了        else if (workerCountOf(recheck) == 0)            addWorker(null, false);    }    // 如果 workQueue 队列满了，那么进入到这个分支    // 以 maximumPoolSize 为界创建新的 worker，    // 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略    else if (!addWorker(command, false))        reject(command);}</code></pre><p>上面各个分支中，有两种情况会调用 reject(command) 来处理任务，因为按照正常的流程，线程池此时不能接受这个任务，所以需要执行我们的拒绝策略。接下来，我们说一说 ThreadPoolExecutor 中的拒绝策略。</p><pre><code class="java">final void reject(Runnable command) {    // 执行拒绝策略    handler.rejectedExecution(command, this);}</code></pre><p>此处的 handler 我们需要在构造线程池的时候就传入这个参数，它是 RejectedExecutionHandler 的实例。</p><p>RejectedExecutionHandler 在 ThreadPoolExecutor 中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p><pre><code class="java">// 只要线程池没有被关闭，那么由提交任务的线程自己来执行这个任务。public static class CallerRunsPolicy implements RejectedExecutionHandler {    public CallerRunsPolicy() { }    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        if (!e.isShutdown()) {            r.run();        }    }}// 不管怎样，直接抛出 RejectedExecutionException 异常// 这个是默认的策略，如果我们构造线程池的时候不传相应的 handler 的话，那就会指定使用这个public static class AbortPolicy implements RejectedExecutionHandler {    public AbortPolicy() { }    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +                                             &quot; rejected from &quot; +                                             e.toString());    }}// 不做任何处理，直接忽略掉这个任务public static class DiscardPolicy implements RejectedExecutionHandler {    public DiscardPolicy() { }    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {    }}// 这个相对霸道一点，如果线程池没有被关闭的话，// 把队列队头的任务(也就是等待了最长时间的)直接扔掉，然后提交这个任务到等待队列中public static class DiscardOldestPolicy implements RejectedExecutionHandler {    public DiscardOldestPolicy() { }    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {        if (!e.isShutdown()) {            e.getQueue().poll();            e.execute(r);        }    }}</code></pre><p>到这里，ThreadPoolExecutor 的源码算是分析结束了。单纯从源码的难易程度来说，ThreadPoolExecutor 的源码还算是比较简单的，只是需要我们静下心来好好看看罢了。</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>这节其实也不是分析 Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p><ul><li><strong>生成一个固定大小的线程池</strong>：</li></ul><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}</code></pre><p>最大线程数设置为与核心线程数相等，此时 keepAliveTime 设置为 0（因为这里它是没用的，即使不为 0，线程池默认也不会回收 corePoolSize 内的线程），任务队列采用 LinkedBlockingQueue，无界队列。</p><p>过程分析：==刚开始，每提交一个任务都创建一个 worker，当 worker 的数量达到 nThreads 后，不再创建新的线程，而是把任务提交到 LinkedBlockingQueue 中，而且之后线程数始终为 nThreads==。</p><ul><li><strong>生成只有一个线程的固定线程池</strong>，这个更简单，和上面的一样，只要设置线程数为 1 就可以了：</li></ul><pre><code class="java">public static ExecutorService newSingleThreadExecutor() {    return new FinalizableDelegatedExecutorService        (new ThreadPoolExecutor(1, 1,                                0L, TimeUnit.MILLISECONDS,                                new LinkedBlockingQueue&lt;Runnable&gt;()));}</code></pre><ul><li><strong>生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池</strong>：</li></ul><pre><code class="java">public static ExecutorService newCachedThreadPool() {    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                  60L, TimeUnit.SECONDS,                                  new SynchronousQueue&lt;Runnable&gt;());}</code></pre><p>核心线程数为 0，最大线程数为 Integer.MAX_VALUE，keepAliveTime 为 60 秒，任务队列采用 SynchronousQueue。</p><p>这种线程池对于任务可以比较快速地完成的情况有比较好的性能。如果线程空闲了 60 秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有的线程都会被关闭，整个线程池不会占用任何的系统资源。</p><p>过程分析：我把 execute 方法的主体黏贴过来，让大家看得明白些。鉴于 corePoolSize 是 0，那么提交任务的时候，直接将任务提交到队列中，由于采用了 SynchronousQueue，所以如果是第一个任务提交的时候，offer 方法肯定会返回 false，因为此时没有任何 worker 对这个任务进行接收，那么将进入到最后一个分支来创建第一个 worker。之后再提交任务的话，取决于是否有空闲下来的线程对任务进行接收，如果有，会进入到第二个 if 语句块中，否则就是和第一个任务一样，进到最后的 else if 分支创建新线程。</p><pre><code class="java">int c = ctl.get();// corePoolSize 为 0，所以不会进到这个 if 分支if (workerCountOf(c) &lt; corePoolSize) {    if (addWorker(command, true))        return;    c = ctl.get();}// offer 如果有空闲线程刚好可以接收此任务，那么返回 true，否则返回 falseif (isRunning(c) &amp;&amp; workQueue.offer(command)) {    int recheck = ctl.get();    if (! isRunning(recheck) &amp;&amp; remove(command))        reject(command);    else if (workerCountOf(recheck) == 0)        addWorker(null, false);}else if (!addWorker(command, false))    reject(command);</code></pre><blockquote><p>SynchronousQueue 是一个比较特殊的 BlockingQueue，其本身不储存任何元素，它有一个虚拟队列（或虚拟栈），不管读操作还是写操作，如果当前队列中存储的是与当前操作相同模式的线程，那么当前操作也进入队列中等待；如果是相反模式，则配对成功，从当前队列中取队头节点。具体的信息，可以看我的另一篇关于 BlockingQueue 的文章。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我一向不喜欢写总结，因为我把所有需要表达的都写在正文中了，写小篇幅的总结并不能真正将话说清楚，本文的总结部分为准备面试的读者而写，希望能帮到面试者或者没有足够的时间看完全文的读者。</p><h3 id="1-java-线程池有哪些关键属性？"><a href="#1-java-线程池有哪些关键属性？" class="headerlink" title="1.java 线程池有哪些关键属性？"></a>1.java 线程池有哪些关键属性？</h3><blockquote><p><strong>corePoolSize</strong>，<strong>maximumPoolSize</strong>，<strong>workQueue</strong>，<strong>keepAliveTime</strong>，<strong>rejectedExecutionHandler</strong></p><p><strong>corePoolSize</strong> 到 <strong>maximumPoolSize</strong> 之间的线程会被回收，当然 corePoolSize 的线程也可以通过设置而得到回收（allowCoreThreadTimeOut(true)）。</p><p><strong>workQueue</strong> ==用于存放任务，添加任务的时候，如果当前线程数超过了 corePoolSize，那么往该队列中插入任务，线程池中的线程会负责到队列中拉取任务==。</p><p><strong>keepAliveTime</strong> ==用于设置空闲时间==，如果线程数超出了 corePoolSize，并且有些线程的空闲时间超过了这个值，会执行关闭这些线程的操作</p><p><strong>rejectedExecutionHandler</strong> 用于处理当线程池不能执行此任务时的情况，默认有<strong>==抛出 RejectedExecutionException 异常==</strong>、<strong>==忽略任务==</strong>、<strong>==使用提交任务的线程来执行此任务==</strong>和<strong>==将队列中等待最久的任务删除，然后提交此任务==</strong>这四种策略，默认为抛出异常。</p></blockquote><h3 id="2-说说线程池中的线程创建时机？"><a href="#2-说说线程池中的线程创建时机？" class="headerlink" title="2.说说线程池中的线程创建时机？"></a>2.说说线程池中的线程创建时机？</h3><blockquote><ol><li><strong>如果当前线程数少于 corePoolSize</strong>，那么提交任务的时候创建一个新的线程，并由这个线程执行这个任务；</li><li>如果当<strong>前线程数已经达到 corePoolSize，那么将提交的任务添加到队列中</strong>，等待线程池中的线程去队列中取任务；</li><li><strong>如果队列已满</strong>，那么创建新的线程来执行任务，需要保证池中的线程数不会超过 maximumPoolSize，如果此时线程数超过了 maximumPoolSize，那么执行拒绝策略。</li></ol></blockquote><p><strong>注意</strong>：如果将队列设置为无界队列，那么线程数达到 corePoolSize 后，其实线程数就不会再增长了。</p><ol><li><p>Executors.newFixedThreadPool(…) 和 Executors.newCachedThreadPool() 构造出来的线程池有什么差别？</p><blockquote><p>Executors.newFixedThreadPool(…) ：生成一个固定大小的线程池</p></blockquote><pre><code class="java">public static ExecutorService newFixedThreadPool(int nThreads) {    return new ThreadPoolExecutor(nThreads, nThreads,                                  0L, TimeUnit.MILLISECONDS,                                  new LinkedBlockingQueue&lt;Runnable&gt;());}</code></pre></li></ol><blockquote><p>Executors.newCachedThreadPool() ：生成一个需要的时候就创建新的线程，同时可以复用之前创建的线程（如果这个线程当前没有任务）的线程池</p></blockquote><pre><code class="java">   public static ExecutorService newCachedThreadPool() {       return new ThreadPoolExecutor(0, Integer.MAX_VALUE,                                     60L, TimeUnit.SECONDS,                                     new SynchronousQueue&lt;Runnable&gt;());   }</code></pre><ol start="2"><li><p>任务执行过程中发生异常怎么处理？</p><blockquote><p>如果某个任务执行出现异常，那么执行任务的线程会被关闭，而不是继续接收其他任务。然后会启动一个新的线程来代替它。</p></blockquote></li><li><p>什么时候会执行拒绝策略？</p><blockquote><ol><li>workers 的数量达到了 corePoolSize（任务此时需要进入任务队列），任务入队成功，与此同时线程池被关闭了，而且关闭线程池并没有将这个任务出队，那么执行拒绝策略。这里说的是非常边界的问题，入队和关闭线程池并发执行，读者仔细看看 execute 方法是怎么进到第一个 reject(command) 里面的。</li><li>workers 的数量大于等于 corePoolSize，将任务加入到任务队列，可是队列满了，任务入队失败，那么准备开启新的线程，可是线程数已经达到 maximumPoolSize，那么执行拒绝策略。</li></ol></blockquote></li></ol><h1 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h1><p>线程池中的<strong>核心线程数</strong>，当提交一个任务时，线程池创建一个新线程执行任务，一直到当前线程数等于<br>corePoolSize;如果当前线程数为 corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行;<br>如果阻塞队列满了，那就创建新的线程执行当前任务;直到线程池中的线程数达到 maxPoolSize,这<br>时再有任务来，只能执行 reject()处理该任务;</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之云存储</title>
      <link href="/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-yun-cun-chu/"/>
      <url>/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-yun-cun-chu/</url>
      
        <content type="html"><![CDATA[<p>#上传图片到七牛云，做云存储</p><p>com.nowcoder.controller.NewsController：</p><pre><code class="java">    /**     *     * @param file 向服务器上传的图片的二进制流     * @return     */    //图片传输的时候就是二进制流，不需要模板渲染，所以用@ResponseBody    @RequestMapping(value = &quot;/uploadImage/&quot;,method = RequestMethod.POST)    @ResponseBody    public String uploadImage(@RequestParam(&quot;file&quot;) MultipartFile file){      try{          //上传图片到本地          //String fileUrl=newsService.saveImage(file);          //上传图片到七牛云          String fileUrl = qiniuService.saveImage(file);          if (fileUrl==null){              return ToutiaoUtil.getJSONString(1, &quot;上传图片失败&quot;);          }          return ToutiaoUtil.getJSONString(0, fileUrl);      }catch (Exception e){          logger.error(&quot;上传图片失败&quot;+e.getMessage());          return ToutiaoUtil.getJSONString(1,&quot;上传失败&quot;);      }    }</code></pre><p>com.nowcoder.service.QiniuService：</p><p>大致思路：通过上传文件的文件名，检查其后缀(fileExt)是否为服务支持的后缀，然后通过UUID随机产生(String)fileName+fileExt,最后上传的文件在云中的名字：QINIU_IMAGE_DOMAIN+fileName+fileExt。</p><pre><code class="java">@Servicepublic class QiniuService {    private static final Logger logger = LoggerFactory.getLogger(QiniuService.class);    //...生成上传凭证，然后准备上传    //设置好账号的ACCESS_KEY和SECRET_KEY    String accessKey = &quot;S_FdXUJAL7pSpDx-NUo8TaYzj2rJbsEPEAiZ8FrL&quot;;    String secretKey = &quot;HjtyyBQEcjrvpqM0zqTo05vcWrNaKD1LzhQDURhf&quot;;    String bucket = &quot;toutiao&quot;;    private static String QINIU_IMAGE_DOMAIN = &quot;http://pnmtwczgg.bkt.clouddn.com/&quot;;    UploadManager uploadManager = new UploadManager();    //密钥配置    Auth auth = Auth.create(accessKey, secretKey);  //核心方法    public String saveImage(MultipartFile file) throws IOException {    //简单上传，使用默认策略，只需要设置上传的空间名就可以了    String upToken = auth.uploadToken(bucket);try {    int dotPos = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);    if (dotPos &lt; 0) {        return null;    }    String fileExt = file.getOriginalFilename().substring(dotPos + 1).toLowerCase();    if (!ToutiaoUtil.isFileAllowed(fileExt)) {        return null;    }    //文件在云上的存储名    String fileName = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;) + &quot;.&quot; + fileExt;    //调用put方法上传    /**     *  file.getBytes():图片的字节流     *  fileName：随机生成的图片名     *  upToken：你指定存储的云空间     */    Response response = uploadManager.put(file.getBytes(), fileName, upToken);    //打印返回的信息    if (response.isOK() &amp;&amp; response.isJson()) {        return QINIU_IMAGE_DOMAIN + JSONObject.parseObject(response.bodyString()).get(&quot;key&quot;);    } else {        logger.error(&quot;七牛异常:&quot; + response.bodyString());        return null;    }    } catch (QiniuException e) {    // 请求失败时打印的异常的信息    logger.error(&quot;七牛异常:&quot; + e.getMessage());    return null;        }    }}</code></pre><p>#优势：</p><p>1.图片做单独的服务器，cdn内容分发网络，内容分发到各个节点，能够更快的访问静态文件。 </p><p>2.云上有封装好的附加功能，比如：可以做实时缩图和实时切图，或者鉴黄。 </p><p>   CDN的全称是Content Delivery Network，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265" target="_blank" rel="noopener">内容分发网络</a>。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。   </p><p>#知识点补充：</p><p>##什么是MultipartFile？</p><p>MultipartFile是spring类型，代表HTML中form data方式上传的文件，包含二进制数据+文件名称。</p><h2 id="什么是CDN？"><a href="#什么是CDN？" class="headerlink" title="什么是CDN？"></a>什么是CDN？</h2><p>CDN的全称是==Content Delivery Network==，即<a href="https://baike.baidu.com/item/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/4034265" target="_blank" rel="noopener">内容分发网络</a>。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。  </p><p>#疑问：</p><p>##图片上传到云上，其中的过程？</p><p>先来看</p><pre><code class="js">/**var oPopupUpload = new PopupUpload({}); */(function (window) {    var PopupUpload = Base.createClass(&#39;main.component.PopupUpload&#39;);    var Popup = Base.getClass(&#39;main.component.Popup&#39;);    var Upload = Base.getClass(&#39;main.component.Upload&#39;);    var Component = Base.getClass(&#39;main.component.Component&#39;);    var Util = Base.getClass(&#39;main.base.Util&#39;);    Base.mix(PopupUpload, Component, {        _tpl: [            &#39;&lt;div&gt;&#39;,              &#39;&lt;div class=&quot;form-group&quot;&gt;&#39;,                &#39;&lt;div class=&quot;form-group&quot;&gt;&#39;,                    &#39;&lt;label class=&quot;col-sm-2 control-label&quot;&gt;上传图片&lt;/label&gt;&#39;,                    &#39;&lt;div class=&quot;js-image-container col-sm-10&quot;&gt;&#39;,                        &#39;&lt;a href=&quot;javascript:void(0);&quot; class=&quot;btn btn-info btn-upload js-upload-btn&quot; style=&quot;diplay:inline-block;position:relative;&quot;&gt;上传图片&lt;/a&gt;&#39;,                    &#39;&lt;/div&gt;&#39;,                &#39;&lt;/div&gt;&#39;,                  &#39;&lt;div class=&quot;form-group&quot;&gt;&lt;label class=&quot;col-sm-2 control-label&quot;&gt;标题&lt;/label&gt;&lt;div class=&quot;col-sm-10&quot;&gt;&lt;input class=&quot;js-title form-control&quot; type=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#39;,                  &#39;&lt;div class=&quot;form-group&quot;&gt;&lt;label class=&quot;col-sm-2 control-label&quot;&gt;链接&lt;/label&gt;&lt;div class=&quot;col-sm-10&quot;&gt;&lt;input class=&quot;js-link form-control&quot; type=&quot;text&quot;&gt;&lt;/div&gt;&lt;/div&gt;&#39;,                  &#39;&lt;div class=&quot;form-group&quot;&gt;&#39;,                        &#39;&lt;div class=&quot;col-lg-10 col-lg-offset-2&quot;&gt;&#39;,                            &#39;&lt;input type=&quot;submit&quot; value=&quot;提交&quot; class=&quot;js-submit btn btn-default btn-info&quot;&gt;&#39;,                        &#39;&lt;/div&gt;&#39;,                    &#39;&lt;/div&gt;&#39;,            &#39;&lt;/div&gt;&#39;].join(&#39;&#39;),        listeners: [{            name: &#39;render&#39;,            type: &#39;custom&#39;,            handler: function () {                var that = this;                var oEl = that.getEl();                var oUploadBtn = oEl.find(&#39;a.js-upload-btn&#39;);                new Upload({                    targetEl: oUploadBtn,                    url: &#39;/uploadImage/&#39;,                    check: function (oFile, sType, nFileSize) {                        var sMsg = nFileSize === 0 ? &#39;文件大小不能为0&#39; : /image/gi.test(sType || &#39;&#39;) ? &#39;&#39; : &#39;文件格式不正确&#39;;                        sMsg &amp;&amp; alert(sMsg);                        return !sMsg;                    },                    call: function (oResult) {                        var sUrl = $.trim(oResult.msg);                        if (oResult.code !== 0) {                            return alert(&#39;出现错误，请重试&#39;);                        }                        that.image = sUrl;                        that.showImage(sUrl);                    }                });            }        }, {            name: &#39;click input.js-submit&#39;,            handler: function () {                var that = this;                var oEl = that.getEl();                var sTitle = $.trim(oEl.find(&#39;input.js-title&#39;).val());                var sLink = $.trim(oEl.find(&#39;input.js-link&#39;).val());                if (!sTitle) {                    return alert(&#39;标题不能为空&#39;);                }                if (!sLink) {                    return alert(&#39;链接不能为空&#39;);                }                if (!that.image) {                    return alert(&#39;图片不能为空&#39;);                }                if (that.requesting) {                    return;                }                that.requesting = true;                $.ajax({                    url: &#39;/user/addNews/&#39;,                    method: &#39;post&#39;,                    data: {image: that.image, title: sTitle, link: sLink},                    dataType: &#39;json&#39;                }).done(function (oResult) {                    that.emit(&#39;done&#39;);                }).fail(function (oResult) {                    alert(&#39;出现错误，请重试&#39;);                }).always(function () {                    that.requesting = false;                });            }        }]})(window);</code></pre><p>我可以看到：有2个function，一个是触发URL:<strong>/uploadImage/</strong>;一个触发：<strong>/user/addNews/</strong>；</p><p>触发的url与NewsController中方法的url对应，如<strong>/user/addNews/</strong>与addNews方法上的@RequestMapping(path={“/user/addNews/“}对应。</p><p>通俗点讲，</p><ol><li>当点击上传图片，并选择图片确定，这时会执行<strong>/uploadImage/</strong>方法，并返回经过处理的JSON串，JSON串=带有七牛外连接+图片名字（UUID生成）+后缀名。前端收到后端返回的JSON串，根据code值来判断是否上传成功。这是一个典型的前端和后端的交互根据json串。</li><li>当我们点击提交时，前端会将访问URL锁定在<strong>/user/addNews/</strong>下，并使用POST方法，将data域中的image（就是步骤1中图片的路径名），title和link与addNews方法中的参数绑定，进而将这条咨询添加到数据库中。</li></ol><p>com.nowcoder.controller.NewsController：</p><pre><code class="java">    /**     *     * @param file 向服务器上传的图片的二进制流     * @return     */    //图片传输的时候就是二进制流，不需要模板渲染，所以用@ResponseBody    @RequestMapping(value = &quot;/uploadImage/&quot;,method = RequestMethod.POST)    @ResponseBody    public String uploadImage(@RequestParam(&quot;file&quot;) MultipartFile file){      try{          //上传图片到本地          //String fileUrl=newsService.saveImage(file);          //上传图片到七牛云          String fileUrl = qiniuService.saveImage(file);          if (fileUrl==null){              return ToutiaoUtil.getJSONString(1, &quot;上传图片失败&quot;);          }          return ToutiaoUtil.getJSONString(0, fileUrl);      }catch (Exception e){          logger.error(&quot;上传图片失败&quot;+e.getMessage());          return ToutiaoUtil.getJSONString(1,&quot;上传失败&quot;);      }    }    //增加咨询    @RequestMapping(value = &quot;/user/addNews/&quot;,method = RequestMethod.POST)    @ResponseBody    public String addNews(@RequestParam(&quot;image&quot;) String image,                          @RequestParam(&quot;title&quot;) String title,                          @RequestParam(&quot;link&quot;) String link){      try {          News news = new News();          news.setCreatedDate(new Date());          news.setTitle(title);          news.setImage(image);          news.setLink(link);          if (hostHolder.getUser() != null) {              news.setUserId(hostHolder.getUser().getId());          }          //设置了一个匿名用户          else {              news.setUserId(3);          }          newsService.addNews(news);          return ToutiaoUtil.getJSONString(0);      }catch (Exception e){          logger.error(&quot;添加失败&quot;+e.getMessage());          return ToutiaoUtil.getJSONString(1,&quot;添加失败！&quot;);      }    }</code></pre><p>com.nowcoder.util.ToutiaoUtil：</p><p>返回JSON串的处理函数：</p><pre><code class="java">    public static String getJSONString(int code, String msg) {        JSONObject json = new JSONObject();        json.put(&quot;code&quot;, code);        json.put(&quot;msg&quot;, msg);        return json.toJSONString();    }</code></pre><p>可以看到，json串中有2个key，<strong>code</strong>和<strong>msg</strong>。</p><p>##操作效果图：</p><p>使用postman：</p><p>可以看到uploadImage方法返回的json串：</p><blockquote><p>{“msg”:”<a href="http://pp5tb1vb6.bkt.clouddn.com/eb9b3019211242e6928fdc94a6c8fda3.jpg&quot;,&quot;code&quot;:0}" target="_blank" rel="noopener">http://pp5tb1vb6.bkt.clouddn.com/eb9b3019211242e6928fdc94a6c8fda3.jpg&quot;,&quot;code&quot;:0}</a></p><p>前端根据”code”键值对判断是否上传成功；上传成功(就是”code”:0)后，通过”msg”取得图片在云上存储的位置，将其作为url：<strong>/user/addNews/</strong>对应方法addNews(String image,String title,String link)中参数image，传入方法中。</p></blockquote><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034024.png" alt="屏幕快照 2019-03-30 下午1.26.04"></p><p>##在云上的存储情况：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034130.png" alt="屏幕快照 2019-03-30 下午1.27.43"></p><p>在数据库的存储情况：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034025.png" alt="屏幕快照 2019-03-30 下午1.34.29"></p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云存储 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN的原理</title>
      <link href="/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/cdn-de-yuan-li/"/>
      <url>/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/cdn-de-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>#介绍</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034020.png" alt="屏幕快照 2019-04-05 下午8.17.33"></p><p><strong>CDN</strong>，全称<code>Content Delivery Network</code>，主要作用是<strong>为源站减少访问压力的同时，为客户端提供更快速的内容响应</strong>。除此之外，CDN还能对源站进行安全防护。其实真正为CDN付费的是源站，所以CDN的用户其实是源站，例如新浪微博，youku视频，淘宝网啊之类的。而客户端，是CDN的用户的用户。所以CDN是夹在源站和源站的用户之间的，以下称客户端均指源站的用户。</p><h1 id="CDN工作原理"><a href="#CDN工作原理" class="headerlink" title="CDN工作原理"></a><strong>CDN工作原理</strong></h1><h2 id="传统网站访问过程"><a href="#传统网站访问过程" class="headerlink" title="传统网站访问过程"></a><strong>传统网站访问过程</strong></h2><p>要说CDN的工作原理，就得先说说Internet资源的访问过程。传统的来说，在浏览器访问网站应当有这么一些步骤：</p><ol><li>在浏览器键入网址<a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></li><li>浏览器请求dns服务器，查询到<a href="http://www.taobao.com对应的IP" target="_blank" rel="noopener">www.taobao.com对应的IP</a></li><li>浏览器向服务器发起TCP连接</li><li>浏览器通过建立的TCP连接发送HTTP协议报文</li><li>服务器向浏览器发送页面内容</li><li>浏览器将页面展现出来</li></ol><p>对于上面提到的第2步，其实还是有需要来更加详细的说明一下dns的解析过程，因为它是CDN能工作的基本条件。</p><h2 id="DNS工作过程"><a href="#DNS工作过程" class="headerlink" title="DNS工作过程"></a><strong>DNS工作过程</strong></h2><p>DNS的工作过程容易被人忽略，一般只知道DNS的输入是一个网址，输出的是一个IP。==DNS的<a href="http://www.ietf.org/rfc/rfc1035.txt" target="_blank" rel="noopener">协议</a>主要是基于UDP的<strong>，所以dns server的qps一般都是很惊人的，比web server（http是基于tcp的）的qps是高出几个量级的。有个基本概念就是</strong>dns的记录类型<strong>，常见的dns记录类型有</strong>A<strong>，</strong>AAAA<strong>，</strong>CNAME<strong>等。A记录是</strong>域名到IPV4地址的<strong>；AAAA记录是</strong>域名到IPV6地址的<strong>；**</strong>CNAME<strong>记录类似于查询过程中的转发</strong>，意思是你去问问这个个人，他管这事。好的，下面继续说说DNS的工作过程。</p><ol><li>在浏览器键入<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a></strong>,其实真正dns协议里用到的是<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a>.</strong>最后还有一个点，可能是因为美观等原因，一般都不显示</li><li>查询本地缓存（host文件或者是浏览器的缓存）中有没有该域名对应的记录，有的话就直接用了</li><li>向运营商的DNS服务器发起dns解析的请求，一般称运营商的DNS服务器为<strong>local dns</strong></li><li>local dns会查询本地的缓存，local dns设置的缓存时间是有讲究的，过长过短都不好。另外local dns的查询是运营商的事，这里面水很深，外部不可控</li><li>local dns如果没有缓存，会把域名<strong>从右往左扫描</strong>，依次请求对应的服务器，例如对于域名 <strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a>.</strong>，先去问负责<strong>.</strong>的根域名服务器，就是传说中全球只有几台的那些服务器，他们会答复<strong>.com</strong>是谁管理的，然后local dns又去找管理<strong>.com</strong>的服务器（假设名字为S1），去问问<strong>taobao.com</strong>是谁管，一般来说，在S1查到的记录是一条<strong>cname记录</strong>（阿里毕竟大公司，自己管理自己旗下的域名），<strong>然后就转到了阿里自己的DNS服务器上来了</strong>，一般称之为<strong>权威服务器</strong></li><li>权威服务器是阿里自己建的，然后根据公司内部的一些配置啊，调整啊，查到<strong><a href="http://www.taobao.com" target="_blank" rel="noopener">www.taobao.com</a>.</strong>对应的服务器是谁，返回一个IP地址</li><li>local dns缓存这个IP地址，并且回复浏览器</li><li>浏览器和对应的IP地址的服务器简历TCP连接，发送HTTP报文</li></ol><p>买过域名的朋友都知道，假如你在万网买了<strong>cstdlib.com</strong>，然后你想启用一个二级域名<strong>go.cstdlib.com</strong>，那么你要去万网的控制台（已经和阿里云合并）设置一条A记录的解析，将<strong>go.cstdlib.com</strong>指向你想要的IP。每次增加二级域名的过程都是这样子。那么，如果你知道了DNS的解析过程，你可以这么做：</p><ol><li>在服务器D1上起一个dns server，作为cstdlib.com的dns权威服务器</li><li>在万网的控制台新增一条CNAME记录，将cstdlib.com的解析转到D1来</li><li>D1想返回什么IP就返回什么IP</li></ol><p>这样一来，一切尽在掌控，毕竟D1是你的，而且以后你再也不用去万网的控制台了，这就是自建DNS服务器。</p><h2 id="CDN-访问原理"><a href="#CDN-访问原理" class="headerlink" title="CDN 访问原理"></a>CDN 访问原理</h2><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034021.png" alt="3593233181"></p><p>首先，我们作为终端用户（END USERS）在地址栏中键入 <a href="http://www.baidu.com，浏览器发现本地没有关于" target="_blank" rel="noopener">www.baidu.com，浏览器发现本地没有关于</a> <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的 DNS 缓存，于是向网站的 DNS 服务器发起请求。</p><p>然后，网站的 DNS 域名服务器设置了 CName，指向了某个 CDN 服务（比如 <a href="http://www.baidu.com），去请求" target="_blank" rel="noopener">www.baidu.com），去请求</a> CDN 中的<strong>智能 DNS 均衡负载系统</strong>。</p><p>均衡负载系统解析域名，把对用户响应最快的节点（<strong>CDN Node</strong>）返回给用户，然后用户向该节点发出请求。</p><p>如果是第一次访问该内容，CDN 服务器会向源站（Origin Server）请求数据并缓存，否则的话，直接在缓存节点中找到该数据，将请求结果发给用户。</p><p>对于最简单的 CDN 系统而言，只要一台 DNS 调度服务器和一个节点服务器即可，但在复杂的应用中，会存在多级缓存，多台 Cache 来协同工作。</p><h2 id="CDN选择优质节点"><a href="#CDN选择优质节点" class="headerlink" title="CDN选择优质节点"></a>CDN选择优质节点</h2><p>回到正题，CDN如何为用户选择时延更小的源站。这次不以访问淘宝为例了，因为阿里有自己的CDN，要是以访问淘宝为例，容易混淆CDN的提供者和源站。这次举例以新浪微博为源站，假设微博使用了阿里的CDN，那么阿里CDN会告诉微博，你要我给你加速一张图片是吧，那你就把这个图片解析到我的服务器来（可以CNAME，也可以直接写阿里CDN的url，牛客项目中是直接写云的URL<strong>），那么，阿里CDN的dns权威服务器，会收到这么一个解析请求，</strong>“请告诉我，新浪微博的1.png的源站在哪”。这时CDN系统就要大展身手了。</p><p>假设我们现在是阿里CDN的dns权威服务器，有人问我们<strong>“新浪微博的1.png的源站在哪”</strong>，那我会这么做：先看看问我的这个人IP是多少（回忆一下dns解析的过程，我们看到的应该是local dns的IP），然后根据这个IP查到他是哪里的，北京还是广州，上海还是深圳。如果是北京，那好，我就给你返回北京的源站的地址；如果是上海，那我就给你返回上海的源站的地址，这样就实现了就近访问。</p><p>在把IP地址对应到地理位置的过程中，需要用到IP库，阿里CDN的<code>IP地址库</code>很NB，因为阿里CDN的负责人叔度在ArchSummit架构师峰会上说，他们可以用淘宝的包裹记录来校准，真是机智。</p><p>当然，就近只是一个要考虑的因素之一，还有很多因素需要考虑的，例如网络成本，流量分布，源站负载等。这是个很复杂的过程，我只是举了一个直观的方面来说。</p><h2 id="CDN减少源站压力"><a href="#CDN减少源站压力" class="headerlink" title="CDN减少源站压力"></a><strong>CDN减少源站压力</strong></h2><p>刚才说了CDN是如何选择优质节点的，那么对于客户端，算是有个交代了。所以接下来考虑怎么给源站一个交代：<strong>减小源站压力</strong>。如果每一个用户请求都让他直接去源站拿的话，那源站将会承受巨大的压力，所以要考虑为源站提供一个HTTP的缓存，通过提升缓存的命中率来减小源站的压力。</p><p>比如刚才第一个用户请求了1.png，那么CDN先把这张图片缓存（缓存简单可以认为是一个哈希表，key是url，value是response）起来，下次再有人要1.png，就直接返回给他，从而减少回源流量。</p><p>牛客项目中：</p><p>项目中存放在云上的图片url:<strong>云上的外链接+图片在云上的名</strong>，所以在返回给客户端HTML页面中，图片的地址就是</p><p><strong>云上的外链接+图片在云上的名</strong>，用户需要查看图片时，直接联系的是服务你的云，云会根据你发出请求的IP地址，就近为你选择一台离你最近的服务器为你服务。<strong>这样既加快的图片的传输，又因为源站不用处理获取图片的请求，达到了减少源站压力的目的</strong>。</p><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><p>CDN的工作原理：通过权威dns服务器来实现优质节点的选择，通过缓存来减少源站的压力。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之Ajax</title>
      <link href="/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-ajax/"/>
      <url>/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-ajax/</url>
      
        <content type="html"><![CDATA[<p>#什么是 AJAX ？</p><p>AJAX = 异步 JavaScript 和 XML。</p><p>AJAX 是一种用于创建快速动态网页的技术。</p><p>通过在<strong>后台与服务器进行少量数据交换</strong>，AJAX 可以使<strong>网页实现异步更新</strong>。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p><p>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。</p><p>有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。</p><h1 id="AJAX-工作原理"><a href="#AJAX-工作原理" class="headerlink" title="AJAX 工作原理"></a>AJAX 工作原理</h1><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034026.gif" alt="ajax"></p><h1 id="与传统的web应用比较"><a href="#与传统的web应用比较" class="headerlink" title="与传统的web应用比较"></a>与传统的web应用比较</h1><p>传统的web应用允许用户填写表单(form)，当提交表单时就向web服务器发送一个请求。服务器接收并处理传来的表单，<strong>然后返回一个新的网页</strong>。这个做法浪费了许多带宽，==因为在前后两个页面中的大部分HTML代码往往是相同的==。由于每次应用的交互都需要向服务器发送请求，应用的响应时间就依赖于服务器的响应时间。这导致了用户界面的响应比本地应用慢得多。</p><p>与此不同，AJAX应用可以仅向服务器发送并取回必需的数据，它使用SOAP或其它一些基于XML的web service接口，并在客户端采用JavaScript处理来自服务器的响应。因为在服务器和浏览器之间交换的数据大量减少，结果我们就能看到响应更快的应用。同时很多的处理工作可以在发出请求的客户端机器上完成，所以Web服务器的处理时间也减少了。</p><h1 id="ajax实现form表单提交"><a href="#ajax实现form表单提交" class="headerlink" title="ajax实现form表单提交"></a>ajax实现form表单提交</h1><p>static/scripts/main/component/popupLogin.js：</p><pre><code class="javascript">        listeners: [{            name: &#39;render&#39;,            type: &#39;custom&#39;,            handler: function () {            name: &#39;click a.js-login&#39;,            handler: function (oEvent) {                oEvent.preventDefault();                var that = this;                // 值检查                if (!that.checkVal()) {                    return;                }                var oData = that.val();              //完成登录功能的ajax                $.ajax({                    url: &#39;/login/&#39;,//对应的Controller的方法                    type: &#39;post&#39;,//对应http的方法                    dataType: &#39;json&#39;,//传输的数据格式是json串                    data: {//传输哪些数据，和url对应的方法中的参数对应                        username: oData.email,                        password: oData.pwd,                        rember: oData.rember ? 1 : 0                    }                }).done(function (oResult) {                    if (oResult.code === 0) {//                        window.location.reload();                        that.emit(&#39;login&#39;);                    } else {                        oResult.msgname &amp;&amp; that.iptError(that.emailIpt, oResult.msgname);                        oResult.msgpwd &amp;&amp; that.iptError(that.pwdIpt, oResult.msgpwd);                    }                }).fail(function () {                    alert(&#39;出现错误，请重试&#39;);                });            }        }, {          //注册功能的ajax            name: &#39;click a.js-register&#39;,            handler: function (oEvent) {                oEvent.preventDefault();                var that = this;                // 值检查                if (!that.checkVal()) {                    return;                }                var oData = that.val();                $.ajax({                    url: &#39;/reg/&#39;,                    type: &#39;post&#39;,                    dataType: &#39;json&#39;,                    data: {                        username: oData.email,                        password: oData.pwd                    }                }).done(function (oResult) {                    if (oResult.code === 0) {//                        window.location.reload();                        that.emit(&#39;register&#39;);                    } else {                        oResult.msgname &amp;&amp; that.iptError(that.emailIpt, oResult.msgname);                        oResult.msgpwd &amp;&amp; that.iptError(that.pwdIpt, oResult.msgpwd);                    }                }).fail(function () {                    alert(&#39;出现错误，请重试&#39;);                });            }        }]</code></pre><p>前端和后端的传输数据类型是用json。</p><p>#Ajax应用程序的优势在于：</p><ol><li><p>通过异步模式，提升了用户体验</p></li><li><p>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用</p></li><li><p>Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之Mybatis</title>
      <link href="/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-mybatis/"/>
      <url>/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-mybatis/</url>
      
        <content type="html"><![CDATA[<p>#原始的JDBC操作：</p><p>##原始JDBC源代码：</p><pre><code class="java">import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;/** * @ClassName: TestJDBC * @Description: TODO(原始的JDBC操作数据库) */public class TestJDBC {    public static void main(String[] args) {        // 数据库连接        Connection connection = null;        // 预编译的Statement，使用预编译的Statement提高数据库性能        PreparedStatement preparedStatement = null;        // 结果集        ResultSet resultSet = null;        try {            // 加载数据库驱动            Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);            // 通过驱动管理类获取数据库链接            connection = DriverManager                    .getConnection(                            &quot;jdbc:mysql://localhost:3306/toutiao?characterEncoding=utf-8&quot;,                            &quot;root&quot;, &quot;xxh171015&quot;);            // 定义sql语句 ?表示占位符            String sql = &quot;select * from user where name = ?&quot;;            // 获取预处理statement            preparedStatement = connection.prepareStatement(sql);            // 设置参数，第一个参数为sql语句中参数的序号（从1开始），第二个参数为设置的参数值            preparedStatement.setString(1, &quot;x&quot;);            // 向数据库发出sql执行查询，查询出结果集            resultSet = preparedStatement.executeQuery();            // 遍历查询结果集            while (resultSet.next()) {                System.out.println(&quot;id:&quot;+resultSet.getString(&quot;id&quot;) + &quot;  name:&quot;                        + resultSet.getString(&quot;name&quot;)+&quot; head_url:&quot;+resultSet.getString(&quot;head_url&quot;));            }        } catch (Exception e) {            e.printStackTrace();        } finally {            // 释放资源            if (resultSet != null) {                try {                    resultSet.close();                } catch (SQLException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }            if (preparedStatement != null) {                try {                    preparedStatement.close();                } catch (SQLException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }            if (connection != null) {                try {                    connection.close();                } catch (SQLException e) {                    // TODO Auto-generated catch block                    e.printStackTrace();                }            }        }    }}</code></pre><p>##存在的问题</p><p>1、数据库连接，使用时就创建，不使用立即释放，对数据库进行频繁连接开启和关闭，造成数据库资源浪费，影响数据库性能。</p><p>解决方案：<strong>使用数据库连接池管理数据库连接</strong>。</p><p>2、将sql语句硬编码到java代码中，如果sql 语句修改，需要重新编译java代码，不利于系统维护。</p><p>解决方案：<strong>将sql语句配置在xml配置文件中，即使sql变化，不需要对java代码进行重新编译</strong>。</p><p>3、向<strong>preparedStatement</strong>中设置参数，对占位符号位置和设置参数值，硬编码在java代码中，不利于系统维护。</p><p>解决方案：<strong>将sql语句及占位符号和参数全部配置在xml中</strong>。</p><p>4、从<strong>resultSet</strong>中遍历结果集数据时，存在硬编码，将获取表的字段进行硬编码，，不利于系统维护。</p><p>解决方案：<strong>将查询的结果集，自动映射成java对象</strong>。</p><h1 id="MyBatis是什么？"><a href="#MyBatis是什么？" class="headerlink" title="MyBatis是什么？"></a>MyBatis是什么？</h1><p>MyBatis是一个优秀的持久层<strong>ORM</strong>（Object Relational Mapping）框架，它对jdbc的操作数据库的过程进行封装，<strong>使开发者只需要关注 SQL 本身</strong>，而不需要花费精力去处理例如<strong>注册驱动</strong>、<strong>创建connection</strong>、<strong>创建statement</strong>、<strong>手动设置参数</strong>、<strong>结果集检索</strong>等jdbc繁杂的过程代码。</p><p>Mybatis通过==xml==或<strong>注解</strong>的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并<strong>通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回</strong>。</p><p>##MyBatis架构图</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034027.gif" alt="7378149-dff06e3ae5947d57"></p><p>架构图简单讲解：</p><p>1、mybatis配置<strong>SqlMapConfig.xml</strong>，此文件作为mybatis的全局配置文件，配置了mybatis的运行环境等信息。</p><p><strong>mapper.xml</strong>文件即sql映射文件，文件中配置了操作数据库的sql语句。此文件需要在SqlMapConfig.xml中加载；</p><p> 2、通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂；</p><p> 3、由会话工厂创建<strong>sqlSession</strong>即会话，<strong>操作数据库需要通过sqlSession进行</strong>；</p><p> 4、mybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器；</p><p> 5、<strong>Mapped Statement</strong>也是mybatis一个底层封装对象，它<strong>包装了mybatis配置信息及sql映射信息</strong>等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id；</p><p> 6、Mapped Statement对sql执行输入参数进行定义，包括<strong>HashMap、基本类型、pojo</strong>，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，<strong>输入参数映射就是jdbc编程中对preparedStatement设置参数</strong>；</p><p> 7、Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型（String、Integer）、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，<strong>输出结果映射过程相当于jdbc编程中对结果的解析处理过程</strong>。</p><h2 id="简单举例："><a href="#简单举例：" class="headerlink" title="简单举例："></a>简单举例：</h2><p>这个例子中使用注解的方式使用mybatis</p><p>拿UserService中的登录功能举例：</p><pre><code class="java">    public Map&lt;String, Object&gt; login(String username, String password){        Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();        if (StringUtils.isBlank(username)){            map.put(&quot;msgname&quot;,&quot;用户名不能为空&quot;);            return map;        }        if (StringUtils.isBlank(password)){            map.put(&quot;msgpwd&quot;,&quot;密码不能为空&quot;);            return map;        }      //这句是我们要注意的，用到了被依赖注入的userDAO中的selectByName()方法        User user = userDAO.selectByName(username);        if(user==null){            map.put(&quot;msgname&quot;,&quot;用户名不存在&quot;);            return map;        }        if(!ToutiaoUtil.MD5(password+user.getSalt()).equals(user.getPassword())){            map.put(&quot;msgpwd&quot;,&quot;密码不正确&quot;);            return map;        }        map.put(&quot;userId&quot;, user.getId());        String ticket=addLoginTicket(user.getId());        map.put(&quot;ticket&quot;,ticket);        return map;    }</code></pre><p>UserDAO中：</p><pre><code class="java">    String TABLE_NAME = &quot;user&quot;;    String INSET_FIELDS = &quot; name, password, salt, head_url &quot;;    String SELECT_FIELDS = &quot; id, name, password, salt, head_url&quot;;@Select({&quot;select &quot;, SELECT_FIELDS, &quot; from &quot;, TABLE_NAME, &quot; where id=#{id}&quot;})    User selectById(int id);</code></pre><ol><li><p>上面中<strong>@Select注解中一个sql对应一个Mapped Statement对象，Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo（java对象），这里的输入对象是(Integer)id</strong>；</p></li><li><p>Executor通过Mapped Statement在执行sql前<strong>将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数(这步中的映射操作是，上述由@Select注解的内容，经过java对象最后映射成了sql语句，其实就是将</strong>#{id}<strong>映射成方法中的形参</strong>id)；然后执行映射后的sql语句；</p></li></ol><p>会被映射成如下：</p><pre><code class="sql">select id, name, password, salt, head_url from user where id=(方法中传入的id)</code></pre><ol start="3"><li><p>Executor执行完sql后，会将输出结果映射至java对象中，<strong>输出结果映射过程相当于jdbc编程中对结果的解析处理过程</strong>。</p><p>我们从UserDAO的selectById()方法中就可以看出来，最后返回的是User对象。</p></li></ol><h1 id="MyBatis的执行流程"><a href="#MyBatis的执行流程" class="headerlink" title="MyBatis的执行流程"></a>MyBatis的执行流程</h1><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034028.jpg" alt="v2-771a68ce10ea003a11e7fd7751bec30c_1200x500"></p><h2 id="1-Resources"><a href="#1-Resources" class="headerlink" title="1 Resources"></a>1 <strong>Resources</strong></h2><p><strong>首先Mybaitis自己的一个Resources类会去调用一个叫getResourceAsStream()的方法</strong></p><p><strong>加载配置MyBatis的核心配置文件，得到一个</strong>流对象（InputStream类）<strong>。（本质上还是走的java.lang包下的ClassLoader类加载器的getResourceAsStream）</strong></p><p>是在mybatis自己的包下：</p><pre><code class="java">package org.apache.ibatis.io;/*   * Returns a resource on the classpath as a Stream object   *   * @param resource The resource to find   * @return The resource   * @throws java.io.IOException If the resource cannot be found or read   */  public static InputStream getResourceAsStream(String resource) throws IOException {    return getResourceAsStream(null, resource);  }/*   * Returns a resource on the classpath as a Stream object   *   * @param loader   The classloader used to fetch the resource   * @param resource The resource to find   * @return The resource   * @throws java.io.IOException If the resource cannot be found or read   */  public static InputStream getResourceAsStream(ClassLoader loader, String resource) throws IOException {    InputStream in = classLoaderWrapper.getResourceAsStream(resource, loader);    if (in ** null) {      throw new IOException(&quot;Could not find resource &quot; + resource);    }    return in;  }</code></pre><pre><code class="java">package java.lang;public abstract class ClassLoader {public InputStream getResourceAsStream(String name) {        URL url = getResource(name);        try {            return url != null ? url.openStream() : null;        } catch (IOException e) {            return null;        }    }}</code></pre><h2 id="2-SqlSessionFactoryBuilder"><a href="#2-SqlSessionFactoryBuilder" class="headerlink" title="2 SqlSessionFactoryBuilder"></a>2 <strong>SqlSessionFactoryBuilder</strong></h2><p><strong>有了这个流对象，下面执行这个方法</strong></p><pre><code class="java">package org.apache.ibatis.session;public class SqlSessionManager implements SqlSessionFactory, SqlSession {public static SqlSessionManager newInstance(InputStream inputStream) {    return new SqlSessionManager(new SqlSessionFactoryBuilder().build(inputStream, null, null));  }}</code></pre><pre><code class="java">package org.apache.ibatis.session;public class SqlSessionFactoryBuilder {public SqlSessionFactory build(InputStream inputStream) {    return build(inputStream, null, null);  }public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {    try {      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);      return build(parser.parse());    } catch (Exception e) {      throw ExceptionFactory.wrapException(&quot;Error building SqlSession.&quot;, e);    } finally {      ErrorContext.instance().reset();      try {        inputStream.close();      } catch (IOException e) {        // Intentionally ignore. Prefer previous error.      }    }  }  public SqlSessionFactory build(Configuration config) {    return new DefaultSqlSessionFactory(config);  }}</code></pre><p>会先去创建一个<strong>SqlSessionFactoryBuilder</strong>对象（构建者对象），调用build()方法，传入第一步我们得到的那个<strong>流对象</strong>。</p><p>在这个过程中，首先，MyBatis会先去创建一个<strong>XMLConfigBuilder解析器对象</strong>，</p><pre><code class="java">XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);return build(parser.parse());</code></pre><p>解析我们刚才传进来的那个流对象，</p><pre><code class="java">package org.apache.ibatis.builder.xml;public class XMLConfigBuilder extends BaseBuilder {public Configuration parse() {    if (parsed) {      throw new BuilderException(&quot;Each XMLConfigBuilder can only be used once.&quot;);    }    parsed = true;    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));    return configuration;  }}</code></pre><p>解析完成之后，返回一个<strong>configuration</strong>对象，这个对象里面封装了解析之后我们配置的信息</p><p>正好这个configuration对象，就是我们这个方法创建（I）SqlSessionFactory类型对象需要的参数</p><pre><code class="java">public SqlSessionFactory build(Configuration config) {    return new DefaultSqlSessionFactory(config);  }</code></pre><p><strong>返回的就是一个实现了SqlSessionFactory接口的==DefaultSqlSessionFactory==对象</strong></p><h2 id="3-SqlSesionFactory"><a href="#3-SqlSesionFactory" class="headerlink" title="3 SqlSesionFactory"></a>3 SqlSesionFactory</h2><p>有了这个<strong>SqlSesionFactory</strong>实现类的对象之后，我们调用<strong>openSession()</strong>的方法，这个过程中</p><pre><code class="java">package org.apache.ibatis.session.defaults;public class DefaultSqlSessionFactory implements SqlSessionFactory {public SqlSession openSession() {    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);  }  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {    Transaction tx = null;    try {      final Environment environment = configuration.getEnvironment();      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);      final Executor executor = configuration.newExecutor(tx, execType);      return new DefaultSqlSession(configuration, executor, autoCommit);    } catch (Exception e) {      closeTransaction(tx); // may have fetched a connection so lets call close()      throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + e, e);    } finally {      ErrorContext.instance().reset();    }  }}</code></pre><p>需 要 通 过<strong>TransactionFactory</strong> 生成 <strong>Transaction 对象</strong>, 并且还需要创建<strong><strong>核心执行器 Executor</strong></strong>对象,基于这些条件，最终创建了实现SqlSession接口的DefaultSqlSession对象</p><h2 id="4-SqlSession"><a href="#4-SqlSession" class="headerlink" title="4 SqlSession"></a>4 SqlSession</h2><p>之后, 通过 SqlSession 对象执行相应的操作, 如果执行成功, 调用 <strong>commit</strong> 方法提交事务; 如果失败, 调用<strong>rollback</strong> 方法事务回滚. 最后, 调用 <strong>close</strong> 方法关闭session 资源.</p><p>##<strong>总结 MyBatis运行过程中涉及到的类和接口：</strong></p><h3 id="Resources（C）-类"><a href="#Resources（C）-类" class="headerlink" title="Resources（C） 类"></a>Resources（C） 类</h3><p>用于加载MyBatis核心配置文件</p><h3 id="XMLConfigBuilder-C-类"><a href="#XMLConfigBuilder-C-类" class="headerlink" title="XMLConfigBuilder(C) 类"></a>XMLConfigBuilder(C) 类</h3><p>用于解析xml文件（核心配置文件）</p><h3 id="Configuration-C-类"><a href="#Configuration-C-类" class="headerlink" title="Configuration(C)类"></a>Configuration(C)类</h3><p>用于存放xml文件解析后的结果</p><h3 id="DefaultSqlSessionFactory（C）类"><a href="#DefaultSqlSessionFactory（C）类" class="headerlink" title="DefaultSqlSessionFactory（C）类"></a>DefaultSqlSessionFactory（C）类</h3><p>是SqlSessionFactory（I）的实现类，创建时需要使用Configruation对象作为参数</p><h3 id="SqlSession（I）接口"><a href="#SqlSession（I）接口" class="headerlink" title="SqlSession（I）接口"></a>SqlSession（I）接口</h3><p>是MyBatis操作的核心</p><h3 id="DefaultSqlSession-C）类"><a href="#DefaultSqlSession-C）类" class="headerlink" title="DefaultSqlSession(C）类"></a>DefaultSqlSession(C）类</h3><p>是SqlSession接口的实现类</p><h3 id="TransactionFactory（I）接口"><a href="#TransactionFactory（I）接口" class="headerlink" title="TransactionFactory（I）接口"></a>TransactionFactory（I）接口</h3><p>用于生产Trasaction对象（关于事务的）</p><h3 id="Transaction-I-接口"><a href="#Transaction-I-接口" class="headerlink" title="Transaction(I) 接口"></a>Transaction(I) 接口</h3><p>用于表示操作数据库的事务对象</p><h3 id="Executor（I）接口"><a href="#Executor（I）接口" class="headerlink" title="Executor（I）接口"></a>Executor（I）接口</h3><p>是MyBatis的核心执行器，类似于JDBC中的Statement，常用的实现类是SimpleExecutor</p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot与线程安全问题</title>
      <link href="/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-springboot-yu-xian-cheng-an-quan-wen-ti/"/>
      <url>/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-springboot-yu-xian-cheng-an-quan-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="spring与线程安全"><a href="#spring与线程安全" class="headerlink" title="spring与线程安全"></a>spring与线程安全</h1><p>Spring作为一个IOC容器，帮助我们管理了许许多多的“bean”。但其实，<strong>Spring并没有保证这些对象的线程安全</strong>，需要由开发者自己编写解决线程安全问题的代码。</p><p>Spring对每个bean提供了一个scope属性来表示该bean的作用域。它是bean的生命周期。例如，一个scope为singleton的bean，在第一次被注入时，会创建为一个单例对象，该对象会一直被复用到应用结束。</p><ul><li><strong>singleton</strong>：默认的scope，每个scope为singleton的bean都会被定义为一个单例对象，该对象的生命周期是与Spring IOC容器一致的（但在第一次被注入时才会创建）。</li><li><strong>prototype</strong>：bean被定义为在<strong>每次注入时都会创建一个新的对象</strong>。</li><li>request：bean被定义为在每个HTTP请求中创建一个单例对象，也就是说在单个请求中都会复用这一个单例对象。</li><li>session：bean被定义为在一个session的生命周期内创建一个单例对象。</li><li>application：bean被定义为在ServletContext的生命周期中复用一个单例对象。</li><li>websocket：bean被定义为在websocket的生命周期中复用一个单例对象。</li></ul><p>我们交由Spring管理的大多数对象其实都是一些无状态的对象，这种不会因为多线程而导致状态被破坏的对象很适合Spring的默认scope，<strong>每个单例的无状态对象都是线程安全的</strong>（也可以说只要是无状态的对象，不管单例多例都是线程安全的，<strong>不过单例毕竟节省了不断创建对象与GC的开销</strong>）。</p><p>无状态的对象即是自身没有状态的对象，自然也就不会因为多个线程的交替调度而破坏自身状态导致线程安全问题。无状态对象包括我们经常使用的DO、DTO、VO这些只作为数据的实体模型的对象（项目中的model），还有Service、DAO和Controller，这些对象并没有自己的状态，它们只是用来执行某些操作的。例如，每个DAO提供的函数都只是对数据库的CRUD，而且每个数据库Connection都作为函数的局部变量（<strong>局部变量是在用户栈中的，而且用户栈本身就是线程私有的内存区域，所以不存在线程安全问题</strong>），用完即关（或交还给连接池）。</p><p>有人可能会认为，我使用request作用域不就可以避免每个请求之间的安全问题了吗？这是完全错误的，因为Controller默认是单例的，一个controller对象是会被多个线程共享的，这就又回到了线程的安全问题。当然，你也可以把Controller的scope改成prototype，实际上Struts2就是这么做的，但有一点要注意，Spring MVC对请求的拦截粒度是基于每个方法的，而Struts2是基于每个类的，所以把Controller设为多例将会频繁的创建与回收对象，严重影响到了性能。</p><p>通过阅读上文其实已经说的很清楚了，Spring根本就没有对bean的多线程安全问题做出任何保证与措施。对于每个bean的线程安全问题，根本原因是每个bean自身的设计。<strong>不要在bean中声明任何有状态的实例变量或类变量</strong>，如果必须如此，那么就使用ThreadLocal把变量变为线程私有的，<strong>如果bean的实例变量或类变量需要在多个线程之间共享，那么就只能使用synchronized、lock、CAS等这些实现线程同步的方法了</strong>。</p><p>知识点补充：</p><p><strong>线程安全问题都是由全局变量（成员变量）及静态变量引起的。</strong>  </p><p>若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则就可能影响线程安全。</p><p>1） <strong>常量始终是线程安全的</strong>，因为只存在读操作。 </p><p>2）<strong>每次调用方法前都新建一个实例是线程安全的</strong>，因为不会访问共享的资源。</p><p>3）<strong>局部变量是线程安全的</strong>。因为每执行一个方法，都会在独立的空间创建局部变量，它不是共享的资源。局部变量包括方法的参数变量和方法内变量。</p><p>有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象  ，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。</p><p>无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象  .不能保存数据，是不变类，是线程安全的。</p><p>#ThreadLocal和线程同步机制相比有什么优势呢？</p><p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。 </p><p>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。 </p><p>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。 </p><p>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之通用的新模块开发流程</title>
      <link href="/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-tong-yong-de-xin-mo-kuai-kai-fa-liu-cheng/"/>
      <url>/2019/03/30/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-tong-yong-de-xin-mo-kuai-kai-fa-liu-cheng/</url>
      
        <content type="html"><![CDATA[<p>#通用的新模块开发流程 </p><ol><li>Database Column（数据库都有哪些列）</li><li>Model:模型定义，和数据库相匹配（对象的属性和数据库的column对应）</li><li>DAO:数据读取（封装对数据库的操作）</li><li>Service:服务包装（封装业务逻辑）</li><li>Controller:业务入口 </li><li>Test 单元测试</li></ol><h1 id="采用新模块开发流程开发评论中心"><a href="#采用新模块开发流程开发评论中心" class="headerlink" title="采用新模块开发流程开发评论中心"></a>采用新模块开发流程开发评论中心</h1><p>##Database Column：</p><ul><li>id(int)：每条评论都有自己的ID</li><li>content(String)：评论的内容</li><li>entity_id (int)：就是newsID</li><li>entity_type(int)：entity是哪种形式，new？还是comment？</li><li>created_date (Date)：创建的日期</li><li>user_id(int)：是哪个用户发的</li><li>status(int)：</li></ul><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-034026.png" alt="屏幕快照 2019-03-15 下午8.18.03"></p><p>##Model：</p><p>实体类：</p><pre><code class="java">/** * 定义的实体 */public class Comment {    private int id;    private int userId;    private int entityId;    private int entityType;    private String content;    private Date createdDate;    private int status;    public int getId() {        return id;    }    public void setId(int id) {        this.id = id;    }    public int getUserId() {        return userId;    }    public void setUserId(int userId) {        this.userId = userId;    }    public int getEntityId() {        return entityId;    }    public void setEntityId(int entityId) {        this.entityId = entityId;    }    public int getEntityType() {        return entityType;    }    public void setEntityType(int entityType) {        this.entityType = entityType;    }    public String getContent() {        return content;    }    public void setContent(String content) {        this.content = content;    }    public Date getCreatedDate() {        return createdDate;    }    public void setCreatedDate(Date createdDate) {        this.createdDate = createdDate;    }    public int getStatus() {        return status;    }    public void setStatus(int status) {        this.status = status;    }}</code></pre><h2 id="DAO："><a href="#DAO：" class="headerlink" title="DAO："></a>DAO：</h2><pre><code class="java">/** * 读取数据 */@Mapperpublic interface CommentDAO{    String TABLE_NAME = &quot; comment &quot;;    String INSERT_FIELDS = &quot; user_id, content, created_date, entity_id, entity_type, status &quot;;    String SELECT_FIELDS = &quot; id, &quot; + INSERT_FIELDS;    @Insert({&quot;insert into &quot;, TABLE_NAME, &quot;(&quot;, INSERT_FIELDS,            &quot;) values (#{userId},#{content},#{createdDate},#{entityId},#{entityType},#{status})&quot;})    int addComment(Comment comment);    @Select({&quot;select &quot;, SELECT_FIELDS, &quot; from &quot;, TABLE_NAME, &quot; where entity_type=#{entityType} and entity_id=#{entityId} order by id desc &quot;})    List&lt;Comment&gt; selectByEntity(@Param(&quot;entityId&quot;) int entityId, @Param(&quot;entityType&quot;) int entityType);    @Select({&quot;select count(id) from &quot;, TABLE_NAME, &quot; where entity_type=#{entityType} and entity_id=#{entityId}&quot;})    int getCommentCount(@Param(&quot;entityId&quot;) int entityId, @Param(&quot;entityType&quot;) int entityType);}</code></pre><p>通过注解使用的mybatis。通过这种ORM（Object Relational Mapping）框架，对数据库进行增删改查操作。</p><h2 id="Service："><a href="#Service：" class="headerlink" title="Service："></a>Service：</h2><pre><code class="java">@Servicepublic class CommentService {    private static final Logger logger = LoggerFactory.getLogger(QiniuService.class);    @Autowired    CommentDAO commentDAO;    //通过entityId和entityType能唯一确定这条评论的类型和这种类型中的哪个    public List&lt;Comment&gt; getCommentsByEntity(int entityId, int entityType) {        return commentDAO.selectByEntity(entityId, entityType);    }    public int addComment(Comment comment) {        return commentDAO.addComment(comment);    }    public int getCommentCount(int entityId, int entityType) {        return commentDAO.getCommentCount(entityId, entityType);    }}</code></pre><h2 id="Controller："><a href="#Controller：" class="headerlink" title="Controller："></a>Controller：</h2><p>com.nowcoder.controller.NewsController：</p><pre><code class="java">    //增加评论    @RequestMapping(value = &quot;/addComment&quot;,method = RequestMethod.POST)    public String addComment(@RequestParam(&quot;newsId&quot;) int newsId,                             @RequestParam(&quot;content&quot;) String content){        try {            Comment comment=new Comment();            comment.setUserId(hostHolder.getUser().getId());            comment.setEntityId(newsId);            comment.setEntityType(EntityType.ENTITY_NEWS);            comment.setContent(content);            comment.setCreatedDate(new Date());            comment.setStatus(0);            commentService.addComment(comment);            //查看type=news的这条new（由newid标识）有多少条评论            int count= commentService.getCommentCount(comment.getEntityId(),comment.getEntityType());            //更新news里的评论数量            newsService.updateCommentCount(comment.getEntityId(),count);        }catch (Exception e){            logger.error(&quot;添加评论失败&quot;+e.getMessage());        }        return &quot;redirect:/news/&quot;+String.valueOf(newsId);    }</code></pre><p>映射处理的路径为：/addComment时，执行增加评论的操作，其实就是在数据库comment表中增加一条记录，并更新该条新闻的评论数量，此记录附带newID（就是entityID）和评论类型（entityType）。</p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块开发流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目亮点之拦截器</title>
      <link href="/2019/03/29/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-lan-jie-qi/"/>
      <url>/2019/03/29/niu-ke-wang-zhong-ji-xiang-mu/xiang-mu-liang-dian-zhi-lan-jie-qi/</url>
      
        <content type="html"><![CDATA[<p>#项目中的拦截器：</p><p>在springboot中使用拦截器，要<strong>implementsHandlerInterceptor</strong>接口，实现<strong>preHandle</strong>、<strong>postHandle</strong>、<strong>afterCompletion</strong>方法。</p><p><code>preHandle</code>：该方法是进行处理器拦截用的，顾名思义，该方法将在Controller处理之前进行调用，SpringMVC中的Interceptor拦截器是链式的，可以同时存在多个Interceptor，然后SpringMVC会根据声明的前后顺序一个接一个的执行，而且所有的Interceptor中的preHandle方法都会在Controller方法调用之前调用。SpringMVC的这种Interceptor链式结构也是可以进行中断的，这种中断方式是令preHandle的返回值为false，当preHandle的返回值为false的时候整个请求就结束了。</p><p><code>postHandle</code>：这个方法只会在当前这个Interceptor的preHandle方法返回值为true的时候才会执行。postHandle是进行处理器拦截用的，它的执行时间是在处理器进行处理之后，也就是<strong>在Controller的方法调用之后执行</strong>，但是它会<strong>在DispatcherServlet进行视图的渲染之前执行</strong>，也就是说在这个方法中你可以对ModelAndView进行操作。这个方法的链式结构跟正常访问的方向是相反的，也就是说先声明的Interceptor拦截器该方法反而会后调用，这跟Struts2里面的拦截器的执行过程有点像，只是Struts2里面的intercept方法中要手动的调用ActionInvocation的invoke方法，Struts2中调用ActionInvocation的invoke方法就是调用下一个Interceptor * 或者是调用action，然后要在Interceptor之前调用的内容都写在调用invoke之前，要在Interceptor之后调用的内容都写在调用invoke方法之后。</p><p><code>afterCompletion</code>：该方法也是需要当前对应的Interceptor的preHandle方法的返回值为true时才会执行。该方法将在整个请求完成之后，也就是DispatcherServlet渲染了视图后， 这个方法的主要作用是用于清理资源的，当然这个方法也只能在当前这个Interceptor的preHandle方法的返回值为true时才会执行。</p><h2 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h2><p>springboot中光在Interceptor拦截器类上加@Component注解，只能说明拦截器在IOC容器里供用户使用，但是用户无法直接使用，所以必须注册才能生效，也就是下面重写的addInterceptors()方法。</p><pre><code class="java">@Component//加入拦截器public class ToutiaoWebConfig extends WebMvcConfigurerAdapter {    @Autowired    private PassportInterceptor passportInterceptor;    @Autowired    private LoginRequiredInterceptor loginRequiredInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) {        /**         * 错误写法，要体现spring的IOC         */        //registry.addInterceptor(new PassportInterceptor());        /**         * 正确写法,通过自动配置         */        registry.addInterceptor(passportInterceptor);        registry.addInterceptor(loginRequiredInterceptor).addPathPatterns(&quot;/setting*&quot;);    }}</code></pre><h1 id="使用拦截器完成的功能"><a href="#使用拦截器完成的功能" class="headerlink" title="使用拦截器完成的功能"></a>使用拦截器完成的功能</h1><p>##页面访问(思想路线)</p><p>1.客户端:发送带token的HTTP请求 </p><p>2.服务端: </p><ul><li>根据token获取用户id</li><li>根据用户id获取用户的具体信息</li><li>检查该用户是否有相关页面访问权限</li><li>渲染页面/跳转页面。有，可以继续访问；没有跳转到主页</li></ul><p>具体功能：</p><p>一、<strong>可以知道是哪个用户要登录</strong>。 </p><p>在进入controller前，调用preHandle方法处理，它可以检查客户端提交的cookie中是否有服务器之前下发的ticket，如果有证明这个请求是已经登陆的用户了。把登陆的用户放到线程本地变量（ThreadLocal）。在此时进入controller，可以拿到具体的用户HostHolder类，进而可以根据登陆的用户进行个性化渲染，比如关注用户的动态，个人收藏等。</p><p>二、<strong>可以进行权限管理</strong> </p><p>比如，在浏览某些页面时，要保证用户登陆，或者用户是某个等级的。可以先在preHandler中判断，这个可以在设置一个特定范围的拦截器，如下的拦截器LoginRequiredInterceptor，在访问setting页面时才会进入到该拦截器，如果验证没有HostHolder，说明用户没登陆，就跳转到主页或者给出登陆页面。拦截器也先后执行顺序。</p><p>三、<strong>可以自动登陆</strong> </p><p>我们平时在浏览网页的时候会碰到这样的情况，昨天登陆了某个网站，关机，第二天再登陆，自动跳转到我的用户了。这里是服务器会把浏览器的sessionId和服务器的数据库关联，在提交请求的时候服务器会设置拦截器去找sessionId，如果这个sessionId和我服务器上的ticket关联了起来，并且设置的过期时间没有过期，那在登陆主页前我就可以知道是某个用户，在controller层中可以进行渲染。可以做到自动登陆的功能。</p><p>###自动登录(登录验证)</p><p>想要达到的目的就是将访问网站的用户所在的线程和ThreadLocal进行绑定，解决了线程安全的问题。</p><p><strong>com.nowcoder.interceptor.PassportInterceptor：</strong></p><pre><code class="java">@Componentpublic class PassportInterceptor implements HandlerInterceptor {    @Autowired    private LoginTicketDAO loginTicketDAO;    @Autowired    private UserDAO userDAO;    @Autowired    private HostHolder hostHolder;  //在preHandle中我们实现了自动登录，检查cookie中的ticket，通过找到的ticket在数据库中查找对应的LoginTicket对象，如果LoginTicket对象有效，然后通过LoginTicket对象中的userid字段，找到user对象    @Override    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {        String ticket=null;        if (httpServletRequest.getCookies()!=null){          //在cook中找ticket            for (Cookie cookie:httpServletRequest.getCookies()){               if (cookie.getName().equals(&quot;ticket&quot;)){                   ticket=cookie.getValue();                   break;               }            }        }        //cookie可以伪造，所以光查看cookie不够        //如果客户端有ticket存在，查看与服务器后端的数据库中的值是否相等        if (ticket!=null){            LoginTicket loginTicket=loginTicketDAO.selectByTicket(ticket);            //ticket不相等、超过期限或者状态无效            if (loginTicket==null||loginTicket.getExpired().before(new Date())||loginTicket.getStatus()!=0)            {                return  true;            }            //认证过后，将用户信息保存在hostHolder中，方便后面的流程使用            User user=userDAO.selectById(loginTicket.getUserId());            hostHolder.setUser(user);        }        return true;    }         //在controller结束的时候，通常会把结果返回给view视图，在拦截器中postHandle方法做    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {        if (modelAndView != null &amp;&amp; hostHolder.getUser() != null) {            modelAndView.addObject(&quot;user&quot;, hostHolder.getUser());        }    }    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {        hostHolder.clear();    }}</code></pre><p><strong>com.nowcoder.model.HostHolder：</strong></p><pre><code class="java">/** * ThreadLocal的用法 * * 使用ThreadLocal把里面的值共享给所有的类 */@Componentpublic class HostHolder {    private static ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;User&gt;();    public User getUser() {        return users.get();    }    public void setUser(User user) {        users.set(user);    }    public void clear() {        users.remove();;    }}</code></pre><p>###权限管理</p><p>拦截位置放在登陆验证PassportInterceptor的后面，通过登陆验证看HostHolder类中有没有线程本地变量user类，如果有，能确定是谁登陆的。如果没有，那没有权限访问/setting*相关的页面。通过PassportInterceptor的PreHandler()方法后，进入LoginRequiredInterceptor的PreHandler方法，如果没有拿到user类，返回false。不能进入controller层，重定向到首页，并且约定pop=1，弹出登陆框。</p><p>新增一个拦截器LoginRequiredInterceptor:</p><pre><code class="java">@Componentpublic class LoginRequiredInterceptor implements HandlerInterceptor {    @Autowired    private HostHolder hostHolder;    @Override    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {      //歧视就是当前用户没有登录，直接重定向        if (hostHolder.getUser()==null){            httpServletResponse.sendRedirect(&quot;/?pop=1&quot;);////自己定义的，传到前端，假如pop=1，让登录框弹出            return false;        }        return true;    }    @Override    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {    }}</code></pre><p>当用户证明没有登录，网址会重定向到：<a href="http://localhost:8080/?pop=1" target="_blank" rel="noopener">http://localhost:8080/?pop=1</a>，重定向到这个url会发生什么呢？往下看</p><p>templates/home.html中:</p><pre><code class="html">#if ($pop)&lt;script&gt;window.loginpop = $!{pop};&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/scripts/main/site/home.js&quot;&gt;&lt;/script&gt;#end</code></pre><p>将变量pop的值付给了window.loginpop，此时的window.loginpop=1</p><p>然后static/scripts/main/site/home.js中：</p><pre><code class="javascript">    function fInitialize() {        if (window.loginpop &gt; 0) {            fClickLogin();        }    }    function fClickLogin() {        var that = this;        PopupLogin.show({            listeners: {                login: function () {                    //alert(&#39;login&#39;);                    window.location.reload();                },                register: function () {                    //alert(&#39;reg&#39;);                    window.location.reload();                }            }        });    }</code></pre><p>上面大致的意思就是：当window.loginpop &gt; 0时，执行<strong>function fClickLogin()</strong>，在项目中就是跳出登录框，如图：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-34024.png" alt="屏幕快照 2019-03-29 下午9.24.17"></p>]]></content>
      
      
      <categories>
          
          <category> 牛客中级项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Interceptor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS原理分析</title>
      <link href="/2019/03/28/java/java-duo-xian-cheng/cas-yuan-li-fen-xi/"/>
      <url>/2019/03/28/java/java-duo-xian-cheng/cas-yuan-li-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>#CAS原理分析</p><p>我们知道多线程操作共享资源时，会出现三个问题：<strong>可见性</strong>、<strong>有序性</strong>以及<strong>原子性</strong>。</p><blockquote><p>一般情况下，我们采用synchronized同步锁(独占锁、互斥锁)，即同一时间只有一个线程能够修改共享变量，其他线程必须等待。但是这样的话就相当于单线程，体现不出来多线程的优势。</p></blockquote><p>那么我们有没有另一种方式来解决这三个问题呢?</p><blockquote><p>之前提到的一个volatile关键字，它可以解决可见性和有序性的问题。而且如果操作的共享变量是基本数据类型，并且同一时间只对变量==进行读取或者写入的操作==，那么原子性问题也得到了解决，就不会产生多线程问题了。</p></blockquote><p>但是通常，我们都要先==读取共享变量，然后操作共享变量，最后写入共享变量==，那么这个时候怎么保证整个操作的原子性呢？一种解决方式就是CAS技术。<br>CAS（Compare and Swap）即比较并交换。在讲解这个之前，先了解两个重要概念：悲观锁与乐观锁。</p><h2 id="一-悲观锁与乐观锁"><a href="#一-悲观锁与乐观锁" class="headerlink" title="一. 悲观锁与乐观锁"></a>一. 悲观锁与乐观锁</h2><ul><li>悲观锁: 假定会发生并发冲突，即共享资源会被某个线程更改。所以当某个线程获取共享资源时，会阻止别的线程获取共享资源。也称独占锁或者互斥锁，例如java中的synchronized同步锁。</li><li>乐观锁: 假设不会发生并发冲突,只有在最后更新共享资源的时候会判断一下在此期间有没有别的线程修改了这个共享资源。如果发生冲突就重试，直到没有冲突，更新成功。<strong>CAS就是一种乐观锁实现方式</strong>。</li></ul><blockquote><p>悲观锁会阻塞其他线程。乐观锁不会阻塞其他线程，如果发生冲突，采用死循环的方式一直重试，直到更新成功。</p></blockquote><h2 id="二-CAS的实现原理"><a href="#二-CAS的实现原理" class="headerlink" title="二. CAS的实现原理"></a>二. CAS的实现原理</h2><p>CAS的原理很简单，包含三个值当前内存值(V)、预期原来的值(A)以及期待更新的值(B)。</p><blockquote><p>如果内存位置V的值与预期原值A相匹配，那么处理器会自动将该位置值更新为新值B,返回true。否则处理器不做任何操作，返回false。</p></blockquote><p>实现CAS最重要的一点，就是比较和交换操作的一致性，否则就会产生歧义。</p><blockquote><p>比如当前线程比较成功后，准备更新共享变量值的时候，这个共享变量值被其他线程更改了，那么CAS函数必须返回false。</p></blockquote><p>要实现这个需求，java中提供了Unsafe类，它提供了三个函数，分别用来操作基本类型int和long，以及引用类型Object。==并能保证此次操作的原子性==</p><pre><code class="java">    public final native boolean compareAndSwapObject       (Object obj, long valueOffset, Object expect, Object update);    public final native boolean compareAndSwapInt       (Object obj, long valueOffset, int expect, int update);    public final native boolean compareAndSwapLong      (Object obj, long valueOffset, long expect, long update);</code></pre><p>参数的意义：</p><blockquote><ol><li>obj 和 valueOffset：表示这个共享变量的内存地址。这个共享变量是obj对象的一个成员属性，valueOffset表示这个共享变量在obj类中的内存偏移量。所以通过这两个参数就可以直接在内存中修改和读取共享变量值。</li><li>expect: 表示预期原来的值。</li><li>update: 表示期待更新的值。</li></ol></blockquote><p>接下来我们来看看java并发框架下的atomic包是如何使用CAS的。</p><h2 id="三-JUC并发框架下的原子类-atomic"><a href="#三-JUC并发框架下的原子类-atomic" class="headerlink" title="三. JUC并发框架下的原子类(atomic)"></a>三. JUC并发框架下的原子类(atomic)</h2><h3 id="JUC-包中的原子类是哪4类"><a href="#JUC-包中的原子类是哪4类" class="headerlink" title="JUC 包中的原子类是哪4类?"></a>JUC 包中的原子类是哪4类?</h3><p>####<strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整形原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean ：布尔型原子类</li></ul><p>####<strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray ：引用类型数组原子类</li></ul><p>####<strong>引用类型</strong></p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedRerence：原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul><p>####<strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater:原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><p>调用JUC并发框架下原子类的方法时，不需要考虑多线程问题。那么我们分析它是怎么解决多线程问题的。以AtomicInteger类为例</p><h2 id="3-1成员变量"><a href="#3-1成员变量" class="headerlink" title="3.1成员变量"></a>3.1成员变量</h2><pre><code class="java">   // 通过它来实现CAS操作的。因为是int类型，所以调用它的compareAndSwapInt方法    private static final Unsafe unsafe = Unsafe.getUnsafe();    // value这个共享变量在AtomicInteger对象上内存偏移量，    // 通过它直接在内存中修改value的值，compareAndSwapInt方法中需要这个参数    private static final long valueOffset;    // 通过静态代码块，在AtomicInteger类加载时就会调用    static {        try {            // 通过unsafe类，获取value变量在AtomicInteger对象上内存偏移量，其中objectFieldOffset是一个本地方法            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(&quot;value&quot;));        } catch (Exception ex) { throw new Error(ex); }    }    // 共享变量，AtomicInteger就保证了对它多线程操作的安全性。    // 使用volatile修饰，解决了可见性和有序性问题。    private volatile int value;</code></pre><p>有三个重要的属性：</p><blockquote><ol><li>unsafe: 通过它实现CAS操作，因为共享变量是int类型，所以调用compareAndSwapInt方法。</li><li>valueOffset: 共享变量value在AtomicInteger对象上内存偏移量</li><li>value: 共享变量，使用volatile修饰，解决了可见性和有序性问题。</li></ol></blockquote><p>##3.2 重要方法</p><p>###3.2.1 get与set方法</p><pre><code class="java">    // 直接读取。因为是volatile关键子修饰的，总是能看到(任意线程)对这个volatile变量最新的写入    public final int get() {        return value;    }    // 直接写入。因为是volatile关键子修饰的，所以它修改value变量也会立即被别的线程读取到。    public final void set(int newValue) {        value = newValue;    }</code></pre><p>因为value变量是volatile关键字修饰的，它总是能读取(任意线程)对这个volatile变量最新的写入。它修改value变量也会立即被别的线程读取到。</p><h3 id="3-2-2-compareAndSet方法"><a href="#3-2-2-compareAndSet方法" class="headerlink" title="3.2.2 compareAndSet方法"></a>3.2.2 compareAndSet方法</h3><pre><code class="java">    // 如果value变量的当前值(内存值)等于期望值(expect)，那么就把update赋值给value变量，返回true。    // 如果value变量的当前值(内存值)不等于期望值(expect)，就什么都不做，返回false。    // 这个就是CAS操作，使用unsafe.compareAndSwapInt方法，保证整个操作过程的原子性    public final boolean compareAndSet(int expect, int update) {        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);    }</code></pre><p>通过调用unsafe的compareAndSwapInt方法实现CAS函数的。==但是CAS函数只能保证比较并交换操作的原子性，但是更新操作并不一定会执行==。</p><p>比如我们想让共享变量value自增。<br>共享变量value自增是三个操作，1.读取value值，2.计算value+1的值，3.将value+1的值赋值给value。分析这三个操作：</p><blockquote><ol><li>读取value值,因为value变量是volatile关键字修饰的，能够读取到任意线程对它最后一次修改的值，所以没问题。</li><li>计算value+1的值：这个时候就有问题了，可能在计算这个值的时候，其他线程更改了value值，因为没有加同步锁，所以其他线程可以更改value值。</li><li>将value+1的值赋值给value: 使用CAS函数，如果返回false，说明在当前线程读取value值到调用CAS函数方法前，共享变量被其他线程修改了，那么value+1的结果值就不是我们想要的了，因为要重新计算。</li></ol></blockquote><h3 id="3-2-3-getAndAddInt方法"><a href="#3-2-3-getAndAddInt方法" class="headerlink" title="3.2.3 getAndAddInt方法"></a>3.2.3 getAndAddInt方法</h3><pre><code class="java">     public final int getAndAddInt(Object obj, long valueOffset, int var) {        int expect;        // 利用循环，直到更新成功才跳出循环。        do {            // 获取value的最新值            expect = this.getIntVolatile(obj, valueOffset);            // expect + var表示需要更新的值，如果compareAndSwapInt返回false，说明value值被其他线程更改了。            // 那么就循环重试，再次获取value最新值expect，然后再计算需要更新的值expect + var。直到更新成功        } while(!this.compareAndSwapInt(obj, valueOffset, expect, expect + var));        // 返回当前线程在更改value成功后的，value变量原先值。并不是更改后的值        return expect;    }</code></pre><p>这个方法在Unsafe类中，利用do_while循环，先利用当前值，计算更新值，然后通过compareAndSwapInt方法设置value变量，如果compareAndSwapInt方法返回失败，表示value变量的值被别的线程更改了，所以循环获取value变量最新值，再通过compareAndSwapInt方法设置value变量。直到设置成功。跳出循环，返回更新前的值。</p><pre><code class="java">    // 将value的值当前值的基础上加1，并返回当前值    public final int getAndIncrement() {        return unsafe.getAndAddInt(this, valueOffset, 1);    }    // 将value的值当前值的基础上加-1，并返回当前值    public final int getAndDecrement() {        return unsafe.getAndAddInt(this, valueOffset, -1);    }    // 将value的值当前值的基础上加delta，并返回当前值    public final int getAndAdd(int delta) {        return unsafe.getAndAddInt(this, valueOffset, delta);    }    // 将value的值当前值的基础上加1，并返回更新后的值(即当前值加1)    public final int incrementAndGet() {        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;    }    // 将value的值当前值的基础上加-1，并返回更新后的值(即当前值加-1)    public final int decrementAndGet() {        return unsafe.getAndAddInt(this, valueOffset, -1) - 1;    }    // 将value的值当前值的基础上加delta，并返回更新后的值(即当前值加delta)    public final int addAndGet(int delta) {        return unsafe.getAndAddInt(this, valueOffset, delta) + delta;    }</code></pre><p>都是利用unsafe.getAndAddInt方法实现的。</p><h2 id="3-3-能不能给我简单介绍一下-AtomicInteger-类的原理？"><a href="#3-3-能不能给我简单介绍一下-AtomicInteger-类的原理？" class="headerlink" title="3.3 能不能给我简单介绍一下 AtomicInteger 类的原理？"></a>3.3 能不能给我简单介绍一下 AtomicInteger 类的原理？</h2><p>AtomicInteger 类主要利用 <strong>CAS</strong> (compare and swap) + <strong>volatile</strong> 和 <strong>native</strong> 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> CAS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式也可以这么简单</title>
      <link href="/2019/03/25/she-ji-mo-shi/she-ji-mo-shi/"/>
      <url>/2019/03/25/she-ji-mo-shi/she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p><a id="more"></a><p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。是的，我不善于扯这些有的没的，还是少点废话吧<del>~</del></p><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><p><strong>目录</strong></p><!-- toc --><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p><pre><code class="java">public class FoodFactory {    public static Food makeFood(String name) {        if (name.equals(&quot;noodle&quot;)) {            Food noodle = new LanZhouNoodle();            noodle.addSpicy(&quot;more&quot;);            return noodle;        } else if (name.equals(&quot;chicken&quot;)) {            Food chicken = new HuangMenChicken();            chicken.addCondiment(&quot;potato&quot;);            return chicken;        } else {            return null;        }    }}</code></pre><p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p><p>简单地说，==简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。==</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。但是违反了开放封闭原则。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><pre><code class="java">public interface FoodFactory {    Food makeFood(String name);}public class ChineseFoodFactory implements FoodFactory {    @Override    public Food makeFood(String name) {        if (name.equals(&quot;A&quot;)) {            return new ChineseFoodA();        } else if (name.equals(&quot;B&quot;)) {            return new ChineseFoodB();        } else {            return null;        }    }}public class AmericanFoodFactory implements FoodFactory {    @Override    public Food makeFood(String name) {        if (name.equals(&quot;A&quot;)) {            return new AmericanFoodA();        } else if (name.equals(&quot;B&quot;)) {            return new AmericanFoodB();        } else {            return null;        }    }}</code></pre><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><pre><code class="java">public class APP {    public static void main(String[] args) {        // 先选择一个具体的工厂        FoodFactory factory = new ChineseFoodFactory();        // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象        Food food = factory.makeFood(&quot;A&quot;);    }}</code></pre><p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>==核心在于，我们需要在第一步选好我们需要的工厂==</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034633.png" alt="factory-1"></p><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034635.png" alt="factory-1"></p><p>这个时候的客户端调用是这样的：</p><pre><code class="java">// 得到 Intel 的 CPUCPUFactory cpuFactory = new IntelCPUFactory();CPU cpu = intelCPUFactory.makeCPU();// 得到 AMD 的主板MainBoardFactory mainBoardFactory = new AmdMainBoardFactory();MainBoard mainBoard = mainBoardFactory.make();// 组装 CPU 和主板Computer computer = new Computer(cpu, mainBoard);</code></pre><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034637.png" alt="abstract-factory-2"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034637-1.png" alt="abstract-factory-3"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><pre><code class="java">public static void main(String[] args) {    // 第一步就要选定一个“大厂”    ComputerFactory cf = new AmdFactory();    // 从这个大厂造 CPU    CPU cpu = cf.makeCPU();    // 从这个大厂造主板    MainBoard board = cf.makeMainBoard();      // 从这个大厂造硬盘      HardDisk hardDisk = cf.makeHardDisk();    // 将同一个厂子出来的 CPU、主板、硬盘组装在一起    Computer result = new Computer(cpu, board, hardDisk);}</code></pre><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>==对修改关闭，对扩展开放==</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><pre><code class="java">public class Singleton {    // 首先，将 new Singleton() 堵死    private Singleton() {};    // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建    private static Singleton instance = new Singleton();    public static Singleton getInstance() {        return instance;    }    // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，    // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了    public static Date getDate(String mode) {return new Date();}}</code></pre><blockquote><p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><pre><code class="java">public class Singleton {    // 首先，也是先堵死 new Singleton() 这条路    private Singleton() {}    // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的    private static volatile Singleton instance = null;    public static Singleton getInstance() {        if (instance == null) {            // 加锁            synchronized (Singleton.class) {                // 这一次判断也是必须的，不然会有并发问题                if (instance == null) {                    instance = new Singleton();                }            }        }        return instance;    }}</code></pre><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><pre><code class="java">public class Singleton3 {    private Singleton3() {}    // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性    private static class Holder {        private static Singleton3 instance = new Singleton3();    }    public static Singleton3 getInstance() {        return Holder.instance;    }}</code></pre><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，一定有人跳出来说用枚举实现单例，是的没错，枚举类很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。不说了，读者自己看着办吧，不建议使用。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><pre><code class="java">Food food = new FoodBuilder().a().b().c().build();Food food = Food.builder().a().b().c().build();</code></pre><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p><p>来一个中规中矩的建造者模式：</p><pre><code class="java">class User {    // 下面是“一堆”的属性    private String name;    private String password;    private String nickName;    private int age;    // 构造方法私有化，不然客户端就会直接调用构造方法了    private User(String name, String password, String nickName, int age) {        this.name = name;        this.password = password;        this.nickName = nickName;        this.age = age;    }    // 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，    // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好    public static UserBuilder builder() {        return new UserBuilder();    }    public static class UserBuilder {        // 下面是和 User 一模一样的一堆属性        private String  name;        private String password;        private String nickName;        private int age;        private UserBuilder() {        }        // 链式调用设置各个属性值，返回 this，即 UserBuilder        public UserBuilder name(String name) {            this.name = name;            return this;        }        public UserBuilder password(String password) {            this.password = password;            return this;        }        public UserBuilder nickName(String nickName) {            this.nickName = nickName;            return this;        }        public UserBuilder age(int age) {            this.age = age;            return this;        }        // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。        // 当然，可以在 “复制” 之前做点检验        public User build() {            if (name == null || password == null) {                throw new RuntimeException(&quot;用户名和密码必填&quot;);            }            if (age &lt;= 0 || age &gt;= 150) {                throw new RuntimeException(&quot;年龄不合法&quot;);            }            // 还可以做赋予”默认值“的功能              if (nickName == null) {                nickName = name;            }            return new User(name, password, nickName, age);        }    }}</code></pre><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><pre><code class="java">public class APP {    public static void main(String[] args) {        User d = User.builder()                .name(&quot;foo&quot;)                .password(&quot;pAss12345&quot;)                .age(25)                .build();    }}</code></pre><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><pre><code class="java">@Builderclass User {    private String  name;    private String password;    private String nickName;    private int age;}</code></pre><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><pre><code class="java">User user = new User().setName(&quot;&quot;).setPassword(&quot;&quot;).setAge(20);</code></pre><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><pre><code class="java">protected native Object clone() throws CloneNotSupportedException;</code></pre><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><pre><code class="java">public interface FoodService {    Food makeChicken();    Food makeNoodle();}public class FoodServiceImpl implements FoodService {    public Food makeChicken() {          Food f = new Chicken()        f.setChicken(&quot;1kg&quot;);          f.setSpicy(&quot;1g&quot;);          f.setSalt(&quot;3g&quot;);        return f;    }    public Food makeNoodle() {        Food f = new Noodle();        f.setNoodle(&quot;500g&quot;);        f.setSalt(&quot;5g&quot;);        return f;    }}// 代理要表现得“就像是”真实实现类，所以需要实现 FoodServicepublic class FoodServiceProxy implements FoodService {    // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入    private FoodService foodService = new FoodServiceImpl();    public Food makeChicken() {        System.out.println(&quot;我们马上要开始制作鸡肉了&quot;);        // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，        // 代理只是在核心代码前后做些“无足轻重”的事情        Food food = foodService.makeChicken();        System.out.println(&quot;鸡肉制作完成啦，加点胡椒粉&quot;); // 增强          food.addCondiment(&quot;pepper&quot;);        return food;    }    public Food makeNoodle() {        System.out.println(&quot;准备制作拉面~&quot;);        Food food = foodService.makeNoodle();        System.out.println(&quot;制作完成啦&quot;)        return food;    }}</code></pre><p>客户端调用，注意，我们要用代理来实例化接口：</p><pre><code class="java">// 这里用代理类来实例化FoodService foodService = new FoodServiceProxy();foodService.makeChicken();</code></pre><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034639.png" alt="proxy"></p><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，算了还是不要吹捧这个名词了，在 AOP 中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说 …… ==Spring 中实现动态代理有两种==，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><pre><code class="java">public interface FileAlterationListener {    void onStart(final FileAlterationObserver observer);    void onDirectoryCreate(final File directory);    void onDirectoryChange(final File directory);    void onDirectoryDelete(final File directory);    void onFileCreate(final File file);    void onFileChange(final File file);    void onFileDelete(final File file);    void onStop(final FileAlterationObserver observer);}</code></pre><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><pre><code class="java">public class FileAlterationListenerAdaptor implements FileAlterationListener {    public void onStart(final FileAlterationObserver observer) {    }    public void onDirectoryCreate(final File directory) {    }    public void onDirectoryChange(final File directory) {    }    public void onDirectoryDelete(final File directory) {    }    public void onFileCreate(final File file) {    }    public void onFileChange(final File file) {    }    public void onFileDelete(final File file) {    }    public void onStop(final FileAlterationObserver observer) {    }}</code></pre><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><pre><code class="java">public class FileMonitor extends FileAlterationListenerAdaptor {    public void onFileCreate(final File file) {        // 文件创建        doSomething();    }    public void onFileDelete(final File file) {        // 文件删除        doSomething();    }}</code></pre><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><pre><code class="java">public interface Duck {    public void quack(); // 鸭的呱呱叫      public void fly(); // 飞}public interface Cock {    public void gobble(); // 鸡的咕咕叫      public void fly(); // 飞}public class WildCock implements Cock {    public void gobble() {        System.out.println(&quot;咕咕叫&quot;);    }      public void fly() {        System.out.println(&quot;鸡也会飞哦&quot;);    }}</code></pre><p>鸭接口有 fly() 和 quack() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><pre><code class="java">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用public class CockAdapter implements Duck {    Cock cock;    // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用      public CockAdapter(Cock cock) {        this.cock = cock;    }    // 实现鸭的呱呱叫方法      @Override      public void quack() {        // 内部其实是一只鸡的咕咕叫        cock.gobble();    }      @Override      public void fly() {        cock.fly();    }}</code></pre><p>客户端调用很简单了：</p><pre><code class="java">public static void main(String[] args) {    // 有一只野鸡      Cock wildCock = new WildCock();      // 成功将野鸡适配成鸭      Duck duck = new CockAdapter(wildCock);      ...}</code></pre><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034640.png" alt="adapter-1"></p><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034641.png" alt="adapter-1"></p><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，<strong>代理模式做的是增强原方法的活</strong>；<strong>适配器做的是适配的活</strong>，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034643.png" alt="adapter-5"></p></li></ol><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><pre><code class="java">public interface DrawAPI {   public void draw(int radius, int x, int y);}</code></pre><p>然后是一系列实现类：</p><pre><code class="java">public class RedPen implements DrawAPI {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class GreenPen implements DrawAPI {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class BluePen implements DrawAPI {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}</code></pre><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><pre><code class="java">public abstract class Shape {   protected DrawAPI drawAPI;   protected Shape(DrawAPI drawAPI){      this.drawAPI = drawAPI;   }   public abstract void draw();    }</code></pre><p>定义抽象类的子类：</p><pre><code class="java">// 圆形public class Circle extends Shape {   private int radius;   public Circle(int radius, DrawAPI drawAPI) {      super(drawAPI);      this.radius = radius;   }   public void draw() {      drawAPI.draw(radius, 0, 0);   }}// 长方形public class Rectangle extends Shape {    private int x;      private int y;      public Rectangle(int x, int y, DrawAPI drawAPI) {        super(drawAPI);          this.x = x;          this.y = y;    }      public void draw() {      drawAPI.draw(0, x, y);   }}</code></pre><p>最后，我们来看客户端演示：</p><pre><code class="java">public static void main(String[] args) {    Shape greenCircle = new Circle(10, new GreenPen());      Shape redRectangle = new Rectangle(4, 8, new RedPen());      greenCircle.draw();      redRectangle.draw();}</code></pre><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034645.png" alt="bridge-1"></p><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><blockquote><p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm" target="_blank" rel="noopener">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 Java IO 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034646.png" alt="decorator-1"></p><p>我们来说说装饰模式的出发点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 ConcreteDecorator* 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent* 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？万一有个变态要四份柠檬，所以这种做法是给自己找加班的。</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><pre><code class="java">public abstract class Beverage {      // 返回描述      public abstract String getDescription();      // 返回价格      public abstract double cost();}</code></pre><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><pre><code class="java">public class BlackTea extends Beverage {      public String getDescription() {        return &quot;红茶&quot;;    }      public double cost() {        return 10;    }}public class GreenTea extends Beverage {    public String getDescription() {        return &quot;绿茶&quot;;    }      public double cost() {        return 11;    }}...// 咖啡省略</code></pre><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><pre><code class="java">// 调料public abstract class Condiment extends Beverage {}</code></pre><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承 Condiment 类：</p><pre><code class="java">public class Lemon extends Condiment {    private Beverage bevarage;      // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，      // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶      public Lemon(Beverage bevarage) {        this.bevarage = bevarage;    }      public String getDescription() {        // 装饰        return bevarage.getDescription() + &quot;, 加柠檬&quot;;    }      public double cost() {          // 装饰        return beverage.cost() + 2; // 加柠檬需要 2 元    }}public class Mango extends Condiment {    private Beverage bevarage;      public Mango(Beverage bevarage) {        this.bevarage = bevarage;    }      public String getDescription() {        return bevarage.getDescription() + &quot;, 加芒果&quot;;    }      public double cost() {        return beverage.cost() + 3; // 加芒果需要 3 元    }}...// 给每一种调料都加一个类</code></pre><p>看客户端调用：</p><pre><code class="java">public static void main(String[] args) {      // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡    Beverage beverage = new GreenTea();      // 开始装饰      beverage = new Lemon(beverage); // 先加一份柠檬      beverage = new Mongo(beverage); // 再加一份芒果      System.out.println(beverage.getDescription() + &quot; 价格：￥&quot; + beverage.cost());      //&quot;绿茶, 加柠檬, 加芒果 价格：￥16&quot;}</code></pre><p>如果我们需要芒果珍珠双份柠檬红茶：</p><pre><code class="java">Beverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea()))));</code></pre><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034648.png" alt="decorator-2"></p><p>到这里，大家应该已经清楚装饰模式了吧。</p><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034649.png" alt="decorator-3"></p><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，其实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><pre><code class="java">InputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(&quot;&quot;)));</code></pre><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><pre><code class="java">DataInputStream is = new DataInputStream(                              new BufferedInputStream(                                  new FileInputStream(&quot;&quot;)));</code></pre><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><pre><code class="java">public interface Shape {   void draw();}</code></pre><p>定义几个实现类：</p><pre><code class="java">public class Circle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Circle::draw()&quot;);   }}public class Rectangle implements Shape {   @Override   public void draw() {      System.out.println(&quot;Rectangle::draw()&quot;);   }}</code></pre><p>客户端调用：</p><pre><code class="java">public static void main(String[] args) {    // 画一个圆形      Shape circle = new Circle();      circle.draw();      // 画一个长方形      Shape rectangle = new Rectangle();      rectangle.draw();}</code></pre><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><pre><code class="java">public class ShapeMaker {   private Shape circle;   private Shape rectangle;   private Shape square;   public ShapeMaker() {      circle = new Circle();      rectangle = new Rectangle();      square = new Square();   }  /**   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定   */   public void drawCircle(){      circle.draw();   }   public void drawRectangle(){      rectangle.draw();   }   public void drawSquare(){      square.draw();   }}</code></pre><p>看看现在客户端怎么调用：</p><pre><code class="java">public static void main(String[] args) {  ShapeMaker shapeMaker = new ShapeMaker();  // 客户端调用现在更加清晰了  shapeMaker.drawCircle();  shapeMaker.drawRectangle();  shapeMaker.drawSquare();        }</code></pre><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><pre><code class="java">public class Employee {   private String name;   private String dept;   private int salary;   private List&lt;Employee&gt; subordinates; // 下属   public Employee(String name,String dept, int sal) {      this.name = name;      this.dept = dept;      this.salary = sal;      subordinates = new ArrayList&lt;Employee&gt;();   }   public void add(Employee e) {      subordinates.add(e);   }   public void remove(Employee e) {      subordinates.remove(e);   }   public List&lt;Employee&gt; getSubordinates(){     return subordinates;   }   public String toString(){      return (&quot;Employee :[ Name : &quot; + name + &quot;, dept : &quot; + dept + &quot;, salary :&quot; + salary+&quot; ]&quot;);   }   }</code></pre><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><p>首先，先定义一个策略接口：</p><pre><code class="java">public interface Strategy {   public void draw(int radius, int x, int y);}</code></pre><p>然后我们定义具体的几个策略：</p><pre><code class="java">public class RedPen implements Strategy {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用红色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class GreenPen implements Strategy {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用绿色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}public class BluePen implements Strategy {   @Override   public void draw(int radius, int x, int y) {      System.out.println(&quot;用蓝色笔画图，radius:&quot; + radius + &quot;, x:&quot; + x + &quot;, y:&quot; + y);   }}</code></pre><p>使用策略的类：</p><pre><code class="java">public class Context {   private Strategy strategy;   public Context(Strategy strategy){      this.strategy = strategy;   }   public int executeDraw(int radius, int x, int y){      return strategy.draw(radius, x, y);   }}</code></pre><p>客户端演示：</p><pre><code class="java">public static void main(String[] args) {    Context context = new Context(new BluePen()); // 使用绿色笔来画      context.executeDraw(10, 0, 0);}</code></pre><p>放到一张图上，让大家看得清晰些：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034650.png" alt="strategy-1"></p><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/034645.png" alt="bridge-1"></p><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><pre><code class="java">public class Subject {   private List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();   private int state;   public int getState() {      return state;   }   public void setState(int state) {      this.state = state;      // 数据已变更，通知观察者们      notifyAllObservers();   }   public void attach(Observer observer){      observers.add(observer);           }   // 通知观察者们   public void notifyAllObservers(){      for (Observer observer : observers) {         observer.update();      }   }     }</code></pre><p>定义观察者接口：</p><pre><code class="java">public abstract class Observer {   protected Subject subject;   public abstract void update();}</code></pre><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><p>我们来定义具体的几个观察者类：</p><pre><code class="java">public class BinaryObserver extends Observer {      // 在构造方法中进行订阅主题    public BinaryObserver(Subject subject) {        this.subject = subject;        // 通常在构造方法中将 this 发布出去的操作一定要小心        this.subject.attach(this);    }      // 该方法由主题类在数据变更的时候进行调用    @Override    public void update() {        String result = Integer.toBinaryString(subject.getState());        System.out.println(&quot;订阅的数据发生变化，新的数据处理为二进制值为：&quot; + result);    }}public class HexaObserver extends Observer {    public HexaObserver(Subject subject) {        this.subject = subject;        this.subject.attach(this);    }    @Override    public void update() {          String result = Integer.toHexString(subject.getState()).toUpperCase();        System.out.println(&quot;订阅的数据发生变化，新的数据处理为十六进制值为：&quot; + result);    }}</code></pre><p>客户端使用也非常简单：</p><pre><code class="java">public static void main(String[] args) {    // 先定义一个主题      Subject subject1 = new Subject();      // 定义观察者      new BinaryObserver(subject1);      new HexaObserver(subject1);      // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用      subject.setState(11);}</code></pre><p>output:</p><pre><code>订阅的数据发生变化，新的数据处理为二进制值为：1011订阅的数据发生变化，新的数据处理为十六进制值为：B</code></pre><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><pre><code class="java">public abstract class RuleHandler {      // 后继节点    protected RuleHandler successor;    public abstract void apply(Context context);    public void setSuccessor(RuleHandler successor) {        this.successor = successor;    }    public RuleHandler getSuccessor() {        return successor;    }}</code></pre><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><pre><code class="java">public class NewUserRuleHandler extends RuleHandler {    public void apply(Context context) {        if (context.isNewUser()) {              // 如果有后继节点的话，传递下去            if (this.getSuccessor() != null) {                this.getSuccessor().apply(context);            }        } else {            throw new RuntimeException(&quot;该活动仅限新用户参与&quot;);        }    }}</code></pre><p>校验用户所在地区是否可以参与：</p><pre><code class="java">public class LocationRuleHandler extends RuleHandler {    public void apply(Context context) {        boolean allowed = activityService.isSupportedLocation(context.getLocation);          if (allowed) {            if (this.getSuccessor() != null) {                this.getSuccessor().apply(context);            }        } else  {            throw new RuntimeException(&quot;非常抱歉，您所在的地区无法参与本次活动&quot;);        }    }}</code></pre><p>校验奖品是否已领完：</p><pre><code class="java">public class LimitRuleHandler extends RuleHandler {    public void apply(Context context) {          int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品        if (remainedTimes &gt; 0) {            if (this.getSuccessor() != null) {                this.getSuccessor().apply(userInfo);            }        } else {            throw new RuntimeException(&quot;您来得太晚了，奖品被领完了&quot;);        }    }}</code></pre><p>客户端：</p><pre><code class="java">public static void main(String[] args) {    RuleHandler newUserHandler = new NewUserRuleHandler();      RuleHandler locationHandler = new LocationRuleHandler();      RuleHandler limitHandler = new LimitRuleHandler();      // 假设本次活动仅校验地区和奖品数量，不校验新老用户      locationHandler.setSuccessor(limitHandler);      locationHandler.apply(context);}</code></pre><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的，这也是在开源代码中大量被使用的。</p><p>通常会有一个抽象类：</p><pre><code class="java">public abstract class AbstractTemplate {    // 这就是模板方法      public void templateMethod(){        init();        apply(); // 这个是重点        end(); // 可以作为钩子方法    }    protected void init() {        System.out.println(&quot;init 抽象层已经实现，子类也可以选择覆写&quot;);    }      // 留给子类实现    protected abstract void apply();    protected void end() {    }}</code></pre><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>我们写一个实现类：</p><pre><code class="java">public class ConcreteTemplate extends AbstractTemplate {    public void apply() {        System.out.println(&quot;子类实现抽象方法 apply&quot;);    }      public void end() {        System.out.println(&quot;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了&quot;);    }}</code></pre><p>客户端调用演示：</p><pre><code class="java">public static void main(String[] args) {    AbstractTemplate t = new ConcreteTemplate();      // 调用模板方法      t.templateMethod();}</code></pre><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><pre><code class="java">public interface State {   public void doAction(Context context);}</code></pre><p>定义减库存的状态：</p><pre><code class="java">public class DeductState implements State {   public void doAction(Context context) {      System.out.println(&quot;商品卖出，准备减库存&quot;);      context.setState(this);      //... 执行减库存的具体操作   }   public String toString(){      return &quot;Deduct State&quot;;   }}</code></pre><p>定义补库存状态：</p><pre><code class="java">public class RevertState implements State {    public void doAction(Context context) {        System.out.println(&quot;给此商品补库存&quot;);          context.setState(this);          //... 执行加库存的具体操作    }      public String toString() {        return &quot;Revert State&quot;;    }}</code></pre><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><pre><code class="java">public class Context {    private State state;      private String name;      public Context(String name) {        this.name = name;    }      public void setState(State state) {        this.state = state;    }      public void getState() {        return this.state;    }}</code></pre><p>我们来看下客户端调用，大家就一清二楚了：</p><pre><code class="java">public static void main(String[] args) {    // 我们需要操作的是 iPhone X    Context context = new Context(&quot;iPhone X&quot;);    // 看看怎么进行补库存操作      State revertState = new RevertState();      revertState.doAction(context);    // 同样的，减库存操作也非常简单      State deductState = new DeductState();      deductState.doAction(context);      // 如果需要我们可以获取当前的状态    // context.getState().toString();}</code></pre><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p>（全文完）</p>]]></content>
      
      
      
        <tags>
            
            <tag> design pattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java程序编译和运行的过程</title>
      <link href="/2019/03/25/java/java-ji-chu/java-cheng-xu-bian-yi-he-yun-xing-de-guo-cheng/"/>
      <url>/2019/03/25/java/java-ji-chu/java-cheng-xu-bian-yi-he-yun-xing-de-guo-cheng/</url>
      
        <content type="html"><![CDATA[<p>Java整个编译以及运行的过程相当繁琐，本文通过一个简单的程序来简单的说明整个流程。       </p><p>如下图，<strong>Java程序从源文件创建到程序运行要经过两大步骤</strong>：</p><p>1、源文件(.java)由编译器编译成字节码（ByteCode）  </p><p>2、字节码(.class)由java虚拟机解释运行。因为<strong>java程序既要编译同时也要经过JVM的解释运行</strong>，所以说Java被称为半解释语言（ “semi-interpreted” language）</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031302.png" alt="img"></p><p>下面通过以下这个java程序，来说明java程序从编译到最后运行的整个流程。代码如下：</p><pre><code class="java">//MainApp.java  public class MainApp {      public static void main(String[] args) {          Animal animal = new Animal(&quot;Puppy&quot;);          animal.printName();      }  }  //Animal.java  public class Animal {      public String name;      public Animal(String name) {          this.name = name;      }      public void printName() {          System.out.println(&quot;Animal [&quot;+name+&quot;]&quot;);      }  }  </code></pre><h1 id="第一步-编译"><a href="#第一步-编译" class="headerlink" title="第一步(编译)"></a>第一步(编译)</h1><p>创建完源文件之后，程序会先被编译为<code>.class</code>文件。Java编译一个类时，如果这个类所依赖的类还没有被编译，编译器就会先编译这个被依赖的类，然后引用。如果java编译器在指定目录（BootStrap加载路径下、ExtClassLoader加载路径下、AppClassLoader的加载路径下和自定义类加载器的路径下）下找不到该类所其依赖的类的<code>.class</code>文件或者<code>.java</code>源文件的话，编译器话会抛出<code>ClassNotFound异常</code>。</p><p>编译后的字节码文件格式主要分为两部分：<strong>常量池</strong>和<strong>方法字节码</strong>。==常量池记录的是代码出现过的所有token(<strong>类名</strong>，<strong>成员变量名</strong>等等)以及符号引用（<strong>方法引用</strong>，成员变量引用等等）==；方法字节码放的是==<strong>类中各个方法的字节码</strong>==。</p><p>下面是MainApp.class通过反汇编的结果，我们可以清楚看到.class文件的结构：</p><p>MainApp类常量池 ：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031304.png" alt="img"></p><p>MainApp类方法字节码：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031305.png" alt="img"></p><h1 id="第二步（运行）"><a href="#第二步（运行）" class="headerlink" title="第二步（运行）"></a>第二步（运行）</h1><p>java类运行的过程大概可分为两个过程：<strong>1、类的加载  2、类的执行</strong>。需要说明的是：JVM主要在程序第一次<strong>主动</strong>使用类的时候，才会去加载该类。也就是说，JVM并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次（双亲委派模型决定的只会加载一次）。</p><p>下面是程序运行的详细步骤：</p><ol><li><p>在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个名为AppMain.class的二进制文件，==将MainApp的<strong>类信息</strong>加载到运行时数据区的方法区内==，这个过程叫做MainApp==类的加载==。</p></li><li><p>然后JVM找到AppMain的主函数入口，开始执行main函数。</p></li><li><p>main函数的第一条命令是Animal  animal = new Animal(“Puppy”);就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。</p><p><strong>补充：</strong></p><p><strong>字段信息</strong>：存放类中声明的每一个字段的信息，包括字段的名、类型、修饰符。</p><p><strong>方法信息</strong>：类中声明的每一个方法的信息，包括方法名、返回值类型、参数类型、修饰符、异常、方法的字节码。</p></li><li><p>加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存, 然后调用构造函数初始化Animal实例（先进行<strong>默认初始化</strong>和<strong>显式初始化</strong>，然后<strong>调用构造方法</strong>），==这个Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用==。</p></li><li><p>当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，==然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息的<strong>方法表</strong>，获得printName()函数的字节码的地址==。</p></li><li><p>开始运行printName()函数。</p></li></ol><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-31306.png" alt="img"></p><p>特别说明：java类中所有public和protected的实例方法都采用<strong>动态绑定机制</strong>，所有私有方法、静态方法、构造器及初始化方法<clinit>都是采用静态绑定机制。而使用动态绑定机制的时候会用到方法表，静态绑定时并不会用到。</clinit></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><pre><code class="java">Animal animal = new Animal(&quot;Puppy&quot;);  </code></pre><p>在内存中到底执行了哪些步骤？</p><ol><li>加载Animal.class文件进内存(Application ClassLoader类加载器加载ClassPath上的Animal.class文件)，把类的<strong>类型信息</strong>加载到方法区中；</li><li>验证Animal.class文件，确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求；</li><li>准备，为类变量（static修饰的变量）分配内存并设置初始值(如int型默认为0)；</li><li>解析，将常量池的符号引用替换为直接引用；</li><li>初始化，执行<strong>类变量的赋值动作</strong>和<strong>静态语句块中的语句</strong>；</li><li>在栈内存为 animal 变量申请内存空间；</li><li>在堆内存为Animal对象申请内存空间；</li><li>对类中的成员变量进行默认初始化(比如int变量默认为0)；</li><li>对类中的成员变量进行显式初始化；</li><li>有构造代码块就先执行构造代码块，如果没有，则省略；</li><li>执行构造方法，通过构造方法对对对象属性进行初始化(这里就是利用构造器，传入”Puppy”为对象数据初始化)；</li><li>堆内存中的数据初始化完毕后，把内存值复制给 animal 变量</li></ol><h1 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h1><h2 id="静态代码块、构造代码块和构造方法"><a href="#静态代码块、构造代码块和构造方法" class="headerlink" title="静态代码块、构造代码块和构造方法"></a>静态代码块、构造代码块和构造方法</h2><pre><code class="java">public class PersonDemo {    private String name=&quot;zhang&quot;;    private int age;    private static String country = &quot;cn&quot;;    //静态代码块，对PersonDemo.class类进行初始化    static {        System.out.println(&quot;静态代码块&quot; + country);    }    //构造代码块，对对象进行初始化    {        System.out.println(&quot;构造代码块&quot; + this.name);    }    //构造方法    public PersonDemo(String name, int age) {        this.name = name;        this.age = age;    }    public void setName(String name) {        this.name = name;    }    public static void show() {        System.out.println(&quot;静态方法&quot; + country);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发基础之内存模型</title>
      <link href="/2019/03/25/java/java-duo-xian-cheng/bing-fa-san-wen-ti/"/>
      <url>/2019/03/25/java/java-duo-xian-cheng/bing-fa-san-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>本文的主要目的是让大家对于并发程序中的重排序、内存可见性以及原子性有一定的了解，同时要能准确理解 synchronized、volatile、final 几个关键字的作用。</p><p>另外，本文还对<strong>双重检查形式的单例模式为什么需要使用 volatile</strong> 做了深入的解释。</p><!-- toc --><h2 id="并发三问题"><a href="#并发三问题" class="headerlink" title="并发三问题"></a>并发三问题</h2><p>这节将介绍重排序、内存可见性以及原子性相关的知识，这些也是并发程序为什么难写的原因。</p><h3 id="1-重排序"><a href="#1-重排序" class="headerlink" title="1. 重排序"></a>1. 重排序</h3><p>请读者先在自己的电脑上运行一下以下程序：</p><pre><code class="java">public class Test {    private static int x = 0, y = 0;    private static int a = 0, b =0;    public static void main(String[] args) throws InterruptedException {        int i = 0;        for(;;) {            i++;            x = 0; y = 0;            a = 0; b = 0;            CountDownLatch latch = new CountDownLatch(1);            Thread one = new Thread(() -&gt; {                try {                    latch.await();                } catch (InterruptedException e) {                }                a = 1;                x = b;            });            Thread other = new Thread(() -&gt; {                try {                    latch.await();                } catch (InterruptedException e) {                }                b = 1;                y = a;            });            one.start();other.start();            latch.countDown();            one.join();other.join();            String result = &quot;第&quot; + i + &quot;次 (&quot; + x + &quot;,&quot; + y + &quot;）&quot;;            if(x == 0 &amp;&amp; y == 0) {                System.err.println(result);                break;            } else {                System.out.println(result);            }        }    }}</code></pre><p>几秒后，我们就可以得到 <code>x == 0 &amp;&amp; y == 0</code> 这个结果，仔细看看代码就会知道，如果不发生重排序的话，这个结果是不可能出现的。</p><p><strong>重排序由以下几种机制引起：</strong></p><ol><li><p>编译器优化：对于没有数据依赖关系的操作，编译器在编译的过程中会进行一定程度的重排。</p><blockquote><p>大家仔细看看线程 1 中的代码，编译器是可以将 a = 1 和 x = b 换一下顺序的，因为它们之间没有数据依赖关系，同理，线程 2 也一样，那就不难得到 x == y == 0 这种结果了。</p></blockquote></li><li><p>指令重排序：CPU 优化行为，也是会对不存在数据依赖关系的指令进行一定程度的重排。</p><blockquote><p>这个和编译器优化差不多，就算编译器不发生重排，CPU 也可以对指令进行重排，这个就不用多说了。</p></blockquote></li><li><p>内存系统重排序：内存系统没有重排序，但是由于有缓存的存在，使得程序整体上会表现出乱序的行为。</p><blockquote><p>假设不发生编译器重排和指令重排，线程 1 修改了 a 的值，但是修改以后，a 的值可能还没有写回到主存中，那么线程 2 得到 a == 0 就是很自然的事了。同理，线程 2 对于 b 的赋值操作也可能没有及时刷新到主存中。</p></blockquote></li></ol><h3 id="2-内存可见性"><a href="#2-内存可见性" class="headerlink" title="2. 内存可见性"></a>2. 内存可见性</h3><p>前面在说重排序的时候，也说到了内存可见性的问题，这里再啰嗦一下。</p><p>线程间的对于共享变量的可见性问题<strong>不是直接由多核引起的，而是由多缓存引起的</strong>。如果每个核心共享同一个缓存，那么也就不存在内存可见性问题了。</p><p>现代多核 CPU 中每个核心拥有自己的一级缓存或一级缓存加上二级缓存等，问题就发生在每个核心的独占缓存上。每个核心都会将自己需要的数据读到独占缓存中，数据修改后也是写入到缓存中，然后等待刷入到主存中。所以会导致有些核心读取的值是一个<strong>过期</strong>的值。</p><p>Java 作为高级语言，屏蔽了这些底层细节，用 JMM 定义了一套读写内存数据的规范，虽然我们不再需要关心一级缓存和二级缓存的问题，但是，JMM 抽象了<strong>主内存</strong>和<strong>本地内存</strong>的概念。</p><p>所有的共享变量存在于主内存中，<strong>每个线程有自己的本地内存</strong>，线程读写共享数据也是通过本地内存交换的，所以可见性问题依然是存在的。这里说的本地内存并不是真的是一块给每个线程分配的内存，而是 JMM 的一个抽象，是对于寄存器、一级缓存、二级缓存等的抽象。</p><h3 id="3-原子性"><a href="#3-原子性" class="headerlink" title="3. 原子性"></a>3. 原子性</h3><p>在本文中，原子性不是重点，它将作为并发编程中需要考虑的一部分进行介绍。</p><p>说到原子性的时候，大家应该都能想到 long 和 double，它们的值需要占用 64 位的内存空间，Java 编程语言规范中提到，对于 64 位的值的写入，可以分为两个 32 位的操作进行写入。本来一个整体的赋值操作，被拆分为低 32 位赋值和高 32 位赋值两个操作，中间如果发生了其他线程对于这个值的读操作，必然就会读到一个奇怪的值。</p><p>这个时候我们要使用 volatile 关键字进行控制了，JMM 规定了对于 volatile long 和 volatile double，JVM 需要保证写入操作的原子性。</p><p>另外，对于<strong>引用的读写操作始终是原子的，不管是 32 位的机器还是 64 位的机器</strong>。</p><p>Java 编程语言规范同样提到，鼓励 JVM 的开发者能保证 64 位值操作的原子性，也鼓励使用者尽量使用 volatile 或使用正确的同步方式。关键词是”鼓励“。</p><blockquote><p>在 64 位的 JVM 中，不加 volatile 也是可以的，同样能保证对于 long 和 double 写操作的原子性。关于这一点，我没有找到官方的材料描述它，如果读者有相关的信息，希望可以给我反馈一下。</p></blockquote><h2 id="Java-对于并发的规范约束"><a href="#Java-对于并发的规范约束" class="headerlink" title="Java 对于并发的规范约束"></a>Java 对于并发的规范约束</h2><p>并发问题使得我们的代码有可能会产生各种各样的执行结果，显然这是我们不能接受的，所以 Java 编程语言规范需要规定一些基本规则，JVM 实现者会在这些规则的约束下来实现 JVM，然后开发者也要按照规则来写代码，这样写出来的并发代码我们才能准确预测执行结果。下面进行一些简单的介绍。</p><h3 id="Synchronization-Order"><a href="#Synchronization-Order" class="headerlink" title="Synchronization Order"></a>Synchronization Order</h3><p>Java 语言规范对于同步定义了一系列的规则：<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.4" target="_blank" rel="noopener">17.4.4. Synchronization Order</a>，包括了如下同步关系：</p><ul><li><p>对于监视器 m 的解锁与所有后续操作对于 m 的加锁同步</p></li><li><p>对 volatile 变量 v 的写入，与所有其他线程后续对 v 的读同步</p></li><li><p>启动线程的操作与线程中的第一个操作同步。</p></li><li><p>对于每个属性写入默认值（0， false，null）与每个线程对其进行的操作同步。</p><p>尽管在创建对象完成之前对对象属性写入默认值有点奇怪，但从概念上来说，每个对象都是在程序启动时用默认值初始化来创建的。</p></li><li><p>线程 T1 的最后操作与线程 T2 发现线程 T1 已经结束同步。</p><p>线程 T2 可以通过 T1.isAlive() 或 T1.join() 方法来判断 T1 是否已经终结。</p></li><li><p>如果线程 T1 中断了 T2，那么线程 T1 的中断操作与其他所有线程发现 T2 被中断了同步（通过抛出 InterruptedException 异常，或者调用 Thread.interrupted 或 Thread.isInterrupted ）</p></li></ul><h3 id="Happens-before-Order"><a href="#Happens-before-Order" class="headerlink" title="Happens-before Order"></a>Happens-before Order</h3><p>两个操作可以用 happens-before 来确定它们的执行顺序，如果一个操作 happens-before 于另一个操作，那么我们说第一个操作对于第二个操作是可见的。</p><p>如果我们分别有操作 x 和操作 y，我们写成 <strong>hb(x, y)</strong> 来表示 <strong>x happens-before y</strong>。以下几个规则也是来自于 Java 8 语言规范 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html#jls-17.4.5" target="_blank" rel="noopener">Happens-before Order</a>：</p><ul><li><p>如果操作 x 和操作 y 是同一个线程的两个操作，并且在代码上操作 x 先于操作 y 出现，那么有 hb(x, y)</p></li><li><p>对象构造方法的最后一行指令 happens-before 于 finalize() 方法的第一行指令。</p></li><li><p>如果操作 x 与随后的操作 y 构成同步，那么 hb(x, y)。这条说的是前面一小节的内容。</p></li><li><p>hb(x, y) 和 hb(y, z)，那么可以推断出 hb(x, z)</p></li></ul><p>这里再提一点，x happens-before y，并不是说 x 操作一定要在 y 操作之前被执行，而是说 x 的执行结果对于 y 是可见的，只要满足可见性，发生了重排序也是可以的。</p><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><blockquote><p>monitor，这里翻译成监视器锁，为了大家理解方便。</p></blockquote><p>synchronized 这个关键字大家都用得很多了，这里不会教你怎么使用它，我们来看看它对于内存可见性的影响。</p><p>一个线程在获取到监视器锁以后才能进入 synchronized 控制的代码块，一旦进入代码块，首先，该<strong>线程对于共享变量的缓存就会失效</strong>，因此 <strong>synchronized 代码块中对于共享变量的读取需要从主内存中重新获取</strong>，也就能获取到最新的值。</p><p>退出代码块的时候的，会将该线程写缓冲区中的数据刷到主内存中，所以在 synchronized 代码块之前或 synchronized 代码块中对于共享变量的操作随着该线程退出 synchronized 块，会立即对其他线程可见（<strong>这句话的前提是其他读取共享变量的线程会从主内存读取最新值</strong>）。</p><p>因此，我们可以总结一下：<strong>线程 a 对于进入 synchronized 块之前或在 synchronized 中对于共享变量的操作，对于后续的持有同一个监视器锁的线程 b 可见</strong>。虽然是挺简单的一句话，请读者好好体会。</p><p>注意一点，在进入 <code>synchronized</code> 的时候，<strong>并不会保证之前的写操作刷入到主内存中，synchronized 主要是保证退出的时候能将本地内存的数据刷入到主内存</strong>。</p><h2 id="单例模式中的双重检查"><a href="#单例模式中的双重检查" class="headerlink" title="单例模式中的双重检查"></a>单例模式中的双重检查</h2><p>我们趁热打铁，为大家解决下单例模式中的双重检查问题。关于这个问题，大神们发过<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">文章</a>对此进行阐述了，这里搬运一下。</p><blockquote><p>来膜拜下文章署名中的大神们：<a href="http://www.research.ibm.com/people/d/dfb" target="_blank" rel="noopener">David Bacon</a> (IBM Research) Joshua Bloch (Javasoft), <a href="http://www.cs.ucsb.edu/~bogda/" target="_blank" rel="noopener">Jeff Bogda</a>, Cliff Click (Hotspot JVM project), <a href="http://www.webcom.com/~haahr/" target="_blank" rel="noopener">Paul Haahr</a>, <a href="http://www.cs.oswego.edu/~dl" target="_blank" rel="noopener">Doug Lea</a>, <a href="mailto:tom@go2net.com" target="_blank" rel="noopener">Tom May</a>, <a href="http://www.csg.lcs.mit.edu/~earwig/" target="_blank" rel="noopener">Jan-Willem Maessen</a>, <a href="http://www.cs.umd.edu/~jmanson" target="_blank" rel="noopener">Jeremy Manson</a>, <a href="http://www.jguru.com/johnm" target="_blank" rel="noopener">John D. Mitchell (jGuru)</a> Kelvin Nilsen, <a href="http://www.cs.umd.edu/~pugh" target="_blank" rel="noopener">Bill Pugh</a>, <a href="http://www.cs.washington.edu/homes/egs/" target="_blank" rel="noopener">Emin Gun Sirer</a>，至少 Joshua Bloch 和 Doug Lea 大家都不陌生吧。</p></blockquote><p>废话少说，看以下单例模式的写法：</p><pre><code class="java">public class Singleton {    private static Singleton instance = null;    private int v;    private Singleton() {        this.v = 3;    }    public static Singleton getInstance() {        if (instance == null) { // 1. 第一次检查            synchronized (Singleton.class) { // 2                if (instance == null) { // 3. 第二次检查                    instance = new Singleton(); // 4                }            }        }        return instance;    }}</code></pre><p>很多人都知道上述的写法是不对的，但是可能会说不清楚到底为什么不对。</p><p>我们假设有两个线程 a 和 b 调用 getInstance() 方法，假设 a 先走，一路走到 4 这一步，执行  <code>instance = new Singleton()</code> 这句代码。</p><p>instance = new Singleton() 这句代码<strong>首先会申请一段空间</strong>，<strong>然后将各个属性初始化为零值(0/null)</strong>，<strong>执行构造方法中的属性赋值[1]</strong>，<strong>将这个对象的引用赋值给 instance[2]</strong>。在这个过程中，[1] 和 [2] 可能会发生重排序。</p><p>此时，线程 b 刚刚进来执行到 1（看上面的代码块），就有可能会看到 instance 不为 null，然后线程 b 也就不会等待监视器锁，而是直接返回 instance。问题是这个 instance 可能还没执行完构造方法（线程 a 此时还在 4 这一步），所以线程 b 拿到的 instance 是<strong>不完整的</strong>，它里面的属性值可能是初始化的零值(0/false/null)，而不是线程 a 在构造方法中指定的值。</p><blockquote><p>回顾下前面的知识，分析下这里为什么会有这个问题。</p><p>1、编译器可以将构造方法内联过来，之后再发生重排序就很容易理解了。</p><p>2、即使不发生代码重排序，线程 a 对于属性的赋值写入到了线程 a 的本地内存中，此时对于线程 b 不可见。</p></blockquote><p>最后提一点，如果线程 a 从 synchronized 块出来了，那么 instance 一定是正确构造的<strong>完整</strong>实例，这是我们前面说过的 synchronized 的内存可见性保证。</p><p>—————分割线————— </p><p>对于大部分读者来说，这一小节其实可以结束了，很多读者都知道，解决方案是使用 volatile 关键字，这个我们在介绍 volatile 的时候再说。当然，如果你还有耐心，也可以继续看看本小节。</p><p>我们看下下面这段代码，看看它能不能解决我们之前碰到的问题。</p><pre><code class="java">public static Singleton getInstance() {    if (instance == null) { //        Singleton temp;        synchronized (Singleton.class) { //            temp = instance;            if (temp == null) { //                synchronized (Singleton.class) { // 内嵌一个 synchronized 块                    temp = new Singleton();                }                instance = temp; //            }        }    }    return instance;}</code></pre><p>上面这个代码很有趣，想利用 synchronized 的内存可见性语义，不过这个解决方案还是失败了，我们分析下。</p><p>前面我们也说了，<strong>synchronized 在退出的时候，能保证 synchronized 块中对于共享变量的写入一定会刷入到主内存中</strong>。也就是说，上述代码中，内嵌的 synchronized 结束的时候，temp 一定是完整构造出来的，然后再赋给 instance 的值一定是好的。</p><p>可是，synchronized 保证了释放监视器锁之前的代码一定会在释放锁之前被执行（如 temp 的初始化一定会在释放锁之前执行完 ），但是没有任何规则规定了，释放锁之后的代码不可以在释放锁之前先执行。</p><p>也就是说，代码中释放锁之后的行为 <code>instance = temp</code> 完全可以被提前到前面的 synchronized 代码块中执行，那么前面说的重排序问题就又出现了。</p><p>最后扯一点，如果所有的属性都是使用 final 修饰的，其实之前介绍的双重检查是可行的，不需要加 volatile，这个等到 final 那节再介绍。</p><h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>大部分开发者应该都知道怎么使用这个关键字，只是可能不太了解个中缘由。</p><p><strong>如果你下次面试的时候有人问你 volatile 的作用，记住两点：内存可见性和禁止指令重排序。</strong></p><h3 id="volatile-的内存可见性"><a href="#volatile-的内存可见性" class="headerlink" title="volatile 的内存可见性"></a>volatile 的内存可见性</h3><p>我们还是用 JMM 的<strong>主内存</strong>和<strong>本地内存</strong>抽象来描述，这样比较准确。还有，并不是只有 Java 语言才有 volatile 关键字，所以后面的描述一定要建立在 Java 跨平台以后抽象出了内存模型的这个大环境下。</p><p>还记得 synchronized 的语义吗？进入 synchronized 时，使得本地缓存失效，synchronized 块中对共享变量的读取必须从主内存读取；退出 synchronized 时，会将进入 synchronized 块之前和 synchronized 块中的写操作刷入到主存中。</p><p>volatile 有类似的语义，读一个 volatile 变量之前，需要先使相应的本地缓存失效，这样就必须到主内存读取最新值，写一个 volatile 属性会立即刷入到主内存。所以，volatile 读和 monitorenter 有相同的语义，volatile 写和 monitorexit 有相同的语义。</p><h3 id="volatile-的禁止重排序"><a href="#volatile-的禁止重排序" class="headerlink" title="volatile 的禁止重排序"></a>volatile 的禁止重排序</h3><p>大家还记得之前的双重检查的单例模式吧，前面提到，加个 volatile 能解决问题。其实就是利用了 volatile 的禁止重排序功能。</p><p>volatile 的禁止重排序并不局限于两个 volatile 的属性操作不能重排序，而且是 volatile 属性操作和它周围的普通属性的操作也不能重排序。</p><p>之前 instance = new Singleton() 中，如果 instance 是 volatile 的，那么对于 instance 的赋值操作（赋一个引用给 instance 变量）就不会和构造函数中的属性赋值发生重排序，能保证构造方法结束后，才将此对象引用赋值给 instance。</p><p>根据 volatile 的内存可见性和禁止重排序，那么我们不难得出一个推论：线程 a 如果写入一个 volatile 变量，此时线程 b 再读取这个变量，那么此时对于线程 a 可见的所有属性对于线程 b 都是可见的。</p><h3 id="volatile-小结"><a href="#volatile-小结" class="headerlink" title="volatile 小结"></a>volatile 小结</h3><ol><li>volatile 修饰符适用于以下场景：某个属性被多个线程共享，其中有一个线程修改了此属性，其他线程可以立即得到修改后的值。在并发包的源码中，它使用得非常多。</li><li>volatile 属性的读写操作都是无锁的，它不能替代 synchronized，因为<strong>它没有提供原子性和互斥性</strong>。因为无锁，不需要花费时间在获取锁和释放锁上，所以说它是低成本的。</li><li>volatile 只能作用于属性，我们用 volatile 修饰属性，这样 compilers 就不会对这个属性做指令重排序。</li><li>volatile 提供了可见性，任何一个线程对其的修改将立马对其他线程可见。volatile 属性不会被线程缓存，始终从主存中读取。</li><li>volatile 提供了 happens-before 保证，对 volatile 变量 v 的写入 happens-before 所有其他线程后续对 v 的读操作。</li><li>volatile 可以使得 long 和 double 的赋值是原子的，前面在说原子性的时候提到过。</li></ol><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><p><strong>用 final 修饰的类不可以被继承，用 final 修饰的方法不可以被覆写，用 final 修饰的属性一旦初始化以后不可以被修改</strong>。当然，我们不关心这些段子，这节，我们来看看 final 带来的内存可见性影响。</p><p>之前在说双重检查的单例模式的时候，提过了一句，如果所有的属性都使用了 final 修饰，那么 volatile 也是可以不要的，这就是 final 带来的可见性影响。</p><p>在对象的构造方法中设置 final 属性，<strong>同时在对象初始化完成前，不要将此对象的引用写入到其他线程可以访问到的地方</strong>（不要让引用在构造函数中逸出）。如果这个条件满足，当其他线程看到这个对象的时候，那个线程始终可以看到正确初始化后的对象的 final 属性。</p><p>上面说得很明白了，final 属性的写操作不会和此引用的赋值操作发生重排序，如：</p><pre><code class="java">x.finalField = v; ...; sharedRef = x;</code></pre><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><strong>参考资料：</strong></p><p>javadoop:<a href="https://javadoop.com/post/java-memory-model#toc10" target="_blank" rel="noopener">https://javadoop.com/post/java-memory-model#toc10</a></p><p>JSR 133：<a href="https://jcp.org/en/jsr/detail?id=133" target="_blank" rel="noopener">https://jcp.org/en/jsr/detail?id=133</a></p><p>The “Double-Checked Locking is Broken” Declaration：<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html</a></p><p>美团点评技术团队：<a href="https://tech.meituan.com/java-memory-reordering.html" target="_blank" rel="noopener">https://tech.meituan.com/java-memory-reordering.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于synchronized关键字</title>
      <link href="/2019/03/25/java/java-duo-xian-cheng/guan-yu-synchronized-guan-jian-zi/"/>
      <url>/2019/03/25/java/java-duo-xian-cheng/guan-yu-synchronized-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<p>#面试中关于 synchronized 关键字的 5 连击</p><p>##1.1 说一说自己对于 synchronized 关键字的了解</p><p>synchronized关键字解决的是==多个线程之间访问资源的同步性，<strong>synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行</strong>。</p><p>另外，在 Java 早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，<strong>Java 的线程是映射到操作系统的原生线程之上的</strong>。==如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态==，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如<strong>自旋锁</strong>、<strong>适应性自旋锁</strong>、<strong>锁消除</strong>、<strong>锁粗化</strong>、<strong>偏向锁</strong>、<strong>轻量级锁</strong>等技术来减少锁操作的开销。</p><h2 id="1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="1.2 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>1.2 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h2><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li><li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</strong> 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li></ul><p>下面我以一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p><p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单利模式的原理呗！”</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><pre><code class="java">public class Singleton {    private volatile static Singleton uniqueInstance;    private Singleton() {    }    public static Singleton getUniqueInstance() {       //先判断对象是否已经实例过，没有实例化过才进入加锁代码        if (uniqueInstance == null) {            //类对象加锁            synchronized (Singleton.class) {                if (uniqueInstance == null) {                    uniqueInstance = new Singleton();                }            }        }        return uniqueInstance;    }}</code></pre><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的，<strong>uniqueInstance = new Singleton();</strong> 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 volatile 可以<strong>禁止 JVM 的指令重排</strong>，保证在多线程环境下也能正常运行。</p><p>##1.3 讲一下 synchronized 关键字的底层原理</p><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>① synchronized 同步语句块的情况</strong></p><pre><code class="java">public class SynchronizedDemo {    public void method() {        synchronized (this) {            System.out.println(&quot;synchronized 代码块&quot;);        }    }}</code></pre><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024217.png" alt="synchronized 关键字原理"></p><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 ==monitorenter== 和 ==monitorexit== 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>② synchronized 修饰方法的的情况</strong></p><pre><code class="java">public class SynchronizedDemo2 {    public synchronized void method() {        System.out.println(&quot;synchronized 方法&quot;);    }}</code></pre><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019-07-down/024218.png" alt="synchronized 关键字原理"></p><h2 id="1-4-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗"><a href="#1-4-说说-JDK1-6-之后的synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗" class="headerlink" title="1.4 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗"></a>1.4 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h2><p>JDK1.6 对锁的实现引入了大量的优化，如==偏向锁==、==轻量级锁==、==自旋锁==、==适应性自旋锁==、==锁消除==、==锁粗化==等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：==无锁状态==、==偏向锁状态==、==轻量级锁状态==、==重量级锁状态==，他们会随着竞争的激烈而逐渐升级。==注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率==。</p><p>###<strong>偏向锁</strong></p><p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p><p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步！</p><p>但是对于==锁竞争比较激烈的场合==，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p><p>###<strong>轻量级锁</strong></p><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong></p><p><strong>轻量级锁能够提升程序同步性能的依据是“==对于绝大部分锁，在整个同步周期内都是不存在竞争的==”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p><h3 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a><strong>自旋锁和自适应自旋</strong></h3><p>轻量级锁失败后，==虚拟机为了避免线程真实地在操作系统层面挂起==，还会进行一项称为自旋锁的优化手段。</p><p>==<strong>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</strong>==</p><p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。</p><p>百度百科对自旋锁的解释：</p><blockquote><p>何谓自旋锁？它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p></blockquote><p>自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：==自旋等待不能完全替代阻塞，因为它还是要占用处理器时间==。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。==如果自旋超过了限定次数任然没有获得锁，就应该挂起线程==。<strong>自旋次数的默认值是10次，用户可以修改–XX:PreBlockSpin来更改</strong>。</p><p>另外,<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不再固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a><strong>锁消除</strong></h3><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，对于一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除可以节省毫无意义的请求锁的时间。</p><h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a><strong>锁粗化</strong></h3><p>原则上，我们在编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p><p>##1.5 Synchronized 和 ReenTrantLock 的对比</p><p>###<strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>知识点补充：</strong></p><p>什么是可重入锁以及实际应用场景？</p><p><strong>什么是可重入锁呢？</strong></p><p>当一个线程获取了某个对象锁以后，还可以再次获得该对象锁。</p><p><strong>什么时候我们会用到可重入锁呢？</strong></p><p>看下面的demo</p><pre><code class="java">public class Demo1 {    public synchronized void functionA(){        System.out.println(&quot;iAmFunctionA&quot;);        functionB();    }    public synchronized void functionB(){        System.out.println(&quot;iAmFunctionB&quot;);    }}</code></pre><p>代码解释：</p><p>functionA()和functionB()都是同步方法，当线程进入funcitonA()会获得该类的对象锁，这个锁”new Demo1()”，在functionA()对方法functionB()做了调用，但是functionB()也是同步的，因此该线程需要再次获得该对象锁（new Demo1()）。其他线程是无法获该对象锁的。这就是可重入锁。</p><p><strong>可重入锁的作用就是为了避免死锁，java中synchronized和ReentrantLock都是可重入锁</strong></p><p>###<strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p>###<strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：</p><p><strong>①等待可中断；</strong></p><p><strong>②可实现公平锁；</strong></p><p><strong>③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><p>###<strong>④ 性能已不是选择标准</strong></p><p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量随着线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于volatile关键字</title>
      <link href="/2019/03/25/java/java-duo-xian-cheng/volatile/"/>
      <url>/2019/03/25/java/java-duo-xian-cheng/volatile/</url>
      
        <content type="html"><![CDATA[<h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是<br>    <strong>立即可见</strong>的。<br>2）禁止进行指令重排序。volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取;synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</p><p><strong>知识补充：</strong></p><p>1.线程安全的两个方面：<strong>执行控制</strong>和<strong>内存可见</strong>。</p><p><strong>执行控制</strong>的目的是控制代码执行（顺序）及是否可以并发执行。</p><p><strong>内存可见</strong>控制的是线程执行结果在内存中对其它线程的可见性。根据Java内存模型的实现，线程在具体执行时，会先拷贝主存数据到线程本地（CPU缓存），操作完成后再把结果从线程本地刷到主存。</p><p>2.java内存模型中，多线程对主内存变量的读写情形描述：</p><p>在 java 的内存模型中每一个线程运行时都有一个线程栈，线程栈保存了线程运行时候变量值信息。当线程访问<br>某一个对象值的时候，首先通过对象的引用找到对应在堆内存的变量的值，然后<strong>把堆内存变量的具体值load到线</strong><br><strong>程本地内存中，建立一个变量副本</strong>，之后线程就不再和对象在堆内存变量值有任何关系，而是直接修改副本变量的值，<strong>在修改完之后的某一个时刻（线程退出之前），自动把线程变量副本的值回写到对象在堆中变量</strong>。这样在堆中的对象的值就产生变化了。</p><p>简单的说，多线程执行过程中都是操作的本地内存中共享变量的副本，只有到线程推退出前，才刷新到主内存中。</p><h1 id="volatile变量的可见性"><a href="#volatile变量的可见性" class="headerlink" title="volatile变量的可见性"></a>volatile变量的可见性</h1><p>可见性：指的是线程访问变量是否是最新值。</p><p>局部变量不存在可见性问题，而共享内存就会有可见性问题，因为本地线程在创建的时候，会从主存中读取一个共享变量的副本，且修改也是修改副本，且并不是立即刷新到主存中去，那么其他线程并不会马上共享变量的修改。</p><blockquote><p>解决共享变量可见性问题，需要用volatile关键字修饰。</p></blockquote><p>可见性的特性总结为以下2点：</p><ul><li>对volatile变量的写会立即刷新到主存</li><li>对volatile变量的读会读主存中的新值</li></ul><p>为了能更深刻的理解volatile的语义，我们来看下面的时序图，回答这2个问题：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-025830.png" alt="image-20190318151824712"></p><p><strong>问题1：t2时刻，如果线程A读取running变量，会读取到false，还是等待线程B执行完呢？</strong></p><p>答案是会读到false，不会等待线程B执行完，因为volatile并没有锁的特性。</p><p><strong>问题2：t4时刻，线程A是否一定能读取到线程B修改后的最新值</strong></p><p>答案是肯定的，线程A会从重新从主存中读取running的最新值。</p><h1 id="volatile变量的原子性"><a href="#volatile变量的原子性" class="headerlink" title="volatile变量的原子性"></a>volatile变量的原子性</h1><p>volatile变量的原子性指的是<strong>写操作</strong>，这里的原子性的特别总结为2点：</p><ul><li>对一个volatile变量的写操作，只有所有步骤完成，才能被其它线程读取到。</li><li>多个线程对volatile变量的写操作本质上是有先后顺序的。也就是说并发写没有问题。</li></ul><p>为了区分volatile变量和非volatile变量的区别，我们来举个例子：</p><pre><code class="java">//线程1初始化UserUser user;user = new User();//线程2读取userif(user!=null){user.getName();}</code></pre><p>在多线程并发环境下，线程2读取到的user可能未初始化完成，具体来看User user = new User的语义：</p><ol><li>分配对象的内存空间</li><li>初始化对象</li><li>设置user指向刚分配的内存地址</li></ol><p>步骤2和步骤3可能会被重排序，流程变为</p><p>1-&gt;3-&gt;2</p><p>这样线程1在执行完第3步而还没来得及执行完第2步的时候，如果内存刷新到了主存，那么线程2将得到一个未初始化完成的对象。因此如果将user声明为volatile的，那么步骤2,3将不会被重排序。</p><p>下面我们来看一个具体案例，一个基于双重检查的懒加载的单例模式实现：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-025900.png" alt="image-20190318152827001"></p><p>这个单例模式看起来很完美，如果instance为空，则加锁，只有一个线程进入同步块完成对象的初始化，然后instance不为空，那么后续的所有线程获取instance都不用加锁，从而提升了性能。</p><p>但是我们刚才讲了对象赋值操作步骤可能会存在重排序，即当前线程的步骤4执行到一半，其它线程如果进来执行到步骤1，instance已经不为null（执行完了步骤3，没执行步骤2），因此将会读取到一个没有初始化完成的对象。</p><p>但如果将instance用volatile来修饰，就完全不一样了，对instance的写入操作将会变成一个原子操作，没有初始化完，就不会被刷新到主存中。</p><p>修改后的单例模式代码如下：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-025906.png" alt="image-20190318153600790"></p><p>#对volatile理解的误区</p><p>很多人会认为对volatile变量的所有操作都是原子性的，比如自增i++</p><p>其实是不对的。</p><p>i++操作分为3个步骤</p><ol><li>读取i=0</li><li>计算i+1=1</li><li>重新赋值给i=1</li></ol><p>那么可能存在2个线程同时读取到i=0，并计算出结果i=1然后赋值给i，那么其中一个i的值就会被覆盖，得不到预期结果i=2。</p><p>分析：</p><p>==volatile变量只能保证可见性和禁止指令重排，并不能保证操作的原子性**。</p><h1 id="volatile和synchronized的区别"><a href="#volatile和synchronized的区别" class="headerlink" title="volatile和synchronized的区别"></a>volatile和synchronized的区别</h1><p>synchronized关键字和volatile关键字比较</p><ul><li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li><li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li><li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li><li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li><li><strong>volatile标记的变量不会被编译器优化（禁止指令重排序优化，即执行顺序与程序顺序一致）；</strong><br><strong>synchronized标记的变量可以被编译器优化</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap 和 ConcurrentHashMap</title>
      <link href="/2019/03/16/java/collection/hashmap-he-concurrenthashmap/"/>
      <url>/2019/03/16/java/collection/hashmap-he-concurrenthashmap/</url>
      
        <content type="html"><![CDATA[<p>阅读建议：四节基本上可以进行独立阅读，建议初学者可按照 Java7 HashMap -&gt; Java7 ConcurrentHashMap -&gt; Java8 HashMap -&gt; Java8 ConcurrentHashMap 顺序进行阅读，可适当降低阅读门槛。</p><p>阅读前提：本文分析的是源码，所以至少读者要熟悉它们的接口使用，同时，对于并发，读者至少要知道 CAS、ReentrantLock、UNSAFE 操作这几个基本的知识，文中不会对这些知识进行介绍。Java8 用到了红黑树，不过本文不会进行展开，感兴趣的读者请自行查找相关资料。</p><!-- toc --><h2 id="Java7-HashMap"><a href="#Java7-HashMap" class="headerlink" title="Java7 HashMap"></a>Java7 HashMap</h2><p>HashMap 是最简单的，一来我们非常熟悉，二来就是它不支持并发操作，所以源码也非常简单。</p><p>首先，我们用下面这张图来介绍 HashMap 的结构。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031105.png" alt="1"></p><blockquote><p>这个仅仅是示意图，因为没有考虑到数组要扩容的情况，具体的后面再说。</p></blockquote><p>大方向上，HashMap 里面是一个<strong>数组</strong>，然后数组中每个元素是一个<strong>单向链表</strong>。</p><p>上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。</p><p>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</p><p>loadFactor：负载因子，默认为 0.75。</p><p>threshold：扩容的阈值，等于 capacity * loadFactor</p><h3 id="put-过程分析"><a href="#put-过程分析" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>还是比较简单的，跟着代码走一遍吧。</p><pre><code class="java">public V put(K key, V value) {    // 当插入第一个元素的时候，需要先初始化数组大小    if (table == EMPTY_TABLE) {        inflateTable(threshold);    }    // 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中    if (key == null)        return putForNullKey(value);    // 1. 求 key 的 hash 值    int hash = hash(key);    // 2. 找到对应的数组下标    int i = indexFor(hash, table.length);    // 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，    //    如果有，直接覆盖，put 方法返回旧值就结束了    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    modCount++;    // 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说    addEntry(hash, key, value, i);    return null;}</code></pre><h4 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h4><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值。</p><pre><code class="java">private void inflateTable(int toSize) {    // 保证数组大小一定是 2 的 n 次方。    // 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32    int capacity = roundUpToPowerOf2(toSize);    // 计算扩容阈值：capacity * loadFactor    threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);    // 算是初始化数组吧    table = new Entry[capacity];    initHashSeedAsNeeded(capacity); //ignore}</code></pre><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><h4 id="计算具体数组位置"><a href="#计算具体数组位置" class="headerlink" title="计算具体数组位置"></a>计算具体数组位置</h4><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。</p><pre><code class="java">static int indexFor(int hash, int length) {    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;    return hash &amp; (length-1);}</code></pre><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><h4 id="添加节点到链表中"><a href="#添加节点到链表中" class="headerlink" title="添加节点到链表中"></a>添加节点到链表中</h4><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的<strong>表头</strong>。</p><pre><code class="java">void addEntry(int hash, K key, V value, int bucketIndex) {    // 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {        // 扩容，后面会介绍一下        resize(2 * table.length);        // 扩容以后，重新计算 hash 值        hash = (null != key) ? hash(key) : 0;        // 重新计算扩容后的新的下标        bucketIndex = indexFor(hash, table.length);    }    // 往下看    createEntry(hash, key, value, bucketIndex);}// 这个很简单，其实就是将新值放到链表的表头，然后 size++void createEntry(int hash, K key, V value, int bucketIndex) {    Entry&lt;K,V&gt; e = table[bucketIndex];    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);    size++;}</code></pre><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>前面我们看到，在插入新值的时候，如果<strong>当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素</strong>，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。</p><pre><code class="java">void resize(int newCapacity) {    Entry[] oldTable = table;    int oldCapacity = oldTable.length;    if (oldCapacity == MAXIMUM_CAPACITY) {        threshold = Integer.MAX_VALUE;        return;    }    // 新的数组    Entry[] newTable = new Entry[newCapacity];    // 将原来数组中的值迁移到新的更大的数组中    transfer(newTable, initHashSeedAsNeeded(newCapacity));    table = newTable;    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);}</code></pre><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><h3 id="get-过程分析"><a href="#get-过程分析" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 过程，get 过程是非常简单的。</p><ol><li>根据 key 计算 hash 值。</li><li>找到相应的数组下标：hash &amp; (length - 1)。</li><li>遍历该数组位置处的链表，直到找到相等(==或equals)的 key。</li></ol><pre><code class="java">public V get(Object key) {    // 之前说过，key 为 null 的话，会被放到 table[0]，所以只要遍历下 table[0] 处的链表就可以了    if (key == null)        return getForNullKey();    //     Entry&lt;K,V&gt; entry = getEntry(key);    return null == entry ? null : entry.getValue();}</code></pre><p>getEntry(key):</p><pre><code class="java">final Entry&lt;K,V&gt; getEntry(Object key) {    if (size == 0) {        return null;    }    int hash = (key == null) ? 0 : hash(key);    // 确定数组下标，然后从头开始遍历链表，直到找到为止    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];         e != null;         e = e.next) {        Object k;        if (e.hash == hash &amp;&amp;            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))            return e;    }    return null;}</code></pre><h2 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a>Java7 ConcurrentHashMap</h2><p>ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。</p><p>整个 ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<strong>分段锁</strong>。注意，行文中，我很多地方用了“<strong>槽</strong>”来代表一个 segment。</p><p>简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031106.png" alt="3"></p><p><strong>concurrencyLevel</strong>：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。==默认是 16==，<strong>也就是说 ConcurrentHashMap 有 16 个 Segments</strong>，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>initialCapacity：初始容量，这个值指的是整个 ConcurrentHashMap 的初始容量，实际操作的时候需要平均分给每个 Segment。</p><p>loadFactor：负载因子，之前我们说了，Segment 数组不可以扩容，所以这个负载因子是给每个 Segment 内部使用的。</p><pre><code class="java">public ConcurrentHashMap(int initialCapacity,                         float loadFactor, int concurrencyLevel) {    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)        throw new IllegalArgumentException();    if (concurrencyLevel &gt; MAX_SEGMENTS)        concurrencyLevel = MAX_SEGMENTS;    // Find power-of-two sizes best matching arguments    int sshift = 0;    int ssize = 1;    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方    while (ssize &lt; concurrencyLevel) {        ++sshift;        ssize &lt;&lt;= 1;    }    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值    this.segmentShift = 32 - sshift;    this.segmentMask = ssize - 1;    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    // initialCapacity 是设置整个 map 初始的大小，    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小    // 如 initialCapacity 为 64，那么每个 Segment 或称之为&quot;槽&quot;可以分到 4 个    int c = initialCapacity / ssize;    if (c * ssize &lt; initialCapacity)        ++c;    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，    // 插入一个元素不至于扩容，插入第二个的时候才会扩容    int cap = MIN_SEGMENT_TABLE_CAPACITY;     while (cap &lt; c)        cap &lt;&lt;= 1;    // 创建 Segment 数组，    // 并创建数组的第一个元素 segment[0]    Segment&lt;K,V&gt; s0 =        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];    // 往数组写入 segment[0]    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]    this.segments = ss;}</code></pre><p>初始化完成，我们得到了一个 Segment 数组。</p><p>我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，<strong>负载因子是 0.75</strong>，<strong>得出初始阈值为 1.5</strong>，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为<strong>移位数</strong>和<strong>掩码</strong>，这两个值马上就会用到</li></ul><h3 id="put-过程分析-1"><a href="#put-过程分析-1" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><pre><code class="java">public V put(K key, V value) {    Segment&lt;K,V&gt; s;    if (value == null)        throw new NullPointerException();    // 1. 计算 key 的 hash 值    int hash = hash(key);    // 2. 根据 hash 值找到 Segment 数组中的位置 j    //    hash 是 32 位，无符号右移 segmentShift(28) 位，剩下高 4 位，    //    然后和 segmentMask(15) 做一次与操作，也就是说 j 是 hash 值的高 4 位，也就是槽的数组下标    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;    // 刚刚说了，初始化的时候初始化了 segment[0]，但是其他位置还是 null，    // ensureSegment(j) 对 segment[j] 进行初始化    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment        s = ensureSegment(j);    // 3. 插入新值到 槽 s 中    return s.put(key, hash, value, false);}</code></pre><p>第一层皮很简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 <strong>数组+链表</strong> 组成的。</p><pre><code class="java">final V put(K key, int hash, V value, boolean onlyIfAbsent) {    // 在往该 segment 写入前，需要先获取该 segment 的独占锁    //    先看主流程，后面还会具体介绍这部分内容    HashEntry&lt;K,V&gt; node = tryLock() ? null :        scanAndLockForPut(key, hash, value);    V oldValue;    try {        // 这个是 segment 内部的数组        HashEntry&lt;K,V&gt;[] tab = table;        // 再利用 hash 值，求应该放置的数组下标        int index = (tab.length - 1) &amp; hash;        // first 是数组该位置处的链表的表头        HashEntry&lt;K,V&gt; first = entryAt(tab, index);        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况        for (HashEntry&lt;K,V&gt; e = first;;) {            if (e != null) {                K k;                if ((k = e.key) == key ||                    (e.hash == hash &amp;&amp; key.equals(k))) {                    oldValue = e.value;                    if (!onlyIfAbsent) {                        // 覆盖旧值                        e.value = value;                        ++modCount;                    }                    break;                }                // 继续顺着链表走                e = e.next;            }            else {                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。                if (node != null)                    node.setNext(first);                else                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);                int c = count + 1;                // 如果超过了该 segment 的阈值，这个 segment 需要扩容                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)                    rehash(node); // 扩容后面也会具体分析                else                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，                    // 其实就是将新的节点设置成原链表的表头                    setEntryAt(tab, index, node);                ++modCount;                count = c;                oldValue = null;                break;            }        }    } finally {        // 解锁        unlock();    }    return oldValue;}</code></pre><p>整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>总的来说，==put的同步机制是如果没有其他线程在更新该段，那么直接put。否则轮询请求锁，直至获得锁==。</p><p>到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><h4 id="初始化槽-ensureSegment"><a href="#初始化槽-ensureSegment" class="headerlink" title="初始化槽: ensureSegment"></a>初始化槽: ensureSegment</h4><p>ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><pre><code class="java">private Segment&lt;K,V&gt; ensureSegment(int k) {    final Segment&lt;K,V&gt;[] ss = this.segments;    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset    Segment&lt;K,V&gt; seg;    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {        // 这里看到为什么之前要初始化 segment[0] 了，        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了        Segment&lt;K,V&gt; proto = ss[0];        int cap = proto.table.length;        float lf = proto.loadFactor;        int threshold = (int)(cap * lf);        // 初始化 segment[k] 内部的数组        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))            == null) { // 再次检查一遍该槽是否被其他线程初始化了。            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))                   == null) {                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))                    break;            }        }    }    return seg;}</code></pre><p>总的来说，ensureSegment(int k) 比较简单，<strong>对于并发操作使用 CAS 进行控制</strong>。</p><blockquote><p>我没搞懂这里为什么要搞一个 while 循环，CAS 失败不就代表有其他线程成功了吗，为什么要再进行判断？</p><p>感谢评论区的<strong>李子木</strong>，如果当前线程 CAS 失败，这里的 while 循环是为了将 seg 赋值返回。</p></blockquote><h4 id="获取写入锁-scanAndLockForPut"><a href="#获取写入锁-scanAndLockForPut" class="headerlink" title="获取写入锁: scanAndLockForPut"></a>获取写入锁: scanAndLockForPut</h4><p>前面我们看到，在往某个 segment 中 put 的时候，首先会调用  <strong>node = tryLock() ? null : scanAndLockForPut(key, hash, value)</strong>，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><pre><code class="java">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);    HashEntry&lt;K,V&gt; e = first;    HashEntry&lt;K,V&gt; node = null;    int retries = -1; // negative while locating node    // 循环获取锁    while (!tryLock()) {        HashEntry&lt;K,V&gt; f; // to recheck first below        if (retries &lt; 0) {            if (e == null) {                if (node == null) // speculatively create node                    // 进到这里说明数组该位置的链表是空的，没有任何元素                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);                retries = 0;            }            else if (key.equals(e.key))                retries = 0;            else                // 顺着链表往下走                e = e.next;        }        // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁        //    lock() 是阻塞方法，直到获取锁后返回        else if (++retries &gt; MAX_SCAN_RETRIES) {            lock();            break;        }        else if ((retries &amp; 1) == 0 &amp;&amp;                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法                 (f = entryForHash(this, hash)) != first) {            e = first = f; // re-traverse if entry changed            retries = -1;        }    }    return node;}</code></pre><p>这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>这个方法就是看似复杂，但是其实就是做了一件事，那就是<strong>获取该 segment 的独占锁</strong>，如果需要的话顺便实例化了一下 node。</p><p>补充：</p><p>put操作一旦未获得锁 while (!tryLock()) 则进行重试循环。</p><p>第一次重试中retries &lt; 0，如果桶条目不为空，那么遍历桶中条目链表，如果key已经存在，那么直接进入下一个循环，否则构造新条目，进入下一个循环；如果重试次数达到极限，那么使用阻塞同步方法；每隔一次循环，校验下所在桶有没有更新，如果更新了，那么重试次数重置，重新开始。</p><p>一旦获得锁，直接返回，进行常规的hash put操作。</p><h4 id="扩容-rehash"><a href="#扩容-rehash" class="headerlink" title="扩容: rehash"></a>扩容: rehash</h4><p>重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry&lt;K,V&gt;[] 进行扩容，扩容后，容量为原来的 2 倍。</p><p>首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><pre><code class="java">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。private void rehash(HashEntry&lt;K,V&gt; node) {    HashEntry&lt;K,V&gt;[] oldTable = table;    int oldCapacity = oldTable.length;    // 2 倍    int newCapacity = oldCapacity &lt;&lt; 1;    threshold = (int)(newCapacity * loadFactor);    // 创建新数组    HashEntry&lt;K,V&gt;[] newTable =        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’    int sizeMask = newCapacity - 1;    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置    for (int i = 0; i &lt; oldCapacity ; i++) {        // e 是链表的第一个元素        HashEntry&lt;K,V&gt; e = oldTable[i];        if (e != null) {            HashEntry&lt;K,V&gt; next = e.next;            // 计算应该放置在新数组中的位置，            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19            int idx = e.hash &amp; sizeMask;            if (next == null)   // 该位置处只有一个元素，那比较好办                newTable[idx] = e;            else { // Reuse consecutive sequence at same slot                // e 是链表表头                HashEntry&lt;K,V&gt; lastRun = e;                // idx 是当前链表的头结点 e 的新位置                int lastIdx = idx;                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的                for (HashEntry&lt;K,V&gt; last = next;                     last != null;                     last = last.next) {                    int k = last.hash &amp; sizeMask;                    if (k != lastIdx) {                        lastIdx = k;                        lastRun = last;                    }                }                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置                newTable[lastIdx] = lastRun;                // 下面的操作是处理 lastRun 之前的节点，                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {                    V v = p.value;                    int h = p.hash;                    int k = h &amp; sizeMask;                    HashEntry&lt;K,V&gt; n = newTable[k];                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);                }            }        }    }    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部    int nodeIndex = node.hash &amp; sizeMask; // add the new node    node.setNext(newTable[nodeIndex]);    newTable[nodeIndex] = node;    table = newTable;}</code></pre><p>这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p><p>仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<strong>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆</strong>。</p><h3 id="get-过程分析-1"><a href="#get-过程分析-1" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><pre><code class="java">public V get(Object key) {    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead    HashEntry&lt;K,V&gt;[] tab;    // 1. hash 值    int h = hash(key);    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;    // 2. 根据 hash 找到对应的 segment    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;        (tab = s.table) != null) {        // 3. 找到segment 内部数组相应位置的链表，遍历        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);             e != null; e = e.next) {            K k;            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))                return e.value;        }    }    return null;}</code></pre><h3 id="并发问题分析"><a href="#并发问题分析" class="headerlink" title="并发问题分析"></a>并发问题分析</h3><p>现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>添加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ol><li><p>put 操作的线程安全性。</p><ol><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ol></li><li><p>remove 操作的线程安全性。</p><p>remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。</p><p>get 操作需要遍历链表，但是 remove 操作会”破坏”链表。</p><p>如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。</p><p>如果 remove 先破坏了一个节点，分两种情况考虑。  1、如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。2、如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</p></li></ol><h2 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a>Java8 HashMap</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 <strong>数组+链表+红黑树</strong> 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 <strong>O(n)</strong>。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素达到了 8 个时，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 <strong>==O(logN)==</strong>。</p><p>来一张图简单示意一下吧：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031107.png" alt="2"></p><blockquote><p>注意，上图是示意图，主要是描述结构，不会达到这个状态的，因为这么多数据的时候早就扩容了。</p></blockquote><p>下面，我们还是用代码来介绍吧，个人感觉，Java8 的源码可读性要差一些，不过精简一些。</p><p>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 <strong>Node</strong>，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong>TreeNode</strong>。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="put-过程分析-2"><a href="#put-过程分析-2" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><pre><code class="java">public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作// 第四个参数 evict 我们这里不关心final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度    // 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {// 数组该位置有数据        Node&lt;K,V&gt; e; K k;        // 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是&quot;相等&quot;，如果是，取出这个节点        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        // 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            // 到这里，说明数组该位置上是一个链表            for (int binCount = 0; ; ++binCount) {                // 插入到链表的最后面(Java7 是插入到链表的最前面)                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    // TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 8 个                    // 会触发下面的 treeifyBin，也就是将链表转换为红黑树                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                // 如果在该链表中找到了&quot;相等&quot;的 key(== 或 equals)                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    // 此时 break，那么 e 为链表中[与要插入的新值的 key &quot;相等&quot;]的 node                    break;                p = e;            }        }        // e!=null 说明存在旧值的key与要插入的key&quot;相等&quot;        // 对于我们分析的put操作，下面这个 if 其实就是进行 &quot;值覆盖&quot;，然后返回旧值        if (e != null) {            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    // 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p>==和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容==，不过这个不重要。</p><h4 id="数组扩容-1"><a href="#数组扩容-1" class="headerlink" title="数组扩容"></a>数组扩容</h4><p>resize() 方法用于<strong>初始化数组</strong>或<strong>数组扩容</strong>，每次扩容后，容量为原来的 2 倍，并进行数据迁移。</p><pre><code class="java">final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) { // 对应数组扩容        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        // 将数组大小扩大一倍        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            // 将阈值扩大一倍            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候        newCap = oldThr;    else {// 对应使用 new HashMap() 初始化后，第一次 put 的时候        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    // 用新的数组大小初始化新的数组    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab; // 如果是初始化数组，到这里就结束了，返回 newTab 即可    if (oldTab != null) {        // 开始遍历原数组，进行数据迁移。        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                // 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                // 如果是红黑树，具体我们就不展开了                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else {                     // 这块是处理链表的情况，                    // 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序                    // loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do {                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    if (loTail != null) {                        loTail.next = null;                        // 第一条链表                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        // 第二条链表的新的位置是 j + oldCap，这个很好理解                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><h3 id="get-过程分析-2"><a href="#get-过程分析-2" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>相对于 put 来说，get 真的太简单了。</p><ol><li>计算 key 的 hash 值，根据 hash 值找到对应数组下标: hash &amp; (length-1)</li><li>判断数组该位置处的元素是否刚好就是我们要找的，如果不是，走第三步</li><li>判断该元素类型是否是 TreeNode，如果是，用红黑树的方法取数据，如果不是，走第四步</li><li>遍历链表，直到找到相等(==或equals)的 key</li></ol><pre><code class="java">public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}</code></pre><pre><code class="java">final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        // 判断第一个节点是不是就是需要的        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            // 判断是否是红黑树            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            // 链表遍历            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><h2 id="Java8-ConcurrentHashMap"><a href="#Java8-ConcurrentHashMap" class="headerlink" title="Java8 ConcurrentHashMap"></a>Java8 ConcurrentHashMap</h2><p>Java7 中实现的 ConcurrentHashMap 说实话还是比较复杂的，Java8 对 ConcurrentHashMap 进行了比较大的改动。建议读者可以参考 Java8 中 HashMap 相对于 Java7 HashMap 的改动，对于 ConcurrentHashMap，Java8 也引入了红黑树。</p><p><strong>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。</strong></p><p>我们先用一个示意图来描述下其结构：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031108.png" alt="4"></p><p>结构上和 Java8 的 HashMap 基本上一样，不过它要保证线程安全性，所以在源码上确实要复杂一些。</p><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><pre><code class="java">// 这构造函数里，什么都不干public ConcurrentHashMap() {}</code></pre><pre><code class="java">public ConcurrentHashMap(int initialCapacity) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException();    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?               MAXIMUM_CAPACITY :               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));    this.sizeCtl = cap;}</code></pre><p>这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = 【 (1.5 * initialCapacity + 1)，然后向上取最近的 2 的 n 次方】。如 initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><p>sizeCtl 这个属性使用的场景很多，不过只要跟着文章的思路来，就不会被它搞晕了。</p><p>如果你爱折腾，也可以看下另一个有三个参数的构造方法，这里我就不说了，大部分时候，我们会使用无参构造函数进行实例化，我们也按照这个思路来进行源码分析吧。</p><h3 id="put-过程分析-3"><a href="#put-过程分析-3" class="headerlink" title="put 过程分析"></a>put 过程分析</h3><p>仔细地一行一行代码看下去：</p><pre><code class="java">public V put(K key, V value) {    return putVal(key, value, false);}</code></pre><pre><code class="java">final V putVal(K key, V value, boolean onlyIfAbsent) {    if (key == null || value == null) throw new NullPointerException();    // 得到 hash 值    int hash = spread(key.hashCode());    // 用于记录相应链表的长度    int binCount = 0;    for (Node&lt;K,V&gt;[] tab = table;;) {        Node&lt;K,V&gt; f; int n, i, fh;        // 如果数组&quot;空&quot;，进行数组初始化        if (tab == null || (n = tab.length) == 0)            // 初始化数组，后面会详细介绍            tab = initTable();        // 找该 hash 值对应的数组下标，得到第一个节点 f        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {            // 如果数组该位置为空，            //    用一次 CAS 操作将这个新值放入其中即可，这个 put 操作差不多就结束了，可以拉到最后面了            //          如果 CAS 失败，那就是有并发操作，进到下一个循环就好了            if (casTabAt(tab, i, null,                         new Node&lt;K,V&gt;(hash, key, value, null)))                break;                   // no lock when adding to empty bin        }        // hash 居然可以等于 MOVED，这个需要到后面才能看明白，不过从名字上也能猜到，肯定是因为在扩容        else if ((fh = f.hash) == MOVED)            // 帮助数据迁移，这个等到看完数据迁移部分的介绍后，再理解这个就很简单了            tab = helpTransfer(tab, f);        else { // 到这里就是说，f 是该位置的头结点，而且不为空            V oldVal = null;            // 获取数组该位置的头结点的监视器锁            synchronized (f) {                if (tabAt(tab, i) == f) {                    if (fh &gt;= 0) { // 头结点的 hash 值大于 0，说明是链表                        // 用于累加，记录链表的长度                        binCount = 1;                        // 遍历链表                        for (Node&lt;K,V&gt; e = f;; ++binCount) {                            K ek;                            // 如果发现了&quot;相等&quot;的 key，判断是否要进行值覆盖，然后也就可以 break 了                            if (e.hash == hash &amp;&amp;                                ((ek = e.key) == key ||                                 (ek != null &amp;&amp; key.equals(ek)))) {                                oldVal = e.val;                                if (!onlyIfAbsent)                                    e.val = value;                                break;                            }                            // 到了链表的最末端，将这个新值放到链表的最后面                            Node&lt;K,V&gt; pred = e;                            if ((e = e.next) == null) {                                pred.next = new Node&lt;K,V&gt;(hash, key,                                                          value, null);                                break;                            }                        }                    }                    else if (f instanceof TreeBin) { // 红黑树                        Node&lt;K,V&gt; p;                        binCount = 2;                        // 调用红黑树的插值方法插入新节点                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,                                                       value)) != null) {                            oldVal = p.val;                            if (!onlyIfAbsent)                                p.val = value;                        }                    }                }            }            if (binCount != 0) {                // 判断是否要将链表转换为红黑树，临界值和 HashMap 一样，也是 8                if (binCount &gt;= TREEIFY_THRESHOLD)                    // 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，                    // 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树                    //    具体源码我们就不看了，扩容部分后面说                    treeifyBin(tab, i);                if (oldVal != null)                    return oldVal;                break;            }        }    }    //     addCount(1L, binCount);    return null;}</code></pre><p>put 的主流程看完了，但是至少留下了几个问题，第一个是初始化，第二个是扩容，第三个是帮助数据迁移，这些我们都会在后面进行一一介绍。</p><h4 id="初始化数组：initTable"><a href="#初始化数组：initTable" class="headerlink" title="初始化数组：initTable"></a>初始化数组：initTable</h4><p>这个比较简单，主要就是初始化一个<strong>合适大小</strong>的数组，然后会设置 sizeCtl。</p><p>初始化方法中的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。</p><pre><code class="java">private final Node&lt;K,V&gt;[] initTable() {    Node&lt;K,V&gt;[] tab; int sc;    while ((tab = table) == null || tab.length == 0) {        // 初始化的&quot;功劳&quot;被其他线程&quot;抢去&quot;了        if ((sc = sizeCtl) &lt; 0)            Thread.yield(); // lost initialization race; just spin        // CAS 一下，将 sizeCtl 设置为 -1，代表抢到了锁        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {            try {                if ((tab = table) == null || tab.length == 0) {                    // DEFAULT_CAPACITY 默认初始容量是 16                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;                              // 初始化数组，长度为 16 或初始化时提供的长度                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                    // 将这个数组赋值给 table，table 是 volatile 的                    table = tab = nt;                    // 如果 n 为 16 的话，那么这里 sc = 12                    // 其实就是 0.75 * n                    sc = n - (n &gt;&gt;&gt; 2);                }            } finally {                // 设置 sizeCtl 为 sc，我们就当是 12 吧                sizeCtl = sc;            }            break;        }    }    return tab;}</code></pre><h4 id="链表转红黑树-treeifyBin"><a href="#链表转红黑树-treeifyBin" class="headerlink" title="链表转红黑树: treeifyBin"></a>链表转红黑树: treeifyBin</h4><p>前面我们在 put 源码分析也说过，treeifyBin 不一定就会进行红黑树转换，也可能是仅仅做数组扩容。我们还是进行源码分析吧。</p><pre><code class="java">private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {    Node&lt;K,V&gt; b; int n, sc;    if (tab != null) {        // MIN_TREEIFY_CAPACITY 为 64        // 所以，如果数组长度小于 64 的时候，其实也就是 32 或者 16 或者更小的时候，会进行数组扩容        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)            // 后面我们再详细分析这个方法            tryPresize(n &lt;&lt; 1);        // b 是头结点        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {            // 加锁            synchronized (b) {                if (tabAt(tab, index) == b) {                    // 下面就是遍历链表，建立一颗红黑树                    TreeNode&lt;K,V&gt; hd = null, tl = null;                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {                        TreeNode&lt;K,V&gt; p =                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,                                              null, null);                        if ((p.prev = tl) == null)                            hd = p;                        else                            tl.next = p;                        tl = p;                    }                    // 将红黑树设置到数组相应位置中                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));                }            }        }    }}</code></pre><h3 id="扩容：tryPresize"><a href="#扩容：tryPresize" class="headerlink" title="扩容：tryPresize"></a>扩容：tryPresize</h3><p>如果说 Java8 ConcurrentHashMap 的源码不简单，那么说的就是扩容操作和迁移操作。</p><p>这个方法要完完全全看懂还需要看之后的 transfer 方法，读者应该提前知道这点。</p><p>这里的扩容也是做翻倍扩容的，扩容后数组容量为原来的 2 倍。</p><pre><code class="java">// 首先要说明的是，方法参数 size 传进来的时候就已经翻了倍了private final void tryPresize(int size) {    // c：size 的 1.5 倍，再加 1，再往上取最近的 2 的 n 次方。    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);    int sc;    while ((sc = sizeCtl) &gt;= 0) {        Node&lt;K,V&gt;[] tab = table; int n;        // 这个 if 分支和之前说的初始化数组的代码基本上是一样的，在这里，我们可以不用管这块代码        if (tab == null || (n = tab.length) == 0) {            n = (sc &gt; c) ? sc : c;            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {                try {                    if (table == tab) {                        @SuppressWarnings(&quot;unchecked&quot;)                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];                        table = nt;                        sc = n - (n &gt;&gt;&gt; 2); // 0.75 * n                    }                } finally {                    sizeCtl = sc;                }            }        }        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)            break;        else if (tab == table) {            // 我没看懂 rs 的真正含义是什么，不过也关系不大            int rs = resizeStamp(n);            if (sc &lt; 0) {                Node&lt;K,V&gt;[] nt;                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||                    transferIndex &lt;= 0)                    break;                // 2. 用 CAS 将 sizeCtl 加 1，然后执行 transfer 方法                //    此时 nextTab 不为 null                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))                    transfer(tab, nt);            }            // 1. 将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)            //     我是没看懂这个值真正的意义是什么？不过可以计算出来的是，结果是一个比较大的负数            //  调用 transfer 方法，此时 nextTab 参数为 null            else if (U.compareAndSwapInt(this, SIZECTL, sc,                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))                transfer(tab, null);        }    }}</code></pre><p>这个方法的核心在于 sizeCtl 值的操作，首先将其设置为一个负数，然后执行 transfer(tab, null)，再下一个循环将 sizeCtl 加 1，并执行 transfer(tab, nt)，之后可能是继续 sizeCtl 加 1，并执行 transfer(tab, nt)。</p><p>所以，可能的操作就是执行 <strong>1 次 transfer(tab, null) + 多次 transfer(tab, nt)</strong>，这里怎么结束循环的需要看完 transfer 源码才清楚。</p><h4 id="数据迁移：transfer"><a href="#数据迁移：transfer" class="headerlink" title="数据迁移：transfer"></a>数据迁移：transfer</h4><p>下面这个方法很点长，将原来的 tab 数组的元素迁移到新的 nextTab 数组中。</p><p>虽然我们之前说的 tryPresize 方法中多次调用 transfer 不涉及多线程，但是这个 transfer 方法可以在其他地方被调用，典型地，我们之前在说 put 方法的时候就说过了，请往上看 put 方法，是不是有个地方调用了 helpTransfer 方法，helpTransfer 方法会调用 transfer 方法的。</p><p>此方法支持多线程执行，外围调用此方法的时候，会保证第一个发起数据迁移的线程，nextTab 参数为 null，之后再调用此方法的时候，nextTab 不会为 null。</p><p>阅读源码之前，先要理解并发操作的机制。原数组长度为 n，所以我们有 n 个迁移任务，让每个线程每次负责一个小任务是最简单的，每做完一个任务再检测是否有其他没做完的任务，帮助迁移就可以了，而 Doug Lea 使用了一个 stride，简单理解就是<strong>步长</strong>，每个线程每次负责迁移其中的一部分，如每次迁移 16 个小任务。所以，我们就需要一个全局的调度者来安排哪个线程执行哪几个任务，这个就是属性 transferIndex 的作用。</p><p>第一个发起数据迁移的线程会将 transferIndex 指向原数组最后的位置，然后<strong>从后往前</strong>的 stride 个任务属于第一个线程，然后将 transferIndex 指向新的位置，再往前的 stride 个任务属于第二个线程，依此类推。当然，这里说的第二个线程不是真的一定指代了第二个线程，也可以是同一个线程，这个读者应该能理解吧。其实就是将一个大的迁移任务分为了一个个任务包。</p><pre><code class="java">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {    int n = tab.length, stride;    // stride 在单核下直接等于 n，多核模式下为 (n&gt;&gt;&gt;3)/NCPU，最小值是 16    // stride 可以理解为”步长“，有 n 个位置是需要进行迁移的，    //   将这 n 个任务分为多个任务包，每个任务包有 stride 个任务    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)        stride = MIN_TRANSFER_STRIDE; // subdivide range    // 如果 nextTab 为 null，先进行一次初始化    //    前面我们说了，外围会保证第一个发起迁移的线程调用此方法时，参数 nextTab 为 null    //       之后参与迁移的线程调用此方法时，nextTab 不会为 null    if (nextTab == null) {        try {            // 容量翻倍            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];            nextTab = nt;        } catch (Throwable ex) {      // try to cope with OOME            sizeCtl = Integer.MAX_VALUE;            return;        }        // nextTable 是 ConcurrentHashMap 中的属性        nextTable = nextTab;        // transferIndex 也是 ConcurrentHashMap 的属性，用于控制迁移的位置        transferIndex = n;    }    int nextn = nextTab.length;    // ForwardingNode 翻译过来就是正在被迁移的 Node    // 这个构造方法会生成一个Node，key、value 和 next 都为 null，关键是 hash 为 MOVED    // 后面我们会看到，原数组中位置 i 处的节点完成迁移工作后，    //    就会将位置 i 处设置为这个 ForwardingNode，用来告诉其他线程该位置已经处理过了    //    所以它其实相当于是一个标志。    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);    // advance 指的是做完了一个位置的迁移工作，可以准备做下一个位置的了    boolean advance = true;    boolean finishing = false; // to ensure sweep before committing nextTab    /*     * 下面这个 for 循环，最难理解的在前面，而要看懂它们，应该先看懂后面的，然后再倒回来看     *      */    // i 是位置索引，bound 是边界，注意是从后往前    for (int i = 0, bound = 0;;) {        Node&lt;K,V&gt; f; int fh;        // 下面这个 while 真的是不好理解        // advance 为 true 表示可以进行下一个位置的迁移了        //   简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride        while (advance) {            int nextIndex, nextBound;            if (--i &gt;= bound || finishing)                advance = false;            // 将 transferIndex 值赋给 nextIndex            // 这里 transferIndex 一旦小于等于 0，说明原数组的所有位置都有相应的线程去处理了            else if ((nextIndex = transferIndex) &lt;= 0) {                i = -1;                advance = false;            }            else if (U.compareAndSwapInt                     (this, TRANSFERINDEX, nextIndex,                      nextBound = (nextIndex &gt; stride ?                                   nextIndex - stride : 0))) {                // 看括号中的代码，nextBound 是这次迁移任务的边界，注意，是从后往前                bound = nextBound;                i = nextIndex - 1;                advance = false;            }        }        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {            int sc;            if (finishing) {                // 所有的迁移操作已经完成                nextTable = null;                // 将新的 nextTab 赋值给 table 属性，完成迁移                table = nextTab;                // 重新计算 sizeCtl：n 是原数组长度，所以 sizeCtl 得出的值将是新数组长度的 0.75 倍                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);                return;            }            // 之前我们说过，sizeCtl 在迁移前会设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2            // 然后，每有一个线程参与迁移就会将 sizeCtl 加 1，            // 这里使用 CAS 操作对 sizeCtl 进行减 1，代表做完了属于自己的任务            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {                // 任务结束，方法退出                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)                    return;                // 到这里，说明 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，                // 也就是说，所有的迁移任务都做完了，也就会进入到上面的 if(finishing){} 分支了                finishing = advance = true;                i = n; // recheck before commit            }        }        // 如果位置 i 处是空的，没有任何节点，那么放入刚刚初始化的 ForwardingNode ”空节点“        else if ((f = tabAt(tab, i)) == null)            advance = casTabAt(tab, i, null, fwd);        // 该位置处是一个 ForwardingNode，代表该位置已经迁移过了        else if ((fh = f.hash) == MOVED)            advance = true; // already processed        else {            // 对数组该位置处的结点加锁，开始处理数组该位置处的迁移工作            synchronized (f) {                if (tabAt(tab, i) == f) {                    Node&lt;K,V&gt; ln, hn;                    // 头结点的 hash 大于 0，说明是链表的 Node 节点                    if (fh &gt;= 0) {                        // 下面这一块和 Java7 中的 ConcurrentHashMap 迁移是差不多的，                        // 需要将链表一分为二，                        //   找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的                        //   lastRun 之前的节点需要进行克隆，然后分到两个链表中                        int runBit = fh &amp; n;                        Node&lt;K,V&gt; lastRun = f;                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {                            int b = p.hash &amp; n;                            if (b != runBit) {                                runBit = b;                                lastRun = p;                            }                        }                        if (runBit == 0) {                            ln = lastRun;                            hn = null;                        }                        else {                            hn = lastRun;                            ln = null;                        }                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {                            int ph = p.hash; K pk = p.key; V pv = p.val;                            if ((ph &amp; n) == 0)                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);                            else                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);                        }                        // 其中的一个链表放在新数组的位置 i                        setTabAt(nextTab, i, ln);                        // 另一个链表放在新数组的位置 i+n                        setTabAt(nextTab, i + n, hn);                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了                        setTabAt(tab, i, fwd);                        // advance 设置为 true，代表该位置已经迁移完毕                        advance = true;                    }                    else if (f instanceof TreeBin) {                        // 红黑树的迁移                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;                        TreeNode&lt;K,V&gt; lo = null, loTail = null;                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;                        int lc = 0, hc = 0;                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {                            int h = e.hash;                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;                                (h, e.key, e.val, null, null);                            if ((h &amp; n) == 0) {                                if ((p.prev = loTail) == null)                                    lo = p;                                else                                    loTail.next = p;                                loTail = p;                                ++lc;                            }                            else {                                if ((p.prev = hiTail) == null)                                    hi = p;                                else                                    hiTail.next = p;                                hiTail = p;                                ++hc;                            }                        }                        // 如果一分为二后，节点数少于 8，那么将红黑树转换回链表                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;                        // 将 ln 放置在新数组的位置 i                        setTabAt(nextTab, i, ln);                        // 将 hn 放置在新数组的位置 i+n                        setTabAt(nextTab, i + n, hn);                        // 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，                        //    其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了                        setTabAt(tab, i, fwd);                        // advance 设置为 true，代表该位置已经迁移完毕                        advance = true;                    }                }            }        }    }}</code></pre><p>说到底，transfer 这个方法并没有实现所有的迁移任务，每次调用这个方法只实现了 transferIndex 往前 stride 个位置的迁移工作，其他的需要由外围来控制。</p><p>这个时候，再回去仔细看 tryPresize 方法可能就会更加清晰一些了。</p><h3 id="get-过程分析-3"><a href="#get-过程分析-3" class="headerlink" title="get 过程分析"></a>get 过程分析</h3><p>get 方法从来都是最简单的，这里也不例外：</p><ol><li>计算 hash 值</li><li>根据 hash 值找到数组对应位置: (n - 1) &amp; h</li><li>根据该位置处结点性质进行相应查找<ul><li>如果该位置为 null，那么直接返回 null 就可以了</li><li>如果该位置处的节点刚好就是我们需要的，返回该节点的值即可</li><li>如果该位置节点的 hash 值小于 0，说明正在扩容，或者是红黑树，后面我们再介绍 find 方法</li><li>如果以上 3 条都不满足，那就是链表，进行遍历比对即可</li></ul></li></ol><pre><code class="java">public V get(Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;    int h = spread(key.hashCode());    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (e = tabAt(tab, (n - 1) &amp; h)) != null) {        // 判断头结点是否就是我们需要的节点        if ((eh = e.hash) == h) {            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))                return e.val;        }        // 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树        else if (eh &lt; 0)            // 参考 ForwardingNode.find(int h, Object k) 和 TreeBin.find(int h, Object k)            return (p = e.find(h, key)) != null ? p.val : null;        // 遍历链表        while ((e = e.next) != null) {            if (e.hash == h &amp;&amp;                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))                return e.val;        }    }    return null;}</code></pre><p>简单说一句，此方法的大部分内容都很简单，只有正好碰到扩容的情况，ForwardingNode.find(int h, Object k) 稍微复杂一些，不过在了解了数据迁移的过程后，这个也就不难了，所以限于篇幅这里也不展开说了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实也不是很难嘛，虽然没有像之前的 AQS 和线程池一样一行一行源码进行分析，但还是把所有初学者可能会糊涂的地方都进行了深入的介绍，只要是稍微有点基础的读者，应该是很容易就能看懂 HashMap 和 ConcurrentHashMap 源码了。</p><p>#HashMap 线程不安全的典型表现(java8前)</p><p>HashMap是一个数组链表，当一个key/Value对被加入时，首先会通过Hash算法定位出这个键值对要被放入的桶，然后就把它插到相应桶中。如果这个桶中已经有元素了，那么发生了碰撞，这样会在这个桶中形成一个链表。一般来说，当有数据要插入HashMap时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大HashMap的尺寸，但是这样一来，就需要对整个HashMap里的节点进行重哈希操作。</p><p>jdk1.7 HashMap重哈希的关键源码如下：</p><pre><code class="java"> /**     * Transfers all entries from current table to newTable.     */    void transfer(Entry[] newTable) {        // 将原数组 table 赋给数组 src        Entry[] src = table;        int newCapacity = newTable.length;        // 将数组 src 中的每条链重新添加到 newTable 中        for (int j = 0; j &lt; src.length; j++) {            Entry&lt;K,V&gt; e = src[j];            if (e != null) {                src[j] = null;   // src 回收                // 将每条链的每个元素依次添加到 newTable 中相应的桶中                do {                    Entry&lt;K,V&gt; next = e.next;                    // e.hash指的是 hash(key.hashCode())的返回值;                    // 计算在newTable中的位置，注意原来在同一条子链上的元素可能被分配到不同的桶中                    int i = indexFor(e.hash, newCapacity);                       e.next = newTable[i];                    newTable[i] = e;                    e = next;                } while (e != null);            }        }    }</code></pre><h2 id="1、单线程环境下的重哈希过程演示"><a href="#1、单线程环境下的重哈希过程演示" class="headerlink" title="1、单线程环境下的重哈希过程演示"></a><strong>1、单线程环境下的重哈希过程演示</strong></h2><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031108.jpg" alt="HashMap-rehash1.jpg-68kB"></p><p>单线程情况下，rehash 不会出现任何问题，如上图所示。假设hash算法就是最简单的 key mod table.length（也就是桶的个数）。最上面的是old hash表，其中的Hash表桶的个数为2， 所以对于 key = 3、7、5 的键值对在 mod 2以后都冲突在table[1]这里了。接下来的三个步骤是，Hash表resize成4，然后对所有的键值对重哈希的过程。</p><p>##<strong>2、多线程环境下的重哈希过程演示</strong></p><p>　假设我们有两个线程，我用红色和浅蓝色标注了一下，被这两个线程共享的资源正是要被重哈希的原来1号桶中的Entry链。我们再回头看一下我们的transfer代码中的这个细节：</p><pre><code class="java">do {    Entry&lt;K,V&gt; next = e.next;       // &lt;--假设线程一执行到这里就被调度挂起了    int i = indexFor(e.hash, newCapacity);    e.next = newTable[i];    newTable[i] = e;    e = next;} while (e != null);</code></pre><p>而我们的线程二执行完成了，于是我们有下面的这个样子：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031109.jpg" alt="HashMap-rehash2.jpg-39.8kB"></p><p>注意，在Thread2重哈希后，Thread1的指针e和指针next分别指向了Thread2重组后的链表(e指向了key(3)，而next指向了key(7))。此时，Thread1被调度回来执行：Thread1先是执行 newTalbe[i] = e;然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)，如下图所示：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031110.jpg" alt="HashMap-rehash3.jpg-35.9kB"></p><p>这时，一切安好。Thread1有条不紊的工作着：把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移，如下图所示：</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-031111.jpg" alt="HashMap-rehash4.jpg-45.7kB"></p><p>在此时，特别需要注意的是，当执行e.next = newTable[i]后，会导致 key(3).next 指向了 key(7)，而此时的key(7).next 已经指向了key(3)，环形链表就这样出现了，如下图所示。于是，当我们的Thread1调用HashMap.get(11)时，悲剧就出现了 —— Infinite Loop。</p><p><img src="http://xuxinghua-blog.oss-cn-zhangjiakou.aliyuncs.com/2019/2019-07-15-31112.jpg" alt="HashMap-rehash5.jpg-41.1kB"></p><h1 id="重写equals-和重写hashCode"><a href="#重写equals-和重写hashCode" class="headerlink" title="重写equals()和重写hashCode()"></a>重写equals()和重写hashCode()</h1><p>equals()方法在Object类中的定义:</p><pre><code class="java">public boolean equals(Object obj){    return (this == obj);}</code></pre><p>equals()的定义为：</p><pre><code class="java">public native int hashCode();</code></pre><p>是一个本地方法，返回的对象的地址值。</p><p>则在往hashmap中添加对象时，</p><p>##只重写equals()而没重写hashCode()：</p><p>比如：</p><pre><code class="java">map.put(new Student(&quot;xxh&quot;,25),1);map.put(new Student(&quot;xxh&quot;,25),2);</code></pre><p>不会有覆盖存在。因为</p><pre><code class="java">if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</code></pre><p><strong>e.hash == hash不能相同，所以不会进去到if语句中执行替换操作</strong>。</p><p>出现的结果：</p><p><strong>Map.Entry</strong>可能存在不同的槽中（也可能hash值不同但是hash取模操作得到相同的hash值），map中会存在相同的键key（具体来说就是相同的学生即姓名和年龄相同），对应了不同的value，无法满足业务要求（业务要求姓名年龄相同的学生视为一个学生）。</p><p><strong>get操作</strong>：</p><p>由于没有重写hashcode()，所以业务上相等的对象(student的姓名和年龄相同)，无法定位到事先存储student的槽中，并且就算定位到了，也会因为hashcode不相等而取不到对应的value，只能是<strong>null</strong>。</p><p>##只重写hashCode()而没重写equals()：</p><p>不会存在覆盖。</p><p><strong>(k = e.key) == key || key.equals(k))不可能相同，所以也不会进去到if语句中执行替换操作。</strong></p><p>出现的结果：</p><p><strong>Map.Entry</strong>在同一槽中的链表里，会存在业务方面的相同的key(就是说，相同的学生key对应了2个不同的value)</p><p><strong>get操作：</strong></p><p><strong>key.equals(k)</strong>不满足，因为equals底层是”==”，比较对象的地址，所以业务上相等的对象(student的姓名和年龄相同)，能定位到事先存储student的槽中，但是因为<strong>key.equals(k)=false</strong>，取得<strong>null</strong>。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://javadoop.com/post/hashmap" target="_blank" rel="noopener">https://javadoop.com/post/hashmap</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合类 </tag>
            
            <tag> HashMap </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
